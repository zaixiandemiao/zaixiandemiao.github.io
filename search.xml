<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[TreeMap]]></title>
      <url>/2017/12/19/TreeMap_info/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TreeMap算是要分析的Map家族中的最后一个成员了，它是AbstractMap的子类，并实现了NavigableMap接口，是Map家族中比较特殊的，支持元素排序插入的Map集合类。</p>
<a id="more"></a>
<h1 id="TreeMap简介"><a href="#TreeMap简介" class="headerlink" title="TreeMap简介"></a>TreeMap简介</h1><p>TreeMap的类图如下：</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-12-18/6367000.jpg" alt=""></p>
<ul>
<li>虚线箭头代表的是实现接口；实线箭头代表的是继承关系</li>
</ul>
<p>由上图所示，它是AbstractMap的子类，因此就具备了一个普通Map的全部操作，如put、get、containsKey等方法，同时，它也实现了NavigableMap，由图中关系，NavigableMap是SortedMap的子接口，所以NavigableMap具备排序功能，且有它的名字可知，它也具备点查询(Navigable)功能。下面简单介绍一下NavigableMap。</p>
<h2 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a>NavigableMap</h2><p>NavigableMap在SortedMap的基础上，增加了一些navigation方法，比如说lowerEntry、floorEntry、ceilingEntry和higherEntry，它们传入的参数都是一个键，类型为泛型K，返回值都为一个Map.Entry对象。这四个方法分别返回小于、小于或等于、大于或等于、大于传入的key的最接近的Entry，也就是说floorEntry方法，如果有小于key的entry1和等于key的entry2，则返回entry2。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>根据名字也可猜出，TreeMap的存储结构为树，树的节点为一个内部类Entry，它是Map.Entry的一个子类。它的属性包含了key,value,指向左兄弟节点的left和指向右兄弟节点的right，指向父节点的parent，表示颜色的布尔值color(为true表示黑色，false表示红色)，因此可知TreeMap是一个红黑树。在HashMap的分析中，1.8之后也增加了红黑树的实现，在此可以进行一下对比。TreeMap中没有指向前一个节点的prev指针，这比较容易理解，HashMap中红黑树是对开链法形成的大于8个节点的链表所进行的，其原型还是链表，只是通过增加了指针形成了红黑树，当节点小于8时，还需要进行untreeify，因此指向前一个节点的指针存储的为链表信息。而TreeMap本身就是树状结构，因此不需要保存链表信息的prev属性。另一个区别是TreeMap中表示颜色的属性为color，虽然也为布尔值，但它的赋值是通过定义好的两个常量进行的，常量定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p>
<p>修改颜色时将对应的常量赋值给color属性即可，这样的定义方式更加形象、直观。至于区别的原因，暂时理解为不同contributor的编程习惯。TreeMap的内部类Entry实现非常简单，只是实现了getValue、getKey、setValue、equals和hashCode方法。其中equals方法首先要求传入的为Map.Entry子对象，其次要求key和value同时相等时才返回true。hashCode返回的为key，value的hashCode的异或值。由于Entry的实现简洁，树的结构操作都放在了TreeMap的方法中，因此不禁产生疑问，TreeMap是如何进行插入和查询的呢？</p>
<p>带着疑问先来看get方法，其核心为getEntry方法，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>getEntry实现的是二叉搜索树的查找算法，也就是与当前节点的key值比较，如果小于，则在左子树中遍历查找，大于的话则在右子树查找，等于返回当前节点。这里需要注意的是，为了查找的性能，这里有一个判断语句，如果comparator不为空，则调用了getEntryUsingComparator方法，该方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        K k = (K) key;</div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                p = p.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                p = p.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看到，在算法上，此方法仍然使用的是二叉搜索树的查找算法，因此在性能上不会有提升，它的性能提高主要体现在comparator的比较算法上，但大多数情况下comparator的比较算法不会有太大差别，本方法的存在只是为了以防万一。由此，get方法实现的是二叉搜索树的标准查找算法，下面分析put方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="comment">//TreeMap为空</span></div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="comment">//使用comparator进行比较</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key为Comparable，使用key.compareTo比较</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    <span class="comment">//修复以使得插入后仍然满足红黑树的特性</span></div><div class="line">    fixAfterInsertion(e);</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>put方法的算法比价清晰，首先查找key值，如果找到了则用新值替换旧值，否则，在合适的位置插入一个新的Entry。由于TreeMap为红黑树，因此需要在插入节点之后进行fix操作，以使得插入后的仍然满足红黑树的特性，该方法为fixAfterInsertion,其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** From CLR */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">//x为新插入的节点，赋为红色</span></div><div class="line">    x.color = RED;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</div><div class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></div><div class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</div><div class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</div><div class="line">            <span class="comment">//叔叔节点为红色</span></div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(y, BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                x = parentOf(parentOf(x));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//x为右子节点，x.parent为左子节点，需要两次旋转进行调整</span></div><div class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);</div><div class="line">                    rotateLeft(x);</div><div class="line">                &#125;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                rotateRight(parentOf(parentOf(x)));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(y, BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                x = parentOf(parentOf(x));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);</div><div class="line">                    rotateRight(x);</div><div class="line">                &#125;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                rotateLeft(parentOf(parentOf(x)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    root.color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>方法的注释<code>From CLR</code>表示的是直接使用了C#中相应的代码，stackOverflow上有篇回答比较详细，感兴趣的可以看一下 <a href="https://stackoverflow.com/questions/38482750/from-clr-in-java-treemap-implementation" target="_blank" rel="external">/<em>From CLR</em>/  Java TreeMap implementation
</a></li>
</ul>
<p>上面代码加上了必要的注释，总的来说就是分为下面几步解决红黑树的平衡问题：</p>
<ol>
<li>新插入的节点设为红色</li>
<li>通过循环，从新插入节点向上遍历，解决冲突，循环的终止条件是x.parent.color = BLACK,这里有一个隐含条件就是x.color = RED，因此当x的父节点为黑色时，红黑树已经调整完毕，其他的跳出循环为边界情况</li>
<li>循环中，根据x父节点是否为其祖父节点的左子节点分成了两个分支，在各自的分支中，根据x叔父节点是否为红色，又分为两个分支，为红色时不需要进行旋转，当前结构平衡，只需要进行颜色的修改；不为红色时，需要通过旋转来保持红黑树的平衡。这里的算法可以参考博客<a href="https://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">红黑树数据结构剖析</a></li>
</ol>
<p>这里可以对照我的另一篇关于HashMap的博客<a href="http://www.wangjialong.cc/2017/12/07/hashmap_info/#more">HashMap解析</a>，其中也有红黑树的相关实现，其算法一致，只是TreeMap中的更加直观，也更加具有语义化，比较容易理解。</p>
<p>get、put之后，我们来分析一下查询方法，get方法实际也有查询的作用，但由于containsValue方法并没有使用get方法，因此单独分析一下，这里也比较容易理解，因为TreeMap的节点是通过key的大小来进行排序的，因此查询value的存在时，不能通过二叉搜索算法来查询，只能通过遍历的方式，时间复杂度为Ω(n)。containsValue定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e))</div><div class="line">        <span class="keyword">if</span> (valEquals(value, e.value))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>getFirstEntry方法返回树的最左边的叶子节点，也就是key最小的节点</li>
<li>successor(e)返回e的下一个节点，也就是key值紧挨着e.key，且大于e.key的节点</li>
</ul>
<p>算法首先找到树中最左边叶子节点，然后successor每次返回当前节点的下一个节点，遍历整个树，直到找到该值或者到达树的最后一个节点。由于successor方法的时间复杂度并不是O(1)的，因此containsValue的时间复杂度大于n，又由于红黑树是二叉平衡树，因此successor时间复杂度不会到达O(n)的级别，因此containsValue的时间复杂度为Ω(n)。successor方法的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//如果t有右子树，则返回其右子树中的最左边的叶子节点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//t不存在右子树，需要向上遍历，找到t为左子节点的第一个父节点</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>算法比较简单，已经在注释中说明，在此不再赘述。</p>
<p>下面分析remove方法，由于remove方法带来了红黑树的结构变化，因此必然也涉及到了删除节点之后的fix过程。remove方法的核心部分为deleteEntry方法，其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></div><div class="line">    <span class="comment">// point to successor.</span></div><div class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; s = successor(p);</div><div class="line">        p.key = s.key;</div><div class="line">        p.value = s.value;</div><div class="line">        p = s;</div><div class="line">    &#125; <span class="comment">// p has 2 children，实际删除的对象变为successor(p)</span></div><div class="line"></div><div class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></div><div class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">//p有孩子节点</span></div><div class="line">        <span class="comment">// Link replacement to parent</span></div><div class="line">        replacement.parent = p.parent;</div><div class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</div><div class="line">            root = replacement;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</div><div class="line">            p.parent.left  = replacement;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p.parent.right = replacement;</div><div class="line"></div><div class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></div><div class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Fix replacement，p为黑色的时候，删除p会影响到路径上黑色节点的个数，需要进行fix操作</span></div><div class="line">        <span class="keyword">if</span> (p.color == BLACK)</div><div class="line">            fixAfterDeletion(replacement);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></div><div class="line">        root = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></div><div class="line">        <span class="keyword">if</span> (p.color == BLACK)</div><div class="line">            fixAfterDeletion(p);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (p == p.parent.left)</div><div class="line">                p.parent.left = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</div><div class="line">                p.parent.right = <span class="keyword">null</span>;</div><div class="line">            p.parent = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，要实现的是删除节点p，在删除的过程中，p的状态有三种情况:p有两个子节点、有一个子节点、没有子节点。</p>
<ol>
<li>p有两个子节点的时候，会找到p的右子树中最左边的节点n，将n的值覆盖掉p的值，此时实际删除的节点变成了n，n没有左子节点，因此将n的右子树的根节点nLeftRoot嫁接到n的位置即可。</li>
<li>p有一个子节点的时候，直接删除的节点为p，将p的左/右子树的根节点childRoot嫁接到p的位置</li>
<li>p没有子节点的时候，需要先进行调整，然后删除节点p</li>
</ol>
<p>红黑树调整也不是每次删除都会发生的，只有当删除的节点p为黑色的时候，会导致其所在路径上的黑色节点数少一个，此时需要进行调整，通过方法fixAfterDeletion来进行，其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** From CLR */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123; <span class="comment">//x所在路径黑色节点少一个</span></div><div class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123; <span class="comment">//x为红色，直接终止循环，将x设为黑色，调整完毕</span></div><div class="line">        <span class="comment">//x为左子节点</span></div><div class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</div><div class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123; <span class="comment">//如果叔父节点为红色，</span></div><div class="line">                setColor(sib, BLACK);</div><div class="line">                setColor(parentOf(x), RED);</div><div class="line">                rotateLeft(parentOf(x));</div><div class="line">                sib = rightOf(parentOf(x));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//此时sib必为黑色，若sib的两个子节点都为黑色，则此路径上黑色节点数多1个</span></div><div class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</div><div class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</div><div class="line">                setColor(sib, RED); <span class="comment">//将sib设为红色，黑色节点数-1</span></div><div class="line">                x = parentOf(x); <span class="comment">//x为sib的兄弟节点，x设为x.parent，递归调整红黑树</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//sib的子节点一红一黑</span></div><div class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123; <span class="comment">//若右子节点为黑色</span></div><div class="line">                    setColor(leftOf(sib), BLACK); <span class="comment">//设左子节点为黑色, sib为红色</span></div><div class="line">                    setColor(sib, RED);</div><div class="line">                    rotateRight(sib); <span class="comment">//右旋sib</span></div><div class="line">                    sib = rightOf(parentOf(x));</div><div class="line">                &#125;</div><div class="line">                setColor(sib, colorOf(parentOf(x)));</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(rightOf(sib), BLACK);</div><div class="line">                rotateLeft(parentOf(x));</div><div class="line">                x = root; <span class="comment">//彻底解决平衡问题，直接返回到root</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></div><div class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</div><div class="line">                setColor(sib, BLACK);</div><div class="line">                setColor(parentOf(x), RED);</div><div class="line">                rotateRight(parentOf(x));</div><div class="line">                sib = leftOf(parentOf(x));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</div><div class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</div><div class="line">                setColor(sib, RED);</div><div class="line">                x = parentOf(x);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</div><div class="line">                    setColor(rightOf(sib), BLACK);</div><div class="line">                    setColor(sib, RED);</div><div class="line">                    rotateLeft(sib);</div><div class="line">                    sib = leftOf(parentOf(x));</div><div class="line">                &#125;</div><div class="line">                setColor(sib, colorOf(parentOf(x)));</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(leftOf(sib), BLACK);</div><div class="line">                rotateRight(parentOf(x));</div><div class="line">                x = root;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setColor(x, BLACK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>该方法传入节点x，由删除方法的触发条件可知，本方法需要解决的问题是，由于x节点的删除，该节点所在的路径上黑色节点数少了一个，因此需要恢复从根节点到x节点上的黑色节点数，使其加一，这样才能恢复树的平衡状态。算法通过一个while循环来进行调整，终止条件为x到达根节点或者x的颜色为红色。x到达根节点时，直接将其设为黑色，方法返回，这比较好理解，因为到达根节点时说明下面各层的颜色调整结束，整棵树满足红黑树。而x为红色时，为什么也可以跳出呢？因为要调整的是x所在路径上的黑色节点数+1，因此如果x为红色的话，只需要将x设置为黑色，则其所在路径上黑色节点数达到要求，因此整棵树也达到了平衡状态。</p>
<p>算法的解释通过注释在上面进行了必要的解释，具体算法可以参考<a href="https://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">红黑树数据结构剖析</a>。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TreeMap中很多东西和HashMap中的一部分东西非常类似，这是因为HashMap在开链法的链表长度大于8的时候，会将链表树化为一个红黑树，因此TreeMap中的插入，删除相当于HashMap中树化的插入、删除。但它们两者也大有不同，一个区别就是TreeMap是一个排序的map，可以通过指定comparator来指定排序规则，而HashMap中树化的比较是通过key的hashCode来进行的，且HashMap首先是一个Hash表，其次bucket对应的链表才是一个红黑树，因此HashMap可以理解为O(1)时间内查找到key值，而TreeMap是一个排序的Map，如果需要维护一个排好序的map时，可以使用TreeMap，且由于红黑树的性质，它可以保证O(logn)的时间内查找到你需要定位的Entry（通过key值来进行比较）。</p>
<blockquote>
<p>live long and prosper</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
            <tag> TreeMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap1.8源码解读]]></title>
      <url>/2017/12/07/hashmap_info/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap和HashTable可以说是Map家族中最常用的两个类了，而两者又都是通过Hash表来进行key值的映射的，因此选择将两者进行统一的比较分析，并借此了解jdk中是如何实现hash表结构的map对象的。这篇博客篇幅较长，但我觉得有很多是很有用的知识，希望读者可以耐心阅读。</p>
<a id="more"></a>
<h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是Map的一个Hash表类型的实现，由于Hash表的常数时间内的寻址特性，使得HashMap可以在常数的时间内执行get(key), set(key, value)方法。HashMap支持存储key和value为null的元素。</p>
<p>HashMap有两个非常重要的初始化参数：initial capacity和load factor。initial capacity决定了存储hash(key)的返回值的bucket。因为HashMap是使用了数组加链表的形式进行元素的存储的（1.8之后增加了红黑树的支持，当链表长度大于8之后，会将链表进行<strong>树化</strong>）。</p>
<p>load factor是另一个重要的指标，它标示了这个HashMap什么时候需要扩容，默认值是0.75.举个例子，假如初始容量为100，则当hash(key)的返回值达到75个的时候，该HashMap需要扩容，并rehash，扩容后的大小是扩容前的两倍。load factor只和填充的bucket有关，而和该bucket对应的存储了多少个Node无关，即使该bucket只存了一个，也会将填充数+1。因此，如过initial capacity * load facotr &gt; entry数量，则HashMap不会进行rehash。因此，如果预先知道entry的数量，计算相应的capacity值，有利于提高存取效率。</p>
<p>HashMap不是一个同步类，如果需要进行多线程的访问，可以考虑三种方式</p>
<ol>
<li>使用 <code>Map m = Collections.synchronizedMap(new HashMap(...));</code></li>
<li>使用HashTable，同步类</li>
<li>使用ConcurrentHashMap</li>
</ol>
<p>如果有高并发读的需求，强烈建议使用ConcurrentHashMap，它是无锁读的。</p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="bucket长度与Hash函数"><a href="#bucket长度与Hash函数" class="headerlink" title="bucket长度与Hash函数"></a>bucket长度与Hash函数</h2><p>HashMap是通过一个内部类Node类存取K/V值的，该Node包含了4个属性：hash,key,value,next。hash存的就是key值经过Hash之后的返回值，HashMap通过hash字段，快速的定位该node； key值就是K/V中的键，value就是K/V中的值，next指向了链表中下一个节点（先分析数组+链表的存储结构，之后分析红黑树，红黑树的节点为TreeNode）。</p>
<p>Node的equals方法比较重要，它决定了HashMap中存储新的的K/V对时，原来的Node中是否有与新的K/V对相同，如果equals为真，则覆盖原来的值，否则，new一个新的Node。equals方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)           </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">            Objects.equals(value, e.getValue()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>有代码可知，先判断引用是否一致，如果相同，则返回true，然后判断是否为Map.Entry的一个子类，之后判断K/V是否同时相同，如果是，则返回true，否则，返回false。这段判断是否相同的逻辑，对于Set中的元素也使用，因为Set也是使用Map来存储元素的。</li>
</ul>
<p>HashMap通过一个Node数组来表示存储hash(key)的bucket入口，默认大小为16.这个数字比较特别，是2的4次方，bucket的大小必须是2的整数次幂,这样做的好处是，length-1正好是低x位均为1，起到一个掩码的作用，而掩码的作用与求余相同。如初始长度16，-1后的二进制为1111，和hash值进行与操作，相当于hash值对16求余。这个求余操作用于将hash值映射到Node数组的空间中，在寻找key对应的bucket时，只需要table[(length-1) &amp; hash(key)]即可，然后遍历其指向的链表即可找到K/V对。HashMap为了保证容量为2的整数次幂，使用了一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>该方法很好理解，将cap-1的二进制数为1的最高位以下的所有位置为1，然后加1，则为一个形如00100000的数。</li>
</ul>
<p>上面提到了hash函数，HashMap的hash函数比较简单，只是简单的将key的高16位与低16位进行位异或即可。这是一个扰动函数，为了防止低16位数的规律性。原因是，由于Node数组长度有限，无法对应hash函数的返回值，而hash函数低x位有可能有一定的规律性，为了减少其低16位的规律性，又因为高16位在求数组index中永远不会用到，因此，选择将高16位直接与低16位做异或，将高16位作为一个扰动信号，维持hash函数的散列性。</p>
<h2 id="put、get源码解读"><a href="#put、get源码解读" class="headerlink" title="put、get源码解读"></a>put、get源码解读</h2><p>下面着重分析put(key,value)和get(key)这两个方法。</p>
<p>put的核心方法是putVal方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">//table为空，需要初始化</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">//bucket入口为空，直接new一个Node，放到数组的对应坐标处</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">//hash值冲突，开链法解决冲突</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">//链表第一个节点就是要put的key，赋值给e</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">//链表长度大于8，已经被树化</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">//到达链表末尾，将k/v对添加到最后</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//大于阈值，进行树化</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//链表中已存在key值</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该key值已存在</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key值不存在，已添加进HashMap</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先介绍参数，后两个为布尔值，作为flag，表示存储策略，onlyIfAbsent为true的时候，put方法检测到已有值时不会覆盖，evict为false的时候，Hash表处于创建，初始化时刻。hash，key,value分别对应Node中的对应属性。</p>
<p>在上面的代码段中已经添加了必要的注释，最终的结果只有两种。一、key值已存在，根据策略替换原值，返回oldValue；二、key值不存在，找到一个合适的位置插入，返回null。为了达到最后的结果，大致有以下几个步骤：</p>
<ol>
<li>判断table是否为空，若为空，则执行resize方法，根据初始容量，初始化table数组</li>
<li>根据key值运算后的hash值，与数组长度求余(通过(n-1)掩码与运算求余)，找到在数组中的index，如果该index对应的为null，则将新的k/v插入到该位置，相当于一个bucket的入口，由此可知，resize只是初始化数组，并没有给数组中的Node进行初始化，因此index位置仍为空</li>
<li>如果bucket的入口非空，则表示Hash冲突，对应的链表长度&gt;=1，需要通过开链法解决冲突。有三个判断逻辑：链表头节点key值与添加的key值相等；链表已经树化，需要搜索红黑树查找该key值是否已存在；链表未被树化，且头节点key值与新增key值不同，需要遍历链表查找该key值是否存在。</li>
<li>上面的判断逻辑中，不管是哪一种，只要key值已存在，则赋值给e，因此在后面判断e是否为null，若不为空，则表示已存在，根据策略决定是否覆盖原值</li>
<li>如果key值不存在，需要将modCount自增1，然后将size自增，判断大小是否超过阈值，是，则通过resize方法double原table数组的容量。</li>
</ol>
<p>在上面的代码块中，有两个方法比较有趣，afterNodeAccess和afterNodeInsertion方法，它们在HashMap中代码段为空，它们的作用主要是为了让LinkedHashMap继承，这样的话，LinkedHashMap不需要重写putVal方法，而只需要重写afterNodeAccess和afterNodeInsertion方法即可，因为LinkedHashMap需要保证HashMap的顺序，因此需要在putVal之后进行顺序的调整，就是通过上面的两个方法执行顺序调整的。这个编程思想让我十分受用，父类定义了方法的流程，在此为putVal方法的流程，而对于父类中不需要的操作，通过将方法体书写为空，对父类的操作不会影响，而对于子类(LinkedHashMap)，只需要重写那两个为空的方法，即可完成功能的增强(在此为保证Map的顺序，也就是key值插入的顺序)。</p>
<blockquote>
<p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="external">LinkedHashMap</a>是一个HashMap和double linklist的结合体，它保证的顺序为key值put的顺序</p>
</blockquote>
<p>下面分析TreeNode的putTreeVal方法，它是putVal的树化版。它遍历红黑树以寻找是否已经存在要插入的key值，若存在，则返回该节点，否则，在合适的位置插入节点，并返回null.要分析putTreeVal,首先需要搞清楚TreeNode的结构，其定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>红黑树的特性</p>
<ol>
<li>根结点是黑的。</li>
<li>每个结点要么是红的，要么是黑的</li>
<li>如果一个结点是红的，那么它的俩个儿子都是黑的</li>
<li>任意从根到叶子的路径的黑色节点总数相同。</li>
<li>本质上是二叉搜索树，左子树节点小于当前节点，右子树节点大于当前节点</li>
</ol>
</blockquote>
<p>上面是典型的红黑树节点定义，包含了指向父节点的指针parent，左子节点left，右子节点right, red表示当前节点是否为红色。</p>
<p>下面来分析putTreeVal方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//找到红黑树的根节点</span></div><div class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line">        <span class="keyword">int</span> dir, ph; K pk;</div><div class="line">        <span class="comment">//当前节点hash大于h,在左节点查找</span></div><div class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">            dir = -<span class="number">1</span>;</div><div class="line">        <span class="comment">////当前节点hash小于h,在右节点查找</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">            dir = <span class="number">1</span>;</div><div class="line">        <span class="comment">//ph == h 且 p.key == k</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        <span class="comment">// K不是Comparable的实现类 或 pk的类型 不是Comparable的实现类</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!searched) &#123;</div><div class="line">                TreeNode&lt;K,V&gt; q, ch;</div><div class="line">                searched = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//递归的在左右子树中查找h, k</span></div><div class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</div><div class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</div><div class="line">                    <span class="keyword">return</span> q;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// dir = -1 / 1</span></div><div class="line">            dir = tieBreakOrder(k, pk);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TreeNode&lt;K,V&gt; xp = p;</div><div class="line">        <span class="comment">//到达叶子节点，没有找到key值，插入新节点</span></div><div class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line">            Node&lt;K,V&gt; xpn = xp.next; <span class="comment">//next属性位于HashMap.Node中，在此进行设置，主要是为了方便红黑树和链表之间的转换</span></div><div class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</div><div class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line">                xp.left = x;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                xp.right = x;</div><div class="line">            xp.next = x;</div><div class="line">            x.parent = x.prev = xp;</div><div class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</div><div class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</div><div class="line">            <span class="comment">//插入，并重新平衡红黑树，并确保root节点为bucket的第一个节点</span></div><div class="line">            moveRootToFront(tab, balanceInsertion(root, x));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我在上面的代码块中添加了必要的代码注释，相信重要的代码分支的含义已经比较清晰。总的来说，putTreeVal方法通过一个循环，从root节点寻找红黑树中是否已存在要插入的key值，最后的结果只有两种，一是找到了，则返回该key值对应的在树中的节点；而是没有找到，此时新建TreeNode，并将其插入到红黑树中，返回null。这里的逻辑与链表插入的逻辑相同，返回null后，通过判断即可得知新增的key值成功插入，且之前不存在。红黑树中查找节点的算法比较简单，和二叉搜索树相同，如果key小于当前节点key，则到左子树查找；大于则到右子树查找，直到找到key值或者到达叶子节点。遍历的方向通过dir表示，-1表示向左子树遍历，1表示向右子树遍历。方法中比较key值得逻辑有几块，主要是满足泛型需要的，key的比较方式有四种：</p>
<ol>
<li>通过 &lt;,=,&gt; 比较运算符直接比较；</li>
<li>通过Object的equals方法比较是否相同，通过Comparable的compareTo比较返回-1或1；</li>
<li>若key不为Comparable的实现类，则通过find方法查找该key值，find方法只会遍历树一次(searched置为true后，不调用)</li>
<li>如果上面的方法都没法进行key值得比较，调用tieBreakOrder方法，通过内部System.identityHashCode(key)进行比较，返回-1或者1</li>
</ol>
<p>最终如果没有找到key值，则new一个TreeNode，进行插入。此处的插入是要满足红黑树的特性的，因此在balanceInsertion(root, x)中插入了x，并整理该树以满足红黑树的性质，返回之后的根节点。moveRootToFront方法将返回的根节点确保其位于tab的对应index位置，也就是确保根节点位于bucket的入口处。</p>
<p>balanceInsertion方法插入节点x，并平衡红黑树，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></div><div class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    x.red = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class="line">        <span class="comment">// x 为根节点</span></div><div class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</div><div class="line">            x.red = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// x的父节点为黑色节点 或 x的父节点为根节点</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        <span class="comment">// x的父节点为其父节点的左子节点</span></div><div class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</div><div class="line">            <span class="comment">//x的叔父节点也为红色节点，不能通过旋转解决颜色冲突，直接通过改变颜色，但改变之后的xpp与其父节点都为红色，在下一次循环中解决冲突</span></div><div class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</div><div class="line">                xppr.red = <span class="keyword">false</span>;</div><div class="line">                xp.red = <span class="keyword">false</span>;</div><div class="line">                xpp.red = <span class="keyword">true</span>;</div><div class="line">                x = xpp;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//与父节点颜色冲突，都为红色</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// x 是xp的右子节点， xp是xpp的左子节点，此时需要两次旋转，先左旋，后右旋</span></div><div class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</div><div class="line">                    <span class="comment">//左旋</span></div><div class="line">                    root = rotateLeft(root, x = xp);</div><div class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line">                    xp.red = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">//右旋后xpp成为xp的右子节点，应该变为红色</span></div><div class="line">                        root = rotateRight(root, xpp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</div><div class="line">                xppl.red = <span class="keyword">false</span>;</div><div class="line">                xp.red = <span class="keyword">false</span>;</div><div class="line">                xpp.red = <span class="keyword">true</span>;</div><div class="line">                x = xpp;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</div><div class="line">                    root = rotateRight(root, x = xp);</div><div class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line">                    xp.red = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line">                        xpp.red = <span class="keyword">true</span>;</div><div class="line">                        root = rotateLeft(root, xpp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码块已经加入了我自己的理解，这里主要是通过插入后，判断是否与父节点颜色冲突(均为红色)，然后通过二叉树的旋转来保持平衡，旋转的策略分为了左旋和右旋，主要根据插入节点、父亲节点、祖父节点的关系决定，具体规则可以参考<a href="https://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">红黑树数据结构剖析</a>，写的比较详细。</p>
<p>到此终于把putVal方法分析完了，小小的一个put方法牵扯了这么多的知识，包含了开链法解决Hash冲突，链表插入，红黑树的插入以及每种插入前的查找。既然在此分析到了TreeNode，就小结一下，TreeNode实现的是红黑树的数据结构，在其中包含了插入、删除、查找、split方法，其中插入、删除、查找比较好理解，split方法主要是用在HashMap的resize中，通过将红黑树分为lower和upper两个红黑树，放置到相应的两个bucket处。</p>
<p>分析完put方法，下面分析get方法，有了put的铺垫，get相对来说就简单一些了。getNode是get的核心方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">//do-while遍历链表</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑就比较简单了，首先判断第一个节点是否为要找的key值，然后如果是链表形态，则do-while结构遍历链表；如果是红黑树形态，则调用getTreeNode查找并返回对应的TreeNode。getTreeNode的方法调用了TreeNode的find方法，其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">int</span> ph, dir; K pk;</div><div class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</div><div class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">            p = pl;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">            p = pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</div><div class="line">            <span class="keyword">return</span> p;  <span class="comment">//上面三个判断时通过&gt;, &lt;, = 比较符号进行比较的</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</div><div class="line">            p = pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</div><div class="line">            p = pl;    <span class="comment">//上面两个判断左右子节点是否为空</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</div><div class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</div><div class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</div><div class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr; <span class="comment">//通过Comparable的compareTo方法判断，-1遍历左子树，1遍历右子树</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">//</span></div><div class="line">            <span class="keyword">return</span> q;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p = pl; <span class="comment">//上面两个是递归调用find的两种形式，一个为递归find右子树，另一个为循环遍历左子树</span></div><div class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>find的逻辑与putTreeVal的查找逻辑十分类似，也是通过比较符、compareTo方法，递归调用find来查找，不同的是，这里不使用System.identityHashCode来比较了。</p>
<p>有了put和get方法，基本上HashMap的框架就有了，接下来分析resize方法，该方法扩容table的size，使其double原来的大小，这也是HashMap如此好用的原因，我们不需要考虑HashMap的大小，只要使用put、get即可。</p>
<h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>resize方法有两个作用：1、初始化table； 2、double原table的大小。 resize的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">//链表只有一个节点</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">//oldCap形如00100000,此处相与，类似于选择器，为0的放在lower list，为1的放在upper list</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//将lower list放在newTab的j处</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//将upper list放在newTab的j+oldCap处，原来j处的list一分为二，相距oldCap距离</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>if (oldTab != null)</code>之前的语句比较容易理解，计算newCap(为oldCap的两倍，左移1位)，然后通过new来初始化数组。到<code>if (oldTab != null)</code>，说明之前table中已经存了k/v(put方法已经被调用过)，需要将原来的K/V值移动到新的table中对应的index处。移动的逻辑也比较简单，如果链表只有一个节点，则直接赋值给新数组的对应index处，这里有一个隐含逻辑，就是当e1.hash &amp; (oldCap-1) = j的时候，e2.hash &amp; (oldCap - 1) = k； j不等于k，则 e1.hash &amp; (newCap - 1) 一定不等于 e2.hash &amp; (newCap - 1)，因为它们的低x位不同(x为oldCap-1的1的个数)。因此不需要考虑e.hash &amp; (newCap - 1) 处是否已存在节点，因为一定为null。</p>
<p>如果链表长度大于1，则需要将链表一分为二，分别为lower list和upper list。 将lower list放到 newTab的j处，upper list放到newTab的j+oldCap处。 但它的分割方法是通过e.hash &amp; oldCap进行的，如果为0，则放在lower里面，否则，放在upper里面。但这种方法个人认为并不能保证等分，它的分割是否平均取决于hash值在该位的随机性。split方法是TreeNode的分割版本，其逻辑也是通过e.hash &amp; oldCap进行分割的，在此不再赘述。</p>
<h2 id="遍历源码分析"><a href="#遍历源码分析" class="headerlink" title="遍历源码分析"></a>遍历源码分析</h2><p>HashMap的遍历方式与Map的一样，有三种遍历方式，分别为:key的遍历，value的遍历，Entry(K/V对)的遍历。三者的实现一致，下面以key的遍历为例进行分析。</p>
<p>keySet()方法会返回一个Set<k>对象，它的实现类是一个内部类KeySet，继承了AbstractSet<k>，通过KeySet的iterator方法，可以返回一个KeyIterator对象，KeyIterator也是一个内部类，继承了HashIterator，ValueIterator（value的遍历对象），EntryIterator（Entry的遍历对象）也继承了该类，因此，在此分析HashIterator即可。</k></k></p>
<p>HashIterator在初始化的时候会将next指向从table的0开始数，第一个存了Node的位置，next指向的为一个Node。构造函数定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    Node&lt;K,V&gt;[] t = table;</div><div class="line">    current = next = <span class="keyword">null</span>;</div><div class="line">    index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>nextNode方法返回next当前指向的Node，并将next指向下一个Node。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] t;</div><div class="line">    Node&lt;K,V&gt; e = next;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="comment">//将next指向下一个不为空的Node</span></div><div class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>到此为止，HashMap就分析结束了，主要分析了HashMap的put、get方法，存储方式，扩容方式，遍历方式，这些是Map的几个最重要的操作，也是体现HashMap之所以为HashMap的特征，接下来，分析两个和HashMap关系密切的类：LinkedHashMap、HashTable。</p>
<h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>LinkedHashMap关系最为密切，它是在HashMap的基础上进行的功能增强，提供了双向链表的存储结构。这里的意思不是说LinkedHashMap完全舍弃了HashMap使用数组的存取方式，而是说在此基础上，通过添加一个双向链表（节点类型为LinkedHashMap.Entry<k,v>, 有一个before指针，和after指针，因此为双向链表），保证了Map的顺序，而在遍历时，舍弃了上面HashMap的HashIterator，选择直接对双向链表遍历，因此就达到了保证顺序的目的。</k,v></p>
<p>LinkedHashMap中有一个比较有趣的属性，叫作accessOrder，它是一个布尔值，表示了双向链表所保证的顺序是否为访问顺序。如果accessOrder为true，则保证的为访问顺序，即通过put修改了某个key对应的value后，会将该节点放在双向链表的最后。如果accessOrder为false，则保证的是插入顺序，此时put修改不会更改该节点在双向链表中的顺序。</p>
<p>LinkedHashMap重写了HashMap的newNode方法，在newNode中调用了linkNodeLast方法将新生成的节点放到了双向链表的最后。因此，在HashMap的putVal方法中调用newNode时，实际调用的为LinkedHashMap的newNode方法，这就达到了复用putVal方法的目的。在插入、修改、删除Node后，通过afterNodeInsertion，afterNodeAccess，afterNodeRemoval修改LinkedHashMap中的双向链表即可。三个方法的含义为</p>
<ul>
<li>afterNodeInsertion在节点插入后执行，在LinkedHashMap中没有实际作用，它提供了一个潜在的功能，就是在插入后删除eldest节点，可以达到一个类似于固定长度的缓冲队列的功能。</li>
<li>afterNodeAccess在accessOrder为true的时候触发，将修改或者通过get访问的节点放到双向链表的最后。</li>
<li>afterNodeRemoval在删除节点后触发，删除双向链表中的对应节点。</li>
</ul>
<p>LinkedHashMap的遍历同构一个内部类LinkedHashIterator实现了双向链表的遍历，在此不再赘述。</p>
<h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>HashTable经常拿来跟HashMap比较，是因为在ConcurrentHashMap，它可以作为一个线程安全的HashMap来使用。但实际HashTable的出生日期比HashMap还要早一些，从1.0开始就存在了，而HashMap在1.2才出现。HashTable就是一个标准的Hash表，继承了Dictionary抽象类，实现的是基本的K/V操作，没有HashMap那么多的基于性能的优化。HashTable中很多方法直接使用的是synchronized修饰，因此是线程安全的。HashTable不能将null作为key值存放，且key值必须是一个对象，定义了hashCode和equals方法。存储结构就是标准的数组+链表的方式，解决Hash冲突的方法就是采用标准的开链法，每次将新的node放在链表的头部。下面分析一下put方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure the value is not null</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="comment">//hash值为key的hashCode，因此key必须实现了hashCode方法</span></div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="comment">//index和31个1相与，然后对length求余，因为int长度为32，第一个1代表为负数，而index&gt;=0</span></div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line">        <span class="comment">//key值已存在，则覆盖</span></div><div class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            <span class="keyword">return</span> old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key值不存在，新增节点</span></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>逻辑很清晰，先计算hash值在数组中的index，然后在index对应的链表寻找是否有对应的key，有的话覆盖旧值，否则，调用addEntry方法，新增节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">        rehash();</div><div class="line"></div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Creates the new entry.</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</div><div class="line">    <span class="comment">//将新增节点放在链表的头部，原来的链表头e，作为新节点的next节点</span></div><div class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果大小大于阈值，需要进行rehash，对数组进行扩容。rehash方法double当前的容量，然后将旧节点放到 <code>(e.hash &amp; 0x7FFFFFFF) % newCapacity</code>处，代码不在此处粘贴。</p>
<p>HashTable的遍历时从数组的末尾index递减的顺序进行遍历的，通过一个内部的Enumerator来实现，通过属性type判断要取的是key值还是value值或者Entry值，在此不做赘述。</p>
<p>由上面所说，HashTable大多数的方法都为同步方法，已经不太适合多并发编程，因此推荐使用ConcurrentHashMap类满足并发需求，ConcurrentHashMap的读不加锁，因此适合频繁多线程读的场景。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析HashMap是我读Collection 家族的最多收获的一次，在过程中不仅复习了开链法解决Hash冲突，还学到了通过掩码实现类似于求余的操作，并搞懂了为什么capacity为什么必须是2的整数次幂，在后面有学习了一下红黑树的相关知识，虽然让我实现一个红黑树还是困难重重，但已经增加了很深对于红黑树的理解。而且在分析LinkedHashMap的时候，了解了LinkedHashMap巧妙复用HashMap的put方法的编程技巧，这一点也是让我受益匪浅。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(sad) &#123;</div><div class="line">  sad = <span class="keyword">false</span>;</div><div class="line">  beAwesome();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
            <tag> HashMap </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Map简介]]></title>
      <url>/2017/11/26/map_info/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Collection家族的最后一个重要成员就是Map了，坦白来说，在实际开发中，用到的最多的怕就是List和Map了，而相对来说Set比他们用的都少一点。Map的K/V存储结构，特别适合在后端开发中存放一些用户请求参数，配置信息等。因此，准备详细分析一下Map家族，大致分为三个部分Map、HashMap、TreeMap。</p>
<a id="more"></a>
<h1 id="Map介绍"><a href="#Map介绍" class="headerlink" title="Map介绍"></a>Map介绍</h1><p>Map是一个接口，它表示了一组可以存放K/V键值对的集合。key值必须是唯一的，不能重复，对应的value值同一时刻只能指向一个对象。Map的定义是使用了泛型的，其定义语法为 <code>public interface Map&lt;K,V&gt;</code>， K为键的类型，V为value的类型。可以是通用数据类型也可以是类。</p>
<p>Map提供了三种视图可以用于遍历，key值得集合，value值得集合，k/v对的集合。有一些子类的遍历顺序是一定的，如TreeMap，而另一些是不确定的，如HashMap。Map主要提供了以下的方法：</p>
<ul>
<li><strong>查询类的</strong>：size返回当前大小、isEmpty返回是否为空，containsKey、containsValue分别返回是否包含该key或value，</li>
<li><strong>操作类的</strong>：get(key)、put(key, value)、remove(key)、putAll(map)、clear()</li>
<li><strong>视图类的</strong>：keySet()返回key值的一个set集合对象，values返回一个Collection对象，entrySet返回一个Set<map.entry<k, v="">&gt; 对象，Map.Entry是一个内部静态类</map.entry<k,></li>
</ul>
<p>根据视图类的三个方法，分别有三种遍历方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>/遍历k,v值</div><div class="line"><span class="keyword">for</span>(K key: map.keySet()) &#123;</div><div class="line">    V value = map.get(key);</div><div class="line">&#125;</div><div class="line"><span class="number">2</span>/只遍历v值</div><div class="line"><span class="keyword">for</span>(V value: map.values()) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="number">3</span>/遍历k,v值</div><div class="line"><span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry: map.entrySet()) &#123;</div><div class="line">    K key = entry.getKey();</div><div class="line">    V value = entry.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>JDK1.8之后，接口中的方法可以提供默认的结构体了，叫作接口的默认方法，该方法提供了默认操作，如果实现类没有重写这些方法，则将直接调用默认方法的逻辑，这赋予了接口部分父类的功能，免除了实现类重复的实现相同的方法逻辑。Map中的默认方法大多与1.8支持的lambda表达式有关，通过传入Function，提供了函数式编程的部分特性。</p>
<p>默认方法中有一部分是无关Lambda表达式的，这部分方法的意义就是纯粹的提供了一个默认的操作逻辑。这些方法包含了</p>
<ul>
<li>putIfAbsent(K key, V value)，该方法判断key对应的是否为null，如果是，则赋值。</li>
<li>remove(Object key, Object value)删除指定key/value对，这里使用了Object而没有采用泛型，具体原因没有分析出来。</li>
<li>replace(K key, V oldValue, V newValue)将旧值替换为新值</li>
<li>replace(K key, V value)将该key对应的value设为传入的value。</li>
</ul>
<p>默认方法中另一组方法是传入参数为Function或者BiFunction的，Function和BiFunction为依赖注入的对象，在默认方法调用其apply方法，对Map的元素进行相应的操作。依赖注入是spring中重要的一个思想，它通过注入一个接口，达到了控制反转的目的。在这里，默认方法都调用apply方法，但apply方法的具体实现逻辑在这里并没有指定，而是通过传入的Function或者BiFunction的实现类来决定的，也就是把具体控制权交给了其实现类。简单介绍一下两个接口。</p>
<ul>
<li>两者都可以用Lambda表达式传入</li>
<li>Function的apply方法传入一个参数，BiFunction的apply方法传入两个参数。</li>
<li>两者的apply方法都会返回一个值</li>
</ul>
<p>computeIfAbsent传入一个key值和Function，在调用时可以使用 <code>map.computeIfAbsent(1, k -&gt; k+&quot;&quot;)</code>的格式，将key为1（不存在与Map中）对应的value设置为字符串“1”。</p>
<p>compute、computeIfPresent、merge、replaceAll传入的都为BiFunction。</p>
<p>compute的典型用法如<br><code>map.compute(key, (k, v) -&gt; (v == null) ? msg : v.concat(msg))</code> 将key对应的value设一个默认字符串或者将原有字符串和新字符串合并。merge的用法与compute类似。<code>map.merge(key, msg, String::concat)</code></p>
<p>computeIfPresent对一个存在的key值进行对应的apply方法调用。replaceAll对所有的k/v对进行相应的操作。</p>
<p>默认方法还有一个传入的是BiConsumer接口。该接口调用的是accept方法，传入两个参数，不返回值。该默认方法为forEach方法，可以方便的用于遍历map.如 <code>map.forEach((k, v) -&gt; System.out.println(k +&quot;-&gt;&quot;+ v));</code></p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Map是Collection框架中的大家族，其中有HashMap、HashTable、TreeMap都有分析的必要，因此决定单独几篇分析每个类。在这里，简单介绍了Map的功能和特性，重点介绍了1.8后支持的默认方法，给接口的使用增加了很多的便利性。灵活使用默认方法搭配Lambda表达式，可以写出来简洁且清晰的代码。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
            <tag> Map </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Set家族简介]]></title>
      <url>/2017/11/19/java_set_info/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Set家族是Collection Framework中重要的一个分支，它的含义就是数学意义上的set概念，也就是说它的元素满足互斥性，如果e1，e2都属于一个Set，则e1.equals(e2)一定返回false，否则，在添加的时候，后面加入的元素无法被添加进来。Set在存储互斥元素的时候有很好的作用，如果我们希望在一个集合中存储唯一元素，如key值，则可以选择Set的子类进行存储。</p>
<a id="more"></a>
<h1 id="Set简述"><a href="#Set简述" class="headerlink" title="Set简述"></a>Set简述</h1><p>Set不能存储相等的两个元素，那么就有一个问题，如果元素存入后改变了怎么办？通常的，一个元素的值得改变如果影响到了equals方法的返回值，Set并没有规定必须抛出异常，但在添加的时候，尽量不要添加会改变equals返回值的元素。</p>
<p>Set中的方法与父接口中方法签名一致，但我在阅读源码的时候，发现Set还是重写了父接口的方法，这在语法上并不是必要的，在此我就暂且“以小人之心度一下源码大大之意“吧。</p>
<ul>
<li>Set中的方法虽然签名与Collection相同，但具体含义不一样，如add方法，Collection是随意添加一个元素，而Set是添加一个之前在集合中不存在的元素</li>
<li>为了写方法的doc注释，Collection中add方法和Set中add方法的注释不同</li>
</ul>
<p>Set家族中有几个重要的成员，HashSet、SortedSet、TreeSet，下面简单介绍一下各自的含义</p>
<ul>
<li>HashSet：Set接口的实现类，内部存储结构为Hash表，实际上是由HashMap实现的HashSet</li>
<li>SortedSet：Set接口的子接口，代表了一类排序的Set，其元素排列顺序为自然排序或者通过具体的comparator比较</li>
<li>TreeSet：SortedSet的一个实现类，内部存储结构为红黑树，实际是由TreeMap实现的</li>
</ul>
<h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet是一个Hash表实现的Set结构，其内部具体存储元素的是HashMap对象(<em>HashMap是Map家族的重要成员，将在Map中进行分析</em>)，其具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由上面代码可以看出，HashSet中的元素实际上被存储为HashMap的key值，其唯一性由HashMap来保证，而HashMap的value值为一个静态常量PRESENT，它是一个Object对象。该对象用于判断map.remove时的返回值是否与其相同，来确保remove方法正确的删除了指定元素。</p>
<p>HashSet中有两个比较重要的概念是initialCapacity和loadFactor，它们也是HashMap中的重要概念，在此只做简单的描述，详细的在Map中进行分析。</p>
<ul>
<li><code>initialCapacity</code>是bucket的默认大小，bucket也就是Hash表中一个key值对应的存储容量，是为了解决key冲突的，一个理想的Hash表应当是每个key对应一个值，这样可以在O(1)的时间内读取到一个值，但这需要Hash算法能把key值散列的完全没有重复才可以达到，而这在现实中是不可能的，因此bucket的存在就很关键，由此可见HashMap是通过开链法解决冲突的</li>
<li><code>loadFactor</code>是bucket的默认填充因子，是一个0~1间的小数，代表了一个bucket最多可以填充多少百分比</li>
</ul>
<p>HashSet是线程不安全的，如果需要获取一个同步Set，可以使用下面的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</div></pre></td></tr></table></figure>
<p>HashSet的iterator也是fail-fast的，如果在iterator遍历时，使用了除iterator的remove方法之外的方法改变了HashSet，则会抛出ConcurrentModificationException，这部分的实现是与</p>
<h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet是HashSet的子类，是从1.4版本开始加入Set家族的(<em>HashSet从1.2就存在了</em>)，它主要解决的问题是HashSet在返回iterator的时候，顺序不统一的问题，因此LinkedHashSet使用了链表的方式，确保了元素的遍历顺序，该顺序与元素插入顺序一致。LinkedHashSet内部使用了LinkedHashMap存储元素值，它的iterator也是调用了LinkedHashMap的iterator方法。</p>
<p>LinkedHashSet的典型使用场景是客户端展示数据，因为相同的集合，客户端希望展示的数组顺序是一样的，此时可以选择使用LinkedHashSet返回元素集合。严格意义上也可以使用TreeSet实现相同的功能，但TreeSet耗时比LinkedHashSet更大，因此LinkedHashSet是更好的选择。</p>
<h1 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h1><p>SortedSet是Set的一个子接口，它的含义跟它的名字一样——排序集合。它可以根据元素的自然顺序进行存储，也可以通过指定Comparator，来实现自己的排序逻辑。插入的元素必须实现Comparable接口（或者可以接受Comparator的compare方法），e1.compareTo(e2)或者comparator.compare(e1, e2)方法必须不能抛出ClassCastException异常。</p>
<p>SortedSet的实现类有以下几点限制：</p>
<ul>
<li>一个无参构造方法，创建一个自然顺序的SortedSet</li>
<li>一个传入Comparator的构造方法，根据Comparator的compare方法进行排序</li>
<li>一个传入Collection的构造方法，根据自然顺序创建一个Collection的拷贝</li>
<li>一个传入SortedSet的构造方法，创建一个跟传入对象相同的SortedSet</li>
</ul>
<p>SortedSet中定义了几个方法：</p>
<ul>
<li>comparator() 返回用于排序的Comparator</li>
<li>first() 返回Set的第一个元素</li>
<li>headSet(E toElement) 返回toElement之前所有元素组成的集合</li>
<li>subSet(E fromElement, E toElement)返回一个half-open的子集合，范围为[fromElement, toElement)</li>
<li>tailSet(E fromElement) 返回fromElement之后所有元素组成的集合</li>
</ul>
<h2 id="NavigableSet（1-6之后才有）"><a href="#NavigableSet（1-6之后才有）" class="headerlink" title="NavigableSet（1.6之后才有）"></a>NavigableSet（1.6之后才有）</h2><p>NavigableSet是SortedSet的一个子接口，也是TreeSet实现的接口，因此在这里简单介绍。NavigableSet顾名思义，是一个可以查找的Set，而且通常意义上很快（TreeSet通过红黑树实现，可以实现O(logN)的查找)。因此可以通过指定一个target，来返回想要查找的元素。</p>
<p>NavigableSet提供了几个实用的方法：</p>
<ul>
<li>lower(E e)返回小于e的最大元素</li>
<li>floor(E e) 返回小于或等于e的最大元素</li>
<li>ceiling(E e)返回大于或等于e的最小元素</li>
<li>higher(E e) 返回大于e的最小元素</li>
<li>descendingSet() 和 descendingIterator()分别返回一个倒序的Set和Iterator</li>
<li>pollFirst() 和 pollLast() 分别返回第一个、最后一个元素</li>
</ul>
<h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>TreeSet实现了NavigableSet，它是基于TreeMap存储的，由于TreeMap实现了红黑树，因此TreeSet也提供了O(logN)的插入、删除、查找操作。</p>
<p>TreeSet的方法是NavigableSet和SortedSet的方法并集，在此不再进行罗列。源码中各个方法都是使用TreeMap的相应方法实现，在此也不过多描述，在TreeMap中进行详细的分析。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析到这里，发现Set家族的儿子都是从别人家偷的（HashSet使用了HashMap，TreeSet使用了TreeMap），真是精致的拿来主义者啊。不过这在代码的实现中，确实很高的技巧，完美的实现了DRY（Don’t repeat yourself）原则。Set家族的分析相对比较简单，因为大多都是Map家族的成员帮助它们完成了功能，因此，在下一步Map的分析就显得任重道远了。Set家族使用的场景虽然不多，但经过一番分析之后，也是挖掘了不少潜在价值，合理利用HashSet和TreeSet，可以减少很多代码的工作量。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
            <tag> Set </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[List家族简介]]></title>
      <url>/2017/11/15/javaList_info/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>List是Collection framework中重要的一员，在平时的编程中，我也会经常用到，它可以简单的理解成一个变长的数组，数组中的每个元素的类型必须一致。在数据结构的概念里面，链表是可以动态添加删除的，由节点与指针组成的一组数据集合，包括了单向链表、双向链表、循环链表、带头节点的链表、十字链表等。在Java中，并没有实现那么多复杂的结构，它的实现类包括了ArrayList、LinkedList、Vector三大类，下面详细介绍各个实现类。</p>
<a id="more"></a>
<h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是List家族最常用的一个类了，它是一个变长的数组，实际上它的内部实现也是通过一个对象数组实现的。它实现了List、RandomAccess、Cloneable、Serializable接口，这四个接口的含义是：</p>
<ul>
<li>List代表的是一个有序的数组，顺序为插入时候的先后顺序，成员可以是基本数据类型和类，用户可以通过下标访问成员，也可以查询成员是否存在</li>
<li>RandomAccess接口比较有意思，它用来修饰实现了List接口的类，也就是说实现该接口必须先实现List接口。它表示该类可以进行快速的随机访问。具体的含义可以理解为代码段</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)</div><div class="line">         list.get(i);</div></pre></td></tr></table></figure>
<p> 的运行速度比下面的代码段快</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Iterator i=list.iterator(); i.hasNext(); )</div><div class="line">    i.next();</div></pre></td></tr></table></figure>
<ul>
<li>Cloneable接口代表的是该类可以进行复制，并保留原有的属性值，实现该接口的类必须有一个public的clone方法</li>
<li>Serializable接口是序列化中的关键，只有实现了该接口的类才可以正常的进行序列化和反序列化</li>
</ul>
<p>上面说到ArrayList内部实现是一个数组，那么它的长度是多少呢，它又是怎么实现变长的呢，数组的元素类型又是什么呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></div><div class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></div><div class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></div><div class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div></pre></td></tr></table></figure>
<p>上面的成员变量就是ArrayList中实际存元素的数组，通过注释我们也可以看出，ArrayList有一个默认的长度，在JDK8中为10，也可以通过构造函数传入默认的长度。ArrayList在添加元素的时候，会保证当前的数组有剩余空间，通过<code>ensureCapacityInternal(size + 1);  // Increments modCount!!</code>来实现，调用该方法保证当前数组长度大于等于size+1，方法内部调用<br><code>ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</code> calculateCapacity方法返回的是默认容量和传入的minCapacity间的最大值，ensureExplicitCapacity方法会判断minCapacity是否大于elementData的长度，如果小于，调用grow方法，对elementData扩容。grow方法默认扩充原elementData的一半长度（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>），如果newCapacity仍然小于minCapacity的话，则<code>newCapacity = minCapacity;</code></p>
<p>在ensureExplicitCapacity方法的调用第一句有一句有趣的代码为<code>modCount++</code>，这个属性我最开始以为是类似于魔数的含义，但最后发现并不是，它的定义语句位于AbstractList中，通过注释可以看到，它的存在是为了解决并发访问的问题，由于ArrayList没有加锁，因此当我们返回它的Iterator之后，一旦对该List进行元素的增删改，就会发生并发错误，ArrayList通过modCount来避免该现象，当ArrayList发生了结构变化时(增删改、自排序)，modCount会自增，这就会于返回Iterator时的值不同，因此直接抛出ConcurrentModificationException异常，这是Java实现的一个fail-fast机制，此时我们可以重新返回新的Iterator元素，重新进行数据的遍历。在ArrayList的序列化和反序列化中，modCount也扮演了重要的角色，在调用writeObject方法时，写完对象之后，会判断modCount和写之前的值是否一致，若不一致，也会抛出ConcurrentModificationException异常。如果我们在使用ArrayList时候，需要考虑并发访问，可以考虑使用<code>List list = Collections.synchronizedList(new ArrayList(...));</code>返回一个同步对象了，然后对该同步对象进行并发操作。</p>
<p>ArrayList常用的方法介绍如下：</p>
<ul>
<li>add方法向数组最后添加一个元素，该方法也可以将元素添加到指定的位置</li>
<li>remove方法可以删除指定位置的元素，也可以删除与指定元素相同的元素，也可以传入一个下标区间，删除该区间内的元素</li>
<li>get方法返回指定位置的元素，set方法修改指定位置的元素</li>
<li>isEmpty方法判断是否为空</li>
<li>iterator方法返回一个遍历对象，该对象可以通过next方法遍历数组</li>
<li>sort方法可以传入一个comparator对象实现数组的自排序，comparator可以定义排序规则</li>
<li>subList可以返回指定区间的子数组，listIterator可以返回指定位置开始的子Iterator</li>
</ul>
<p>ArrayList中通过iterator方法返回一个遍历对象，该对象的类原型是一个ArrayList中的内部类Itr，该类实现了Iterator接口，可以通过next方法遍历数组，并可以通过remove删除当前位置的元素，forEachRemaining方法传入一个Consumer，可以对当前位置之后的所有元素执行Consumer的动作，在特定的场景下可以应用。通过Itr对象进行的元素更改，对原ArrayList会产生影响。上面说到的modCount在Itr中重要的应用，用以防止在Itr对象的生命周期中，原始ArrayList没有发生结构上的变化，若发生了变化，则抛出异常，但通过Itr的remove方法进行的修改不会抛出异常。Itr的remove方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">        cursor = lastRet;</div><div class="line">        lastRet = -<span class="number">1</span>;</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>expectedModCount是一个Itr对象的属性，在该对象创建的时候赋值为modCount，checkForComodification方法判断两值是否相等，若不相等，则抛出异常。remove方法调用的ArrayList的remove方法删除指定位置(lastRet)的元素，删除该元素后，cursor指向了lastRet位置，由于该位置元素已经被删除，因此指向了原位置的下一元素，lastRet指向-1，因此，Itr的remove方法不可以连续执行。</p>
<h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList是一个第一眼看上去很熟悉，但用的时候却总是想不起来的一个角色，对于我来说，它的使用频率甚至少于Stack（Vector的子类），但因为它的名字里面带了List，因此我在第二位分析它。</p>
<p>LinkedList是一个双向链表，它实现了List、Deque、Cloneable、Serializable接口，其他三个都在ArrayList中进行了分析，这里重点介绍Deque接口。Deque光看名字好像跟Queue有点关系，但又不完全相同，实际上它是Queue的子接口，它是一个支持从头、尾两端进行添加元素和删除元素的队列，也就是“double ended queue”。它的添加、删除两头元素的方法都有两种形式，一种是遇到错误的时候抛出异常、一种是遇到错误返回特定的值（null或false），下表是这些方法的详细说明。</p>
<table>
<thead>
<tr>
<th>/</th>
<th>抛出异常</th>
<th>返回特定值</th>
<th>抛出异常</th>
<th>返回特定值</th>
</tr>
</thead>
<tbody>
<tr>
<td>添加</td>
<td>addFirst(e)</td>
<td>offerFirst(e)</td>
<td>addLast(e)</td>
<td>offerLast(e)</td>
</tr>
<tr>
<td>删除</td>
<td>removeFirst()</td>
<td>pullFirst()</td>
<td>removeLast()</td>
<td>pullLast()</td>
</tr>
<tr>
<td>获取值</td>
<td>getFirst()</td>
<td>peekFirst()</td>
<td>getLast()</td>
<td>peekLast()</td>
</tr>
</tbody>
</table>
<p>由于Deque可以在两端增删元素，因此也可以用作栈来使用，实际上，它也提供了相应的方法，push、pop、peek、它们与上面的方法的对应关系为</p>
<table>
<thead>
<tr>
<th>Stack方法</th>
<th>Deque对应的方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>push(e)</td>
<td>addFirst(e)</td>
</tr>
<tr>
<td>pop()</td>
<td>removeFirst()</td>
</tr>
<tr>
<td>peek()</td>
<td>peekFirst()</td>
</tr>
</tbody>
</table>
<p>由此可见，当被用作栈的时候，栈顶为Deque的第一个元素。</p>
<p>LinkedList是双向链表，与ArrayList相比，它或许更有资格称为“List”，因为，它的内部实现就是通过一组节点和节点的引用来构成的，节点类是一个内部类Node，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它通过一个next指向下一个节点，通过prev指向前一个节点。LinkedList通过保存两个节点first、last来记录链表的头部和尾部，通过size属性来记录当前链表的长度。当需要添加一个元素的时候，LinkedList将该节点添加到last之后，当需要删除一个节点的时候，LinkedList从first节点向后遍历，逐一比对，删除第一个相同的节点（equals返回true）。</p>
<p>当调用set、get(index) 方法的时候，LinkedList会根据index来选择比较近的路径找到对应节点（从头向尾或者从尾向头），通过调用node(index)返回对应的节点。该方法的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看到，当index小于size的一半时，从first节点向后，大于时，从last节点从后向前。</p>
<p>LinkedList中有个内部类ListItr，它是ListIterator的一个实现类，ListIterator提供了双向遍历数组的能力，这也是LinkedLIst的能力，该Iterator返回node节点，next方法也是通过Node的next“指针”来进行的，它和ArrayList中的Itr一样，并不会返回一个全新的对象，对它的元素的删除、添加是直接对原LinkedList中的节点的操作，因此也需要防止并发错误，也是通过了modCount来实现的，具体原理与ArrayList中相同。DescendingIterator是一个从后向前遍历的单向Iterator，内部实现使用了ListIterator。</p>
<h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector也是一个第一眼看来很眼熟，但不怎么常用的类(在C++中可能更常用些)，这主要源于它很大程度上与ArrayList的功能相同，内部也是通过对象数组来进行元素的存储。它与ArrayList的主要不同有两点：</p>
<ul>
<li>提供了capacityIncrement来控制当数组空间不足时，新增的容量，这在需要严格控制内存的使用的应用上有时可以派上用场，但鉴于Java应用大多数跑在服务器上，所以似乎用处不大</li>
<li>它是<strong>线程安全</strong>的。这在多线程编程时，自己不想实现类似结构的时候，可以临时使用Vector来代替。但由于其内部实现是通过在方法上直接修饰synchronized来形成同步方法，因此并发度并不高，因此使用场景也比较有限。</li>
</ul>
<p>Vector也提供了Itr和ListItr两种遍历对象来进行数组的遍历，其内部实现逻辑与ArrayList相同，也是通过一个cursor记录当前的遍历位置，在涉及到元素修改的代码中，添加了synchronized (Vector.this)来确保元素的操作是线程安全的。</p>
<h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack跟List家族的关系并不大，在这里介绍主要是因为它是Vector的子类，但它却不是数组，而是栈(LIFO)。栈顶位于Vector的最后一个位置，添加和删除都是从该位置进行的。Stack提供了栈的几个基本的操作，包括push、pop、peek、empty查看是否为空，search返回元素距栈顶的距离。</p>
<p>Stack只是栈的一个最基本的实现，更加具体的实现由Deque和它的实现类提供，在实际使用中应该倾向于使用该类，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</div></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>List家族的几员大将已经分析完毕，还剩一个CopyOnWriteArrayList由于涉及更多关于线程的知识，暂时不在这里讨论，通过总结List中的几个常用类，对它们的使用场景有了更深的认识，并了解了modCount机制，这是一个简单避免线程不安全的方法，在编程中是一个不错的小技巧。List中动态分配内存空间的思想也对于高效编程有很大的帮助，理解它们有助于编写出GC友好的代码。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
            <tag> List </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cgroups资源限制]]></title>
      <url>/2017/11/07/cgroups_info/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>资源隔离技术namespace通过系统调用构建了一个相对隔离的shell环境，在该环境下资源的使用不会影响宿主机，这已经有“容器”的雏形了。而如何将隔离出来的资源合理的使用，这就需要另一个强大的内核工具——cgroups。它不仅可以限制被namespace隔离的资源，还可以为资源设置权重、计算使用量、操控任务(进程或线程)启停等，Docker通过cgroups进行运行时资源的限制。</p>
<a id="more"></a>
<h1 id="cgroups简介"><a href="#cgroups简介" class="headerlink" title="cgroups简介"></a>cgroups简介</h1><p>cgroups最初名为process container，但由于container的多重含义，最后改名为control groups，顾名思义就是把任务放到一个组里，统一进行控制。因此，cgroups控制对象是任务组，一旦一个任务加入了一个组中，就会受到相关联的cgroups的资源限制，这里的资源指的是物理资源(cpu、Memory)。</p>
<p>cgroups的4个特征:</p>
<ul>
<li>cgroups以一个伪文件系统的方式实现，用户态的程序可以通过文件操作实现cgroups的组织管理</li>
<li>cgroups组织管理的单元可以细到线程级别，用户可以创建和销毁cgroup，实现资源再分配和管理</li>
<li>所有资源管理都以子系统的方式实现，接口统一</li>
<li>子任务创建之初与父任务处于同一cgroup</li>
</ul>
<h1 id="cgroups的核心功能和术语"><a href="#cgroups的核心功能和术语" class="headerlink" title="cgroups的核心功能和术语"></a>cgroups的核心功能和术语</h1><p>cgroups为不同用户层面的资源管理提供了一个统一化的接口，实现了资源的虚拟化，主要提供了四大功能：</p>
<ul>
<li><strong>资源限制</strong>：cgroups可以对任务组使用的资源总额进行限制，如内存上限</li>
<li><strong>优先级</strong>：通过分配CPU时间片数量及磁盘IO带宽大小，变相控制任务优先级</li>
<li><strong>资源统计</strong>：统计资源使用量，如CPU使用时长，适用于计费</li>
<li><strong>任务控制</strong>：cgroups可以对任务执行挂起、恢复等操作。</li>
</ul>
<p>cgroups的几个术语</p>
<ul>
<li><strong>task(任务)</strong>:表示系统的一个进程或线程</li>
<li><strong>cgroup(控制组)</strong>:cgroups资源控制的最小单位，表示按某种资源控制标准划分的任务组，包含一个或多个子系统。一个任务可以加入某个cgroup，也可以从某个cgroup迁移到另一个cgroup</li>
<li><strong>subsystem(子系统)</strong>：资源调度器，如CPU子系统、内存子系统</li>
<li><strong>hierarchy(层级)</strong>：由一系列cgroup以树状结构排列而成，每个层级绑定子系统进行资源控制。层级中cgroup节点可以有0或多个子节点，子节点继承父节点的子系统。整个操作系统有多个层级。</li>
</ul>
<h1 id="cgroups的组织结构和基本规则"><a href="#cgroups的组织结构和基本规则" class="headerlink" title="cgroups的组织结构和基本规则"></a>cgroups的组织结构和基本规则</h1><p>前面说到cgroup是一个树状结构，但系统中多个cgroup构成的并非一个单根结构，而是可以存在多个，最终构成了一个cgroup森林。这样做的目的是，如果只有一个层级，则所有的任务都将被迫绑定其上的所有子系统，这会给某些人物带来不必要的限制。在Docker中，每个子系统独自构成一个层级，这样做非常易于管理。组织结构图如下：</p>
<p><img src="http://ww1.sinaimg.cn/mw690/aa213e02jw1eup8axdxb5j21fp1hs465.jpg" alt="image"></p>
<p>上面这个图从整体结构上描述了进程与 cgroups 之间的关系。最下面的P代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构css_set（cgroups subsystem set）。 指向某一个css_set的进程会被加入到当前css_set的进程链表中。一个进程只能隶属于一个css_set，一个css_set可以包含多个进程，隶属于同一css_set的进程受到同一个css_set所关联的资源限制。</p>
<p>上图中的”M×N Linkage”说明的是css_set通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许css_set同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。</p>
<p>一个css_set关联多个 cgroups 层级结构的节点时，表明需要对当前css_set下的进程进行多种资源的控制。而一个 cgroups 节点关联多个css_set时，表明多个css_set下的进程列表受到同一份资源的相同限制。</p>
<p>cgroups、任务、子系统、层级四者间的关系及其基本规则如下：</p>
<ul>
<li>同一个层级可以附加一个或多个子系统</li>
<li>一个已经附加在某个层级上的子系统不能附加到其他含有别的子系统的层级上。</li>
<li>一个任务不能存在于同一个层级的不同cgroup中，但可以存在不同层级的多个cgroup中。</li>
<li>刚fork/clone出的子任务在初始状态与其父任务处于同一个cgroup，但子任务允许被移动到不同的cgroup中。</li>
</ul>
<h1 id="子系统简介"><a href="#子系统简介" class="headerlink" title="子系统简介"></a>子系统简介</h1><p>子系统就是cgroups的资源控制系统，每种子系统独立地控制一种资源，目前Docker使用如下9种子系统：</p>
<ul>
<li>blkio:块设备输入/输出限制，如物理驱动设备(包括磁盘、固态、USB等)。Linux中分为块设备和字符设备两种，块设备以块存储数据，可以进行数据的寻址；字符设备提供连续的数据流，按字节/字符读取，如键盘、串口等。</li>
<li>cpu: 使用调度程序控制任务对cpu的使用</li>
<li>cpuacct：自动生成cgroup中任务对CPU资源使用情况的报告</li>
<li>cpuset: 可以为cgroup中任务数分配独立的cpu(针对多处理器)</li>
<li>devices: 可以开启或关闭对设备的访问</li>
<li>freezer: 挂起或恢复cgroup中的任务</li>
<li>memory: 可以设定cgroup中任务对内存使用量的限定，并自动生成内存使用情况报告</li>
<li>perf_event: 对cgroup中的任务可以进行统一的性能测试</li>
<li>net_cls: 使用等级识别符标记网络数据包，从而允许Linux流量控制程序识别从具体cgroup中生成的数据包</li>
</ul>
<h1 id="cgroups实现方式"><a href="#cgroups实现方式" class="headerlink" title="cgroups实现方式"></a>cgroups实现方式</h1><p>cgroups的实质是给任务挂上钩子，当任务运行的工程中涉及某种资源时，就会触发钩子上所附带的子系统进行检测，根据资源类别的不同，使用相应的技术进行资源限制和优先级分配。</p>
<p>cgroup与任务是多对多的关系，它们不直接关联，而是通过一个中间结构把双向的关联信息记录起来，类似于数据库中的中间表。任务结构体task_struct中包含了一个指针，可以查询相应的cgroup情况，同时可以查询子系统的状态，子系统状态中也包含了找到任务的指针。</p>
<p>一个cgroup创建完成，不管绑定了何种子系统，其目录下都会生成以下几个文件，用来描述cgroup相应信息。</p>
<ul>
<li>tasks： 这个文件罗列所有在该cgroup中任务的TID，即所有进程或线程的ID，并不保证有序。</li>
<li>cgroup.procs: 罗列所有在该cgroup中的TGID(线程组ID)，即线程组中的一个进程的PID。不保证有序和无重复，写一个TGID到这个文件就代表把与其相关的线程加到这个cgroup中。</li>
<li>notify_on_release: 填0或1，表示cgroup中最后一个任务退出时通知运行release_agent，默认不运行(0)</li>
<li>release_agent：指定release_agent执行脚本的文件路径，用于自动化卸载无用的cgroup</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>cgroups通过与cgroup关联的子系统，形成了对进程组的资源限制。它一个伪文件系统的方式实现，并可以通过文件操作实现组织管理，最终提供了资源限制、优先级分配、资源统计、任务控制四大功能。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> cgroups </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Collection简介]]></title>
      <url>/2017/11/04/java_collection/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Java编程中集合类可以说给我们提供了很多的便利，在享受它带来的便利的时候，有时候也会想它的内部是怎么实现的，近期给自己定了个小目标，就是把Collection接口相关的jdk源码看一下，进行一个系统的总结和梳理，一方面提升自己源码阅读的能力，另一方面，通过阅读大神的代码，是自己对于集合这块的数据结构有个更加深刻的了解，对自己以后的使用相信也会有很大的益处。因为自己平时其他的事情也比较多，而且jdk1.8中相关的类也比较多，就先定一个月的时间吧，截止日期12月1日，希望可以完成。</p>
<a id="more"></a>
<h1 id="Collection体系综述"><a href="#Collection体系综述" class="headerlink" title="Collection体系综述"></a>Collection体系综述</h1><p>阅读源码首先得有一个总体的结构认识，不然直接一头扎到类中的每个方法实现细节，只能是盲人摸象，摸到啥算啥。因此，我决定从Java SE 1.8的官方API入手，先梳理Collection这个核心接口，搞清楚它的父接口、子接口以及实现类，形成一个宏观的认识，然后再对它的子接口及其实现类分模块进行梳理，相信会对之后的阅读有一个引导作用。</p>
<p>Collection接口的关系图如下：</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-4/24208556.jpg" alt=""></p>
<ul>
<li>上图中菱形代表的是接口，矩形代表的是类，箭头所指的方向为父类或父接口</li>
</ul>
<p>Collection继承了Iterable接口，Iterable接口在1.8之前都只有一个抽象方法，叫做iterator,返回一个Iterator对象，也就是说，该接口赋予了Collection遍历自己的能力。因此，一个Collection的子类拥有如下的特点：</p>
<ul>
<li>元素的集合，{element1, element2, …, elementn}</li>
<li>可以通过返回的Iterator进行遍历</li>
<li>具有add、remove方法，可以添加或删除元素、集合。</li>
<li>1.8之后，removeIf方法可以传入lambda表达式，通过条件判断进行删除</li>
</ul>
<h1 id="Collection子接口综述"><a href="#Collection子接口综述" class="headerlink" title="Collection子接口综述"></a>Collection子接口综述</h1><p>由上图可以看出，Collection接口的主要子接口为Set、List、Queue(<em>BeanContext并不属于Collection 框架中的成员，且其位于java.beans.beancontext包中，暂时不进行讨论</em>)，三个子接口的特点如下:</p>
<ul>
<li>Set接口表示的一类集合，该集合中element不可重复，且没有先后顺序</li>
<li>List接口表示的类似于数组的一类集合，该集合有先后顺序且可以通过下标进行访问，且可以存放重复元素</li>
<li>Queue通常表示的为FIFO序列，优先队列根据优先级弹出，Queue也就是队列的一个统一接口</li>
</ul>
<p>除了上面的三个直接子接口，Map接口也是Collection Framework中重要的一员，它代表的是一组<k,v>键值对，也可以称为hash表，可以通过key值来访问指定的元素。</k,v></p>
<p>Collection的相关子接口、子类关系如下表所示：</p>
<table>
<thead>
<tr>
<th>接口名</th>
<th>Hash表</th>
<th>变长数组（Resizable Array）</th>
<th>平衡树(Balanced Tree)</th>
<th>链表(Linked List)</th>
<th>链表实现的Hash表</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set</td>
<td>HashSet</td>
<td></td>
<td>TreeSet(红黑树)</td>
<td></td>
<td>LinkedHashSet</td>
</tr>
<tr>
<td>List</td>
<td></td>
<td>ArrayList</td>
<td></td>
<td>LinkedList</td>
</tr>
<tr>
<td>Deque</td>
<td></td>
<td>ArrayList</td>
<td></td>
<td>LinkedList</td>
</tr>
<tr>
<td>Map</td>
<td>HashMap</td>
<td></td>
<td>TreeMap(红黑树)</td>
<td></td>
<td>LinkedHashMap</td>
</tr>
</tbody>
</table>
<h1 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h1><p>Collections类并不是Collection接口的一个实现类，但它却和Collection接口息息相关，因为该类是集合的一个工具类，方法均为静态方法，传入参数大多数为List，也有一部分为Collection。该类是一个集合算法的工具类，提供了诸如集合排序和查找的算法，下面对提供的算法进行一个总结。</p>
<h2 id="改变元素顺序的方法"><a href="#改变元素顺序的方法" class="headerlink" title="改变元素顺序的方法"></a>改变元素顺序的方法</h2><p>sort方法提供了对List及其子类的排序功能(毕竟Set无序)，内部实现的算法是归并排序的算法，该方法是快速和稳定的。</p>
<ul>
<li><strong>快速：</strong>保证时间复杂度在O(n logn)</li>
<li><strong>稳定：</strong>不重排列相等的元素，这在多次排序中很重要，第二次排序希望第一次排完序的部分保持</li>
</ul>
<p>sort方法的方法头如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></div></pre></td></tr></table></figure>
<ul>
<li>可以自定义Comparator实现升序、降序排序</li>
</ul>
<p>swap方法提供了对List指定两个位置元素进行交换的方法，声明为<code>public static void swap(List&lt;?&gt; list, int i, int j)</code>，将位于i,j的元素进行交换</p>
<p>shuffle方法提供了对List及其子类的乱序功能，它可以利用一个Random对象，随机的将位于i的元素和位于random.nextInt(i)的元素交换，核心代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</div><div class="line">    swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</div></pre></td></tr></table></figure>
<ul>
<li>在i-1的位置时，从i到size的元素已经被乱序，因此使用nextInt(i)随机的与前i个元素中的一个进行交换</li>
<li>该方法在形成测试数据时很适用</li>
</ul>
<p>reverse方法将List首尾倒置，该方法的时间复杂度为O(n),核心代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</div><div class="line">    swap(list, i, j);</div></pre></td></tr></table></figure>
<h2 id="改变元素值的方法"><a href="#改变元素值的方法" class="headerlink" title="改变元素值的方法"></a>改变元素值的方法</h2><p>fill方法将List的每个元素设置为指定的元素，该方法在进行数组的初始化时适用。</p>
<p>replaceAll方法将List中指定的旧值设置为新值。</p>
<p>copy方法将src list中的元素全部拷贝到dest list中，并覆盖dest list.</p>
<h2 id="查询类方法"><a href="#查询类方法" class="headerlink" title="查询类方法"></a>查询类方法</h2><p>max方法和min方法分别返回序列中的最大值和最小值，通过遍历找到最大、最小值。</p>
<p>binarySearch方法在一个排好序的方法使用二分查找的方法查找一个元素的位置，该方法对于实现了RandomAccess接口的序列可以在logn时间内找到该元素，但对于未实现该接口，该方法将使用遍历的算法进行查找。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</div><div class="line">    <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</div></pre></td></tr></table></figure>
<p>disjoint方法传入两个集合，如果两个集合没有交集，则返回true，否则，返回false.</p>
<h2 id="序列初始化"><a href="#序列初始化" class="headerlink" title="序列初始化"></a>序列初始化</h2><p>empty*方法可以返回空List、Set等。</p>
<p>synchronized*方法可以将传入的List、Set等，返回线程安全的List、Set，适用于多线程编程，但其内部使用的synchronized同步语句，因此并发度不高。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Collection Framework是Java集合编程的一个重要的工具，通过梳理Collection接口，基本理清了涉及到的接口和对象，接下来将按照List、Set、Queue、Map的顺序依次进行各自模块的梳理。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Collection </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux中的namespace综述]]></title>
      <url>/2017/11/01/linux_namespace/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>namespace是Linux内核中实现资源隔离的手段，通过将资源对象划分为不同的namespace，有效的防止了资源的误用，也防止了不同namespace间资源的互扰。Docker的资源隔离在本质上使用了namespace，达到容器资源与宿主机的隔离，防止容器对宿主机的资源侵染。</p>
<a id="more"></a>
<h1 id="namespace类型"><a href="#namespace类型" class="headerlink" title="namespace类型"></a>namespace类型</h1><p>Linux内核提供了6种namespace隔离的系统调用，这也是一个容器所需要做的6项隔离，具体的隔离类型见下表。</p>
<table>
<thead>
<tr>
<th>namespace</th>
<th>系统调用参数</th>
<th>隔离对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>主机名与域名</td>
</tr>
<tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>信号量、消息队列和共享内存</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>进程编号</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>网络设备、网络栈、端口等</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>挂载点（文件系统）</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>用户和用户组</td>
</tr>
</tbody>
</table>
<ul>
<li>Mount对应的系统调用参数比较特殊，因为它是第一个namespace，所以定义为了CLONE_NEWNS，而不是相关语义</li>
</ul>
<p>Docker的启动，首先就是需要一个文件系统，也就是一个挂载点(Mount)，有了它，容器的存储就能和宿主机的隔离开来；紧接着就是需要网络的隔离(Network)，因为容器之间需要通过独立的IP、端口等进行分布式环境下的通信，有了它，容器就能形成一个隔离于宿主机的“内网”环境，此处的“内网”指的是容器组成的网络。有了容器组成的网络，自然而然每个容器都需要一个主机名来在网络中标识自己，因此就需要主机名和域名的隔离(UTS)。容器内部进程可能会形成协同工作，因此需要进程间的通信，自然就需要信号量、消息队列和共享内存的隔离(IPC)。而容器的进程和宿主机的进程如何进行区分呢？自然需要不同的进程号，因此需要进行进程号隔离(PID)。有了这些，进程和文件的权限自然也离不开用户权限的隔离(User)。因此，上表中的6项namespace基本满足了docker所需要的全部隔离对象。</p>
<h1 id="namespace的API"><a href="#namespace的API" class="headerlink" title="namespace的API"></a>namespace的API</h1><p>Linux内核提供了几种namespace操作的方式，其中包括了系统函数调用和文件描述。系统函数调用包括了clone()、setns()、unshare()，文件描述主要是/proc下的文件。在使用系统调用的时候，通常需要6个参数中的一个或者多个，通过|(位或)连接。6个参数即是表格中的CLONE_NEWUTS、CLONE_NEWIPC、CLONE_NEWPID、CLONE_NEWNET、CLONE_NEWNS和CLONE_NEWUSER。</p>
<h2 id="通过clone-创建namespace"><a href="#通过clone-创建namespace" class="headerlink" title="通过clone()创建namespace"></a>通过clone()创建namespace</h2><p>使用clone()来创建一个独立namespace的进程，是最常见的做法，也是Docker使用namespace最基本的方法，它在创建一个进程的同时，顺带创建了一个独立的namespace。调用方式如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *args)</div></pre></td></tr></table></figure>
<p>clone()实际上是fork()的一种更通用的实现，它通过flags来控制使用多少功能，一共有20多种CLONE_*的flag参数。clone函数的参数说明如下：</p>
<ul>
<li>child_func传入子进程运行的程序主函数</li>
<li>child_stack传入子进程的栈空间</li>
<li>flags表示使用哪些CLONE_*标志位，与namespace相关的为上面提到的6个。</li>
<li>args用于传入用户参数。</li>
</ul>
<h2 id="proc-pid-ns文件"><a href="#proc-pid-ns文件" class="headerlink" title="/proc/[pid]/ns文件"></a>/proc/[pid]/ns文件</h2><p>用户可以在/proc/[pid]/ns文件下看到指向不同namespace号的文件，效果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ls -l /proc/$$/ns</span></div><div class="line">total 0</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 ipc -&gt; ipc:[4026531839]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 mnt -&gt; mnt:[4026531840]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 net -&gt; net:[4026531956]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 pid -&gt; pid:[4026531836]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 user -&gt; user:[4026531837]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 uts -&gt; uts:[4026531838]</div></pre></td></tr></table></figure>
<ul>
<li>形如[4026531839]即为namespace号</li>
<li>$$是shell中表示当前运行的进程ID号</li>
</ul>
<p>若两个进程指向的namespace号相同，就说明它们在同一个namespace下。/proc/[pid]/ns里的link文件一旦被打开，只要该文件描述符存在，即使该namespace下所有进程都已经结束，这个namespace也会存在，可以通过文件描述符将后续进程加入进来。Docker就是通过文件描述符定位和加入namespace的。</p>
<p>通过–bind方式挂载可以起到同样作用。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># touch ~/uts</span></div><div class="line"><span class="comment"># mount --bind /proc/27514/ns/uts ~/uts</span></div></pre></td></tr></table></figure>
<p>上述命令将~/uts文件与该namespace文件绑定，可以通过~/uts文件来使得后续进程加入该namespace中。</p>
<h2 id="setns-加入已存在的namespace"><a href="#setns-加入已存在的namespace" class="headerlink" title="setns()加入已存在的namespace"></a>setns()加入已存在的namespace</h2><p>上面使用挂载方式将namespace保留下来，可以使用setns()系统调用加入该namespace，使用方法如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setns</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> nstype)</span></span>;</div></pre></td></tr></table></figure>
<ul>
<li>参数fd表示要加入namespace的文件描述符，可以通过open()，打开挂载的文件(如~/uts）获得。</li>
<li>nstype让调用者可以检查fd指向的namespace是否符合要求。为0表示不检查。</li>
</ul>
<p>典型用法如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fd=open(argv[<span class="number">1</span>], O_RDONLY);</div><div class="line">setns(fd, <span class="number">0</span>);</div><div class="line">execvp(argv[<span class="number">2</span>], &amp;argv[<span class="number">2</span>]);</div></pre></td></tr></table></figure>
<p>假设该程序编译为setns-test</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ./setns-test ~/uts /bin/bash</span></div></pre></td></tr></table></figure>
<p>可以在新加入的namespace中执行shell命令了。</p>
<h2 id="unshare-在原进程上进行namespace隔离"><a href="#unshare-在原进程上进行namespace隔离" class="headerlink" title="unshare()在原进程上进行namespace隔离"></a>unshare()在原进程上进行namespace隔离</h2><p>unshare()运行在原进程上，不需要启动新进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unshare</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</div></pre></td></tr></table></figure>
<p>unshare()可以在不启动新进程的前提下，跳出原先的namespace进行操作，以达到隔离的目的。</p>
<h1 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h1><p>UTS(UNIX Time-sharing System) namespace提供了主机名和域名的隔离，这样每个docker都可以拥有独立的主机名和域名，在网络上可以被视为一个独立的节点，而非宿主机上的一个进程。Docker中，每个镜像基本都以自身所提供的服务名称来命名镜像的hostname，且不会对宿主机有任何影响，其原理就是利用了UTS namespace。</p>
<h1 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h1><p>进程间通信(Inter-Process Communication)涉及的IPC资源包括常见的信号量、消息队列和共享内存。申请IPC资源就申请了一个全局唯一的32位ID，所以IPC namespace实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，不同IPC namespace下的进程则互相不可见。</p>
<p>Docker使用IPC namespace实现了容器与宿主机、容器与容器之间的IPC隔离。</p>
<h1 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h1><p>PID namespace隔离对进程PID重新编号，使得两个不同namespace下的进程可以有相同的PID。每个PID namespace都有自己的计数器。内核为所有的PID namespace维护了一个树状结构，最顶层的为系统初始时创建，为root namespace。树状结构中的父子节点对应的为namespace的父子关系。父节点可以看到子节点中的进程，并可以通过信号对子节点中进程产生影响。反之，子节点无法看到父节点中德任何内容。</p>
<ul>
<li>每个PID namespace中的第一个进程“PID 1”，就像Linux中的init进程一样，拥有特权</li>
<li>一个namespace中的进程不能通过kill或ptrace影响父节点或兄弟节点中的进程。</li>
<li>如果在新的PID namespace中重新挂载/proc文件系统，会发现只显示同属一个PID namespace中的其他进程</li>
<li>在root namespace中可以看到所有进程，并可以通过递归包含所有子节点中进程。</li>
</ul>
<p>因此，要实现外部监控Docker运行的程序，可以通过监控Docker daemon所在的PID namespace下的所有进程及其子进程，在进行筛选即可。</p>
<h1 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h1><p>mount namespace通过隔离文件系统挂载点来对文件系统进行隔离保护，隔离后，不同mount namespace下的文件结构变化互不影响。可以通过/proc/[pid]/mounts查看到所有挂载在当前namespace中的文件系统，还可以通过/proc/[pid]/mountstats看到文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等。</p>
<p>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新的namespace中所有的mount操作都只影响自身的文件系统，对外界不影响。但若父节点进程中挂载了一个CD-ROM，此时子节点namespace无法自动挂载该CD-ROM。</p>
<p>挂载传播定义了挂载对象之间的关系，包括共享关系和从属关系。</p>
<ul>
<li><strong>共享关系</strong>。若两个挂载对象具有共享关系，则一个挂载对象中的挂载事件会传播到另一个挂载对象中。反之亦然。</li>
<li><strong>从属关系</strong>。若两个挂载对象形成从属关系，则一个挂载对象中的挂载事件会传播到另一个挂载对象中，但是反之不行。</li>
</ul>
<p>一个挂载状态可能为以下中的一种：</p>
<ul>
<li>共享挂载</li>
<li>从属挂载</li>
<li>共享/从属挂载</li>
<li>私有挂载</li>
<li>不可绑定挂载</li>
</ul>
<p>传播事件的为共享挂载，接受传播事件的为从属挂载，同时具有前两者特征的为共享/从属挂载，既不传播又不接受传播事件的为私有挂载，而不可绑定挂载除具有私有挂载约束外，不允许执行绑定挂载，即创建mount namespace时这块文件对象不可被复制。</p>
<h1 id="network-namespace"><a href="#network-namespace" class="headerlink" title="network namespace"></a>network namespace</h1><p>network namespace提供了关于网络资源的隔离，包括网络设备、IPV4和IPv6协议栈、IP路由表、防火墙、/proc/net目录、/sys/class/net目录、套接字（socket）等。一个物理的网络设备最多存在于一个network namespace中，可以通过创建 veth pair在不同的network namespace间创建管道，以达到通信目的。</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-1/18129128.jpg" alt=""></p>
<p>Docker网络如上图所示，使用veth pair创建一个独立网络实体，进行通信。veth pair一端放置在容器的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过多个设备连入网桥或者进行路由转发，实现通信的目的。</p>
<h1 id="user-namespace"><a href="#user-namespace" class="headerlink" title="user namespace"></a>user namespace</h1><p>user namespace隔离了安全相关的标识符和属性，包括用户id、用户组id、key（指密钥）以及特殊权限。一个普通用户的进程创建的新进程在新user namespace中可以拥有不同的用户和用户组。也就是说，一个进程在容器外属于没有特权的普通用户，但进入容器却属于拥有所有权限的超级用户，这使得在保护宿主机的安全基础上，为容器提供了极大的自由。</p>
<ul>
<li>user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样该init进程就可以完成所有必要的初始化工作，而不会因为权限不足出现错误。</li>
<li>从namespace内部观察的UID和GID已经与外部不同，默认为65534，表示尚未与外部namespace用户映射。此时可以进行映射，以保证当涉及一些外部namespace操作时，系统可以检验其权限。</li>
<li>用户在新namespace中有全部权限，但他在创建它的父namespace中不含任何权限。因此即使root用户调用clone在user namespace创建了新用户，它在外部也没有任何权限。</li>
<li>user namespace的创建其实是一个层层嵌套的树状结构。最上层是root namespace，新创建的每个user namespace都有一个父节点，以及零个或多个子节点。</li>
</ul>
<p>Docker不仅使用了user namespace，还使用了在user namespace中涉及的Capabilities机制。Linux把原来和超级用户相关的高级权限划分为不同的单元，称为Capabilities。这样管理员可以独立的对特定的Capabilities进行使用和禁止。Docker同时使用两者，在很大程度上加强了容器的安全性。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>namespace是一个在很多地方都有应用的概念，Linux使用该概念进行了6项资源的限制，对资源的使用进行了保护。Docker起源于Linux，利用namespace达成了容器与宿主机、容器与容器间的资源隔离。利用namespace，我们可以在容器中为所欲为，而对宿主机没有丝毫的影响，这也是容器的便利之一。</p>
]]></content>
      
        <categories>
            
            <category> Linux </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
            <tag> namespace </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Etcd集群安装]]></title>
      <url>/2017/10/31/etcd_install/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Etcd是一个分布式的K/V存储组件，主要用于存储元数据和配置数据，典型应用是Kubernetes中，用于服务发现和节点注册。本篇文章主要介绍了3节点下安装Etcd集群及其配置过程，主要参考了<a href="http://blog.frognew.com/2017/04/install-etcd-cluster.html" target="_blank" rel="external">青蛙小白</a>的博客，解决了安装过程中的一部分问题，并加入了etcdctl工具的配置步骤，方便日后的参考。</p>
<a id="more"></a>
<h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><p>Centos 7<br>IP | hostname<br>—|—<br>192.168.202.131 | etcd-1<br>192.168.202.132 | etcd-2<br>192.168.202.133 | etcd-3</p>
<h1 id="TLS密钥和证书"><a href="#TLS密钥和证书" class="headerlink" title="TLS密钥和证书"></a>TLS密钥和证书</h1><p>部署的etcd集群使用TLS证书对集群中节点间通信进行加密，并开启基于CA根证书签名的双向数字证书认证。本文档使用<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="external">cfssl</a>来生成CA证书以及其他需要的证书。生成的证书列表如下：  </p>
<ul>
<li>ca.pem</li>
<li>etcd.pem</li>
<li>etcd-key.pem<br>下面介绍使用cfssl生成所需要的私钥和证书.</li>
</ul>
<h1 id="安装cfssl"><a href="#安装cfssl" class="headerlink" title="安装cfssl"></a>安装<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="external">cfssl</a></h1><h2 id="方式一：直接使用二进制包安装"><a href="#方式一：直接使用二进制包安装" class="headerlink" title="方式一：直接使用二进制包安装"></a>方式一：直接使用二进制包安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</div><div class="line">$ chmod +x cfssl_linux-amd64</div><div class="line">$ sudo mv cfssl_linux-amd64 /root/local/bin/cfssl</div><div class="line"></div><div class="line">$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</div><div class="line">$ chmod +x cfssljson_linux-amd64</div><div class="line">$ sudo mv cfssljson_linux-amd64 /root/local/bin/cfssljson</div><div class="line"></div><div class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</div><div class="line">$ chmod +x cfssl-certinfo_linux-amd64</div><div class="line">$ sudo mv cfssl-certinfo_linux-amd64 /root/local/bin/cfssl-certinfo</div><div class="line"></div><div class="line">$ export PATH=/root/local/bin:$PATH</div></pre></td></tr></table></figure>
<h2 id="方式二：使用go命令安装"><a href="#方式二：使用go命令安装" class="headerlink" title="方式二：使用go命令安装"></a>方式二：使用go命令安装</h2><p>如果系统中安装过Go的话，可以直接使用命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/cloudflare/cfssl/cmd/...</div><div class="line">$ echo $GOPATH</div><div class="line">/usr/local</div><div class="line">$ ls /usr/local/bin/cfssl*</div><div class="line">cfssl cfssl-bundle cfssl-certinfo cfssljson cfssl-newkey cfssl-scan</div></pre></td></tr></table></figure></p>
<h1 id="创建CA证书"><a href="#创建CA证书" class="headerlink" title="创建CA证书"></a>创建CA证书</h1><h2 id="创建CA的配置文件ca-config-json"><a href="#创建CA的配置文件ca-config-json" class="headerlink" title="创建CA的配置文件ca-config.json"></a>创建CA的配置文件ca-config.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ mkdir /root/ssl</div><div class="line">$ cd /root/ssl</div><div class="line">$ cfssl print-defaults config &gt; ca-config.json</div><div class="line">$ cfssl print-defaults csr &gt; ca-csr.json</div><div class="line">$ cat ca-config.json</div><div class="line">&#123;</div><div class="line">  &quot;signing&quot;: &#123;</div><div class="line">    &quot;default&quot;: &#123;</div><div class="line">      &quot;expiry&quot;: &quot;8760h&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;profiles&quot;: &#123;</div><div class="line">      &quot;frognew&quot;: &#123;</div><div class="line">        &quot;usages&quot;: [</div><div class="line">            &quot;signing&quot;,</div><div class="line">            &quot;key encipherment&quot;,</div><div class="line">            &quot;server auth&quot;,</div><div class="line">            &quot;client auth&quot;</div><div class="line">        ],</div><div class="line">        &quot;expiry&quot;: &quot;87600h&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>ca-config.json中可以定义多个profile，分别设置不同的expiry和usages等参数。如上面的ca-config.json中定义了名称为frognew的profile，这个profile的expiry 87600h为10年，useages中：</p>
<ul>
<li>signing表示此CA证书可以用于签名其他证书，ca.pem中的CA=TRUE</li>
<li>server auth表示TLS Server Authentication, 即client可以用该 CA 对server提供的证书进行验证</li>
<li>client auth表示TLS Client Authentication，即server可以用该CA对client提供的证书进行验证</li>
</ul>
<h2 id="创建CA证书签名请求配置ca-csr-json："><a href="#创建CA证书签名请求配置ca-csr-json：" class="headerlink" title="创建CA证书签名请求配置ca-csr.json："></a>创建CA证书签名请求配置ca-csr.json：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;CN&quot;: &quot;frognew&quot;,</div><div class="line">  &quot;key&quot;: &#123;</div><div class="line">    &quot;algo&quot;: &quot;rsa&quot;,</div><div class="line">    &quot;size&quot;: 2048</div><div class="line">  &#125;,</div><div class="line">  &quot;names&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;C&quot;: &quot;CN&quot;,</div><div class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</div><div class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</div><div class="line">      &quot;O&quot;: &quot;frognew&quot;,</div><div class="line">      &quot;OU&quot;: &quot;cloudnative&quot;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面使用cfssl生成CA证书和私钥:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</div><div class="line">$ ls ca*</div><div class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</div></pre></td></tr></table></figure>
<h1 id="Etcd证书和私钥"><a href="#Etcd证书和私钥" class="headerlink" title="Etcd证书和私钥"></a>Etcd证书和私钥</h1><p>创建etcd证书签名请求配置etcd-csr.json：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;CN&quot;: &quot;frognew&quot;,</div><div class="line">    &quot;hosts&quot;: [</div><div class="line">      &quot;127.0.0.1&quot;,</div><div class="line">      &quot;192.168.202.131&quot;,</div><div class="line">      &quot;192.168.202.132&quot;,</div><div class="line">      &quot;192.168.202.133&quot;,</div><div class="line">      &quot;etcd-1&quot;,</div><div class="line">      &quot;etcd-2&quot;,</div><div class="line">      &quot;etcd-3&quot;</div><div class="line">    ],</div><div class="line">    &quot;key&quot;: &#123;</div><div class="line">        &quot;algo&quot;: &quot;rsa&quot;,</div><div class="line">        &quot;size&quot;: 2048</div><div class="line">    &#125;,</div><div class="line">    &quot;names&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;C&quot;: &quot;CN&quot;,</div><div class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</div><div class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</div><div class="line">            &quot;O&quot;: &quot;frognew&quot;,</div><div class="line">            &quot;OU&quot;: &quot;cloudnative&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面配置hosts字段中制定授权使用该证书的IP和域名列表，因为现在要生成的证书需要被etcd集群各个节点使用，所以这里指定了各个节点的IP和hostname。</p>
<p>下面生成etcd的证书和私钥：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=frognew etcd-csr.json | cfssljson -bare etcd</div><div class="line"></div><div class="line">$ ls etcd*</div><div class="line">etcd.csr  etcd-csr.json  etcd-key.pem  etcd.pem</div></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>：确认-config的参数文件名和路径正确，可以使用绝对路径；etcd-csr.json在当前目录下存在，也可以为绝对路径，否则会报config文件json格式有误，但并不是文件内容的错误，而是路径和文件名错误。<br>对生成的证书可以使用cfssl或者openssl查看：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl-certinfo -cert etcd.pem</div><div class="line"></div><div class="line">$ openssl x509  -noout -text -in  etcd.pem</div></pre></td></tr></table></figure>
<ul>
<li>确认 Issuer 字段的内容和 ca-csr.json 一致；</li>
<li>确认 Subject 字段的内容和 etcd-csr.json 一致；</li>
<li>确认 X509v3 Subject Alternative Name 字段的内容和 etcd-csr.json 一致；</li>
<li>确认 X509v3 Key Usage、Extended Key Usage 字段的内容和 ca-config.json 中 profile 一致；</li>
</ul>
<h1 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h1><p>Etcd可以使用二进制安装和yum源安装两种方式</p>
<h2 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/coreos/etcd/releases/download/v3.1.6/etcd-v3.1.6-linux-amd64.tar.gz</div></pre></td></tr></table></figure>
<p>解压缩etcd-v3.1.6-linux-amd64.tar.gz，将其中的etcd和etcdctl两个可执行文件复制到各节点的/usr/bin目录。</p>
<h2 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum list etcd</div><div class="line">$ yum install -y etcd</div></pre></td></tr></table></figure>
<p>安装完成之后，在各节点创建etcd的数据目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/lib/etcd</div></pre></td></tr></table></figure>
<p>使用systemctl启动和管理etcd服务，在每个节点上创建etcd的systemd unit文件/usr/lib/systemd/system/etcd.service，注意替换ETCD_NAME和INTERNAL_IP变量的值：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">export ETCD_NAME=node1</div><div class="line">export INTERNAL_IP=192.168.202.131</div><div class="line">cat  /usr/lib/systemd/system/etcd.service</div><div class="line">[Unit]</div><div class="line">Description=etcd server</div><div class="line">After=network.target</div><div class="line">After=network-online.target</div><div class="line">Wants=network-online.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=notify</div><div class="line">WorkingDirectory=/var/lib/etcd/</div><div class="line">EnvironmentFile=-/etc/etcd/etcd.conf</div><div class="line">ExecStart=/usr/bin/etcd \</div><div class="line">  --name $&#123;ETCD_NAME&#125; \</div><div class="line">  --cert-file=/etc/etcd/ssl/etcd.pem \</div><div class="line">  --key-file=/etc/etcd/ssl/etcd-key.pem \</div><div class="line">  --peer-cert-file=/etc/etcd/ssl/etcd.pem \</div><div class="line">  --peer-key-file=/etc/etcd/ssl/etcd-key.pem \</div><div class="line">  --trusted-ca-file=/etc/etcd/ssl/ca.pem \</div><div class="line">  --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \</div><div class="line">  --initial-advertise-peer-urls https://$&#123;INTERNAL_IP&#125;:2380 \</div><div class="line">  --listen-peer-urls https://$&#123;INTERNAL_IP&#125;:2380 \</div><div class="line">  --listen-client-urls https://$&#123;INTERNAL_IP&#125;:2379,https://127.0.0.1:2379 \</div><div class="line">  --advertise-client-urls https://$&#123;INTERNAL_IP&#125;:2379 \</div><div class="line">  --initial-cluster-token etcd-cluster-1 \</div><div class="line">  --initial-cluster node1=https://192.168.202.131:2380,node2=https://192.168.202.132:2380,node3=https://192.168.202.133:2380 \</div><div class="line">  --initial-cluster-state new \</div><div class="line">  --data-dir=/var/lib/etcd</div><div class="line">Restart=on-failure</div><div class="line">RestartSec=5</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div><div class="line">EOF</div></pre></td></tr></table></figure>
<ul>
<li>–data-dir指定了etcd的工作目录和数据目录是/var/lib/etcd</li>
<li>–cert-file和–key-file分别指定etcd的公钥证书和私钥</li>
<li>–peer-cert-file和–peer-key-file分别指定了etcd的Peers通信的公钥证书和私钥。</li>
<li>–trusted-ca-file指定了客户端的CA证书</li>
<li>–peer-trusted-ca-file指定了Peers的CA证书</li>
<li>–initial-cluster-state new表示这是新初始化集群，–name指定的参数值必须在–initial-cluster中  </li>
</ul>
<p><strong>注意</strong>：在etcd.pem生成时hosts配置了Ip地址列表和hostname列表，在etcd的service(/usr/lib/systemd/system/etcd.service)文件中，所有ip不能代替为未包含的hostname，如master</p>
<h1 id="启动Etcd"><a href="#启动Etcd" class="headerlink" title="启动Etcd"></a>启动Etcd</h1><p>在各节点上启动etcd：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ systemctl daemon-reload</div><div class="line">$ systemctl enable etcd</div><div class="line">$ systemctl start etcd</div><div class="line">$ systemctl status etcd</div></pre></td></tr></table></figure>
<p>在启动etcd的时候，可以开启另一个命令窗口，查看启动日志，确保没有报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">journalctl -f</div></pre></td></tr></table></figure>
<ul>
<li>如果出现了形如 <code>unkown flag</code>的字段，表示启动参数错误，不识别,说明该参数拼写错误(<em>如–keyfile应当为–key-file</em>),可以到官方配置文档<a href="https://github.com/coreos/etcd/blob/master/Documentation/op-guide/configuration.md" target="_blank" rel="external">Configuration flags</a>查看该参数的写法，确保正确。</li>
<li>如果出现<code>Failed to find member fXXXXXX</code>的错误，这说明之前启动的etcd时，标识号出现错误，此时删除<code>/var/lib/etcd/member</code>目录，让etcd重新为每个节点分配标识号, <code>/var/lib/etcd</code>为etcd启动配置工作目录</li>
</ul>
<p>如果日志一切正常，可以使用<code>etcdctl</code>检查集群是否健康，在任一节点执行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">etcdctl \</div><div class="line">  --ca-file=/etc/etcd/ssl/ca.pem \</div><div class="line">  --cert-file=/etc/etcd/ssl/etcd.pem \</div><div class="line">  --key-file=/etc/etcd/ssl/etcd-key.pem \</div><div class="line">  --endpoints=https://node1:2379,https://node2:2379,https://node3:2379 \</div><div class="line">  cluster-health</div><div class="line"></div><div class="line">2017-04-24 19:53:40.545148 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">2017-04-24 19:53:40.546127 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">member 4f2f99d70000fc19 is healthy: got healthy result from https://192.168.202.132:2379</div><div class="line">member 99a756f799eb4163 is healthy: got healthy result from https://192.168.202.131:2379</div><div class="line">member a9aff19397de2e4e is healthy: got healthy result from https://192.168.202.133:2379</div><div class="line">cluster is healthy</div></pre></td></tr></table></figure>
<p>确保输出<code>cluster is healthy</code>的信息。<br>上面的命令使用证书访问，返回正常信息，若未添加证书，使用<code>etcdctl member list</code>访问，应当报错，否则，TLS(安全认证)未生效，即使用http访问etcd集群。</p>
<h1 id="etcdctl配置"><a href="#etcdctl配置" class="headerlink" title="etcdctl配置"></a>etcdctl配置</h1><p>由于使用了TLS安全认证，etcdctl 查询时需要在命令行中指定证书和endpoints，会使得一条命令变得很长，可以预先创建一个etcdctl配置文件，进行相应的配置.</p>
<ol>
<li>创建etcdctl配置文件</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ vi /etc/etcd/etcdctl</div><div class="line">$ cat /etc/etcd/etcdctl</div><div class="line">export ETCDCTL_API=3</div><div class="line">export ETCDCTL_ENDPOINTS=&quot;https://etcd-1:2379,https://etcd-2:2379,https://etcd-3:2379&quot;</div><div class="line">export ETCDCTL_CACERT=/etc/etcd/ssl/ca.pem</div><div class="line">export ETCDCTL_CERT=/etc/etcd/ssl/etcd.pem</div><div class="line">export ETCDCTL_KEY=/etc/etcd/ssl/etcd-key.pem</div></pre></td></tr></table></figure>
<ol>
<li>使配置文件生效</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source /etc/etcd/etcdctl</div></pre></td></tr></table></figure>
<ol>
<li>查看集群状态</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ etcdctl cluster-health</div><div class="line"></div><div class="line">2017-04-24 19:53:40.545148 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">2017-04-24 19:53:40.546127 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">member 4f2f99d70000fc19 is healthy: got healthy result from https://192.168.202.132:2379</div><div class="line">member 99a756f799eb4163 is healthy: got healthy result from https://192.168.202.131:2379</div><div class="line">member a9aff19397de2e4e is healthy: got healthy result from https://192.168.202.133:2379</div><div class="line">cluster is healthy</div></pre></td></tr></table></figure>
<p>etcdctl配置的本质是定义ETCDCTL_ENDPOINT常量，etcdctl运行时读取该常量值，进行连接，具体的常量名称可以参考官方的配置说明<a href="https://github.com/coreos/etcd/tree/master/etcdctl" target="_blank" rel="external">etcdctl config</a></p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md" target="_blank" rel="external">Clustering Guide</a></li>
<li><a href="https://github.com/coreos/etcd/tree/master/etcdctl" target="_blank" rel="external">etcdctl config</a></li>
<li><a href="https://github.com/cloudflare/cfssl" target="_blank" rel="external">cloudflare/cfssl</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> kubernetes </category>
            
        </categories>
        
        
        <tags>
            
            <tag> etcd </tag>
            
            <tag> kubernetes </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HDFS永久性数据结构]]></title>
      <url>/2017/10/20/hdfs_structer/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲解了HDFS是如何在磁盘上组织永久性数据的，主要从NameNode、Secondary NameNode和DataNode的目录结构以及fsimage和edits文件几个方面进行介绍，了解这些文件的用法有助于进行故障诊断和故障检出。</p>
<a id="more"></a>
<h1 id="Namenode的目录结构"><a href="#Namenode的目录结构" class="headerlink" title="Namenode的目录结构"></a>Namenode的目录结构</h1><p>NameNode在被格式化之后，会产生如下的目录结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$&#123;dfs.name.dir&#125;/</div><div class="line">|---current/</div><div class="line">    |--- VERSION</div><div class="line">    |--- edits</div><div class="line">    |--- fsimage</div><div class="line">    |--- fstime</div></pre></td></tr></table></figure>
<ul>
<li><code>${dfs.name.dir}</code> 是HDFS配置文件的一个属性名，存储着镜像内容，推荐配置为一个NFS的挂载。</li>
</ul>
<p>VERSION文件是一个Java属性文件，其中包含了正在运行的HDFS的版本信息，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespaceID=134368444</div><div class="line">cTime=0</div><div class="line">storageType=NAME_NODE</div><div class="line">layoutVersion=-18</div></pre></td></tr></table></figure>
<ul>
<li><code>namespaceID</code>属性是HDFS文件系统的唯一标识符，是在文件系统首次格式化(<code>hadoop namenode -format</code>)的时候设置的。datanode在注册到NameNode之前都不知道<code>namespaceID</code>的值，因此NameNode可以通过该属性来鉴别是否为新建的DataNode</li>
<li><code>cTime</code>属性标记了NameNode的创建时间，对于刚格式化的存储系统，该值为0，；但在文件系统升级之后，该值会更新到新的时间戳</li>
<li><code>storageType</code>属性说明该存储目录(<code>${dfs.name.dir}/current/</code>)</li>
<li><code>layoutVersion</code>属性是一个负整数，描述HDFS持久性数据结构（也称布局）的版本号，但是与Hadoop发布包的版本号无关。只要HDFS布局变更，版本号变回递减(-1)，此时，HDFS也需要升级。否则，磁盘仍然使用旧版本的布局，新版本的NameNode无法工作。</li>
</ul>
<p>NameNode的存储目录中还包含edits、fsimage、和fstime等二进制文件。这些文件都使用Hadoop的Writable对象作为其序列化格式。</p>
<h1 id="fsimage和edits-文件"><a href="#fsimage和edits-文件" class="headerlink" title="fsimage和edits 文件"></a>fsimage和edits 文件</h1><p>HDFS客户端执行写操作（创建、移动文件）时，这些操作信息都会记录在edits文件中。NameNode在内存中维护HDFS的元数据；当edits日志被修改时，内存中的元数据也会同步更新，该元数据支持客户端的读请求。</p>
<p>每次执行写操作时，首先修改edits文件，并进行更新和同步。在NameNode向多个目录写数据时，只有所有的写操作均完毕后方才返回成功代码，以确保不会因为机器故障而丢失(所有操作都在edits文件中，可以在恢复时进行相应操作的重演，类似于write ahead log的思想)。</p>
<p>fsimage是HDFS元数据的一个永久性的checkpoint。由于fsimage很大(可高达几个GB)，如果频繁写，会拖慢系统的运行，因此，并非每一次写操作都会更新该文件。在NameNode发生故障后，可以先将fsimage文件读入内存进行重构，然后执行edits中记录的各项操作，这也是NameNode启动阶段做的事情。</p>
<p>fsimage包含了HDFS中所有目录和文件inode的序列化信息。每个inode都是一个文件或目录的元数据内部描述。对文件，包含信息有”副本级别”(replication level)、修改时间和访问时间、访问许可、块大小、组成该文件的块等；对于目录，包含的信息有修改时间、访问许可和配额元数据等信息。</p>
<p>edits文件会无限增长，这虽然不会拖慢NameNode的运行，但会使得NameNode的启动异常耗时，有违用户的期待，因此，secondary NameNode应用而生。</p>
<p>Secondary NameNode辅助NameNode创建fsimage文件，它主要的功能有两个</p>
<ul>
<li>作为备份，在NameNode故障时升级为NameNode提供服务</li>
<li>定期合并edits和fsimage文件，防止NameNode故障重启时，由于fsimage长时间没有同步，执行edits的恢复操作很耗时。</li>
</ul>
<p>Secondary NameNode的工作步骤如下图所示</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-10-16/61956212.jpg" alt=""></p>
<ol>
<li>SecondaryNameNode通知NameNode准备提交edits文件，此时主节点将新的写操作数据记录到一个新的文件edits.new中。</li>
<li>SecondaryNameNode通过HTTP GET方式获取NameNode的fsimage与edits文件（在SecondaryNameNode的current同级目录下可见到 temp.check-point或者previous-checkpoint目录，这些目录中存储着从namenode拷贝来的镜像文件）。</li>
<li>Secondary NameNode将获取的fsimage文件载入内存，并逐一执行edits文件的操作，产生新的fsimage文件fsimage.chpt</li>
<li>SecondaryNameNode用HTTP POST方式发送fsimage.ckpt至NameNode。</li>
<li>NameNode将fsimage.ckpt与edits.new文件分别重命名为fsimage与edits，然后更新fstime，记录检查点执行的时间，到此整个checkpoint过程到此结束。</li>
</ol>
<p>最终，NameNode拥有一个更新的fsimage文件和一个更小的edits文件(在Secondary NameNode执行merge时，NameNode可能收到新的写请求)。在NameNode处在安全模式是，管理员可使用<code>hadoop dfsadmin -saveNamespace</code>命令主动创建checkpoint。</p>
<p>该过程解释了Secondary NameNode和NameNode拥有相近内存需求的原因，因为Secondary NameNode在合并时需要先将fsimage读入内存中。创建checkpoint的触发条件有两个限制：通常情况下，Secondary NameNode每个一小时(fs.checkpoint.period属性设置，以秒为单位)创建一次；此外，当edits文件达到64MB(fs.checkpoint.size属性设置，以字节为单位)，即使没到一小时，也会创建checkpoint。系统每5分钟检查一次edits的大小。</p>
<h1 id="Secondary-NameNode的目录结构"><a href="#Secondary-NameNode的目录结构" class="headerlink" title="Secondary NameNode的目录结构"></a>Secondary NameNode的目录结构</h1><p>创建checkpoint不仅为NameNode创建了checkpoint，还使得Secondary NameNode也有了一份备份数据(存储在previous.checkpoint目录中)，此数据可用于NameNode元数据的备份</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$&#123;fs.checkpoint.dir&#125;/</div><div class="line">|---current/</div><div class="line">|   |--- VERSION</div><div class="line">|   |--- edits</div><div class="line">|   |--- fsimage</div><div class="line">|   |--- fstime</div><div class="line">|---previous.checkpoint/</div><div class="line">    |--- VERSION</div><div class="line">    |--- edits</div><div class="line">    |--- fsimage</div><div class="line">    |--- fstime</div></pre></td></tr></table></figure>
<p>Secondary NameNode的previous.checkpoint/和current/与NameNode的current目录布局相同。在NameNode发生故障时，可以从Secondary NameNode恢复数据。有两种方法实现。</p>
<ol>
<li>将相应目录复制到新的NameNode中</li>
<li>使用-importCheckpoint选项，启动NameNode守护进程，从而是Secondary NameNode用作新的NameNode。</li>
</ol>
<h1 id="DataNode的目录结构"><a href="#DataNode的目录结构" class="headerlink" title="DataNode的目录结构"></a>DataNode的目录结构</h1><p>与NameNode不同，DataNode的存储目录是初始阶段自动创建的，不需额外格式化。结构如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$&#123;dfs.data.dir&#125;/</div><div class="line">|---current/</div><div class="line">    |--- VERSION</div><div class="line">    |--- blk_&lt;id_1&gt;</div><div class="line">    |--- blk_&lt;id_1&gt;.meta</div><div class="line">    |--- blk_&lt;id_2&gt;</div><div class="line">    |--- blk_&lt;id_2&gt;.meta</div><div class="line">    |--- ...</div><div class="line">    |--- blk_&lt;id_64&gt;</div><div class="line">    |--- blk_&lt;id_64&gt;.meta</div><div class="line">    |--- subdir0/</div><div class="line">    |--- subdir1/</div><div class="line">    |--- ...</div><div class="line">    |--- subdir63/</div></pre></td></tr></table></figure>
<p>DataNode的VERSION文件与NameNode的VERSION文件类似，如下所示</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">namespaceID=134368444</div><div class="line">storageID=DS-547717739-172.16.85.1-50010-1236720751627</div><div class="line">cTime=0</div><div class="line">storageType=DATA_NODE</div><div class="line">layoutVersion=-18</div></pre></td></tr></table></figure>
<p>namespaceID、cTime、layoutVersion都与NameNode中的值相同。namespaceID是DataNode首次访问NameNode时获取的。storageID对每个DataNode来说是唯一的(但对单个DataNode中所有存储目录来说则相同)，NameNode可用该值区分不同DataNode。storageType表明该目录是DataNode的存储结构。</p>
<p>DataNode的current目录中其他文件都有blk_前缀，包括两种类型：HDFS块文件(仅包含原始数据)和块的元数据(.meta后缀)。块文件包含所存储文件的一部分原始数据(文件分块存储)；元数据包括头部(含版本和类型)及该块各区段的一系列校验和。</p>
<p>当目录中数据块文件增加到一定规模，DataNode会创建一个子目录来存放新的块和元数据信息。如果当前目录存储到64个(由dfs.datanode.numblocks设置)，就创建一个子目录。最终设计一个高扇出的目录树，即使快数量很多，但目录树的层数也不多。</p>
<p>如果dfs.data.dir属性指定不同磁盘上的多个目录，数据块会以轮转(round-robin)的方式写到各个目录中。同一个DataNode上的每个磁盘的块不重复，不同DataNode之间的块才可能重复（如三备份原则保证同一机架的两个DataNode备份，不同机架上有一个DataNode备份）</p>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> hdfs目录结构 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[VMware虚拟机添加磁盘]]></title>
      <url>/2017/10/19/vmware_addDisk/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在搞使用CDH安装Hadoop的时候，需要搭建一个内网的yum源(参考<a href="http://www.wangjialong.cc/2017/09/14/private_yum/">使用httpd搭建内网yum源</a>)，并把CDH的RPM包放上去，方便虚拟机内网使用yum进行安装。由于我最开始虚拟机内网yum源只设置了20G的磁盘，硬盘剩余空间已经不够用，因此考虑给该虚拟机添加硬盘，并将该硬盘挂载到httpd的子目录上，在该磁盘上单独放CDH的包。</p>
<a id="more"></a>
<h1 id="新建硬盘"><a href="#新建硬盘" class="headerlink" title="新建硬盘"></a>新建硬盘</h1><p>VMware添加硬盘非常简单，只需要鼠标右键想要添加硬盘的虚拟机，然后点击添加，选择硬盘，根据向导进行添加即可。</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-10-19/45118131.jpg" alt=""></p>
<p>图形化的向导使用非常方便，在此不作赘述，从上图可以看出，我已经添加了一个20G的硬盘到该虚拟机上，在上图的设备名为硬盘2.</p>
<h1 id="在虚拟机上查看磁盘信息"><a href="#在虚拟机上查看磁盘信息" class="headerlink" title="在虚拟机上查看磁盘信息"></a>在虚拟机上查看磁盘信息</h1><p>启动该虚拟机，在命令行使用<code>fdisk</code>命令查看添加的磁盘是否存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# fdisk -l | grep sd</div><div class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors</div><div class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</div><div class="line">/dev/sda2         2099200    41943039    19921920   8e  Linux LVM</div><div class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</div></pre></td></tr></table></figure>
<p>打印出的/dev/sdb即是我添加的硬盘，由于它是新添加的硬盘，所以没有像sda那样的分区( 即sda1、sda2)。如果有在Windows上使用磁盘管理器的经验的话，就会知道新添加的硬盘是无法直接使用的，需要给该硬盘进行分区，使得Linux系统“认识”它。</p>
<h1 id="fdisk工具添加分区"><a href="#fdisk工具添加分区" class="headerlink" title="fdisk工具添加分区"></a>fdisk工具添加分区</h1><p>根据上一步的结果，我们知道新加的硬盘名称为/dev/sdb， 因此我们可以直接使用<code>fdisk</code>给该硬盘进行分区。<code>fdisk</code>是Linux上一个类似于Windows上的磁盘管理器的工具，它简便易用，可以方便的进行硬盘分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# fdisk /dev/sdb</div><div class="line">Welcome to fdisk (util-linux 2.23.2).</div><div class="line"></div><div class="line">Changes will remain in memory only, until you decide to write them.</div><div class="line">Be careful before using the write command.</div><div class="line"></div><div class="line"></div><div class="line">Command (m for help): m</div><div class="line">Command action</div><div class="line">   a   toggle a bootable flag</div><div class="line">   b   edit bsd disklabel</div><div class="line">   c   toggle the dos compatibility flag</div><div class="line">   d   delete a partition</div><div class="line">   g   create a new empty GPT partition table</div><div class="line">   G   create an IRIX (SGI) partition table</div><div class="line">   l   list known partition types</div><div class="line">   m   print this menu</div><div class="line">   n   add a new partition</div><div class="line">   o   create a new empty DOS partition table</div><div class="line">   p   print the partition table</div><div class="line">   q   quit without saving changes</div><div class="line">   s   create a new empty Sun disklabel</div><div class="line">   t   change a partition&apos;s system id</div><div class="line">   u   change display/entry units</div><div class="line">   v   verify the partition table</div><div class="line">   w   write table to disk and exit</div><div class="line">   x   extra functionality (experts only)</div><div class="line"></div><div class="line">Command (m for help):</div></pre></td></tr></table></figure>
<p>输入<code>m</code>可查看提示，根据提示可知，输入<code>n</code>可以添加一个新分区。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# fdisk /dev/sdb</div><div class="line">Welcome to fdisk (util-linux 2.23.2).</div><div class="line"></div><div class="line">Changes will remain in memory only, until you decide to write them.</div><div class="line">Be careful before using the write command.</div><div class="line"></div><div class="line"></div><div class="line">Command (m for help): n</div><div class="line">Partition type:</div><div class="line">   p   primary (1 primary, 0 extended, 3 free)</div><div class="line">   e   extended</div><div class="line">Select (default p):</div><div class="line">Using default response p</div><div class="line">Partition number (2-4, default 2):</div><div class="line">First sector (10485760-41943039, default 10485760):</div><div class="line">Using default value 10485760</div><div class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10485760-41943039, default 41943039):</div><div class="line">Using default value 41943039</div><div class="line">Partition 2 of type Linux and of size 15 GiB is set</div><div class="line"></div><div class="line">Command (m for help):</div></pre></td></tr></table></figure>
<p>输入<code>n</code>后，会有一个向导指引创建一个新分区，分为以下几步。</p>
<ol>
<li>选择分区类型，根据上面的信息可以看出，默认是 <code>primary</code>类型</li>
<li>选择分区号，由于我已经创建了一个分区，因此它提示我输入2-4内的整数，当前默认为2，创建后的分区为/dev/sdb2。硬盘最多可以分为4个分区，这个跟MBR和扇区的知识有关系，大概是因为硬盘为分区表保留了64字节，而每个分区参数占16个字节，因此只能存4个分区表，但由于分区可以分为主分区和拓展分区，借助拓展分区，可以分4个以上的分区，可以把拓展分区想象成指向了一块新的硬盘。最新的电脑一般默认采用GPT分区表，几乎没有限制（128个），参考<a href="https://www.ithome.com/html/win8/58192.htm" target="_blank" rel="external">MBR和GPT表</a></li>
<li>选择所创建分区的起始位置，推荐默认，因为这样可以从硬盘剩余空间的开头创建新分区。</li>
<li>选择分区的终止扇区位置，只能输入提示范围内的整数值，这个需要进行简单的计算，由于我新增的硬盘为20G,而我希望新分区为5G，因此将最后一个扇区41943039除以4，再加上3步骤中的起始扇区位置即可。</li>
</ol>
<p>上面四步结束后，新的分区已经创建成功，但该分区表目前还在内存中存储，并没有写入硬盘，需要输入<code>w</code>命令，将分区表写入，此时fdisk命令返回。</p>
<h1 id="格式化新分区"><a href="#格式化新分区" class="headerlink" title="格式化新分区"></a>格式化新分区</h1><p>新分区是没有任何格式的，因此操作系统无法进行读写，因此需要将新分区进行格式化。</p>
<p>查看新分区是否创建成功</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# ll /dev/sd*</div><div class="line">brw-rw----. 1 root disk 8,  0 Oct 17 20:31 /dev/sda</div><div class="line">brw-rw----. 1 root disk 8,  1 Oct 17 20:31 /dev/sda1</div><div class="line">brw-rw----. 1 root disk 8,  2 Oct 17 20:31 /dev/sda2</div><div class="line">brw-rw----. 1 root disk 8, 16 Oct 19 15:04 /dev/sdb</div><div class="line">brw-rw----. 1 root disk 8, 17 Oct 19 15:04 /dev/sdb1</div></pre></td></tr></table></figure>
<p>可以看到，已经有一个<code>/dev/sdb1</code>的设备了，现在进行格式化，centos系统下，格式化ext4的格式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# mkfs.ext4 /dev/sdb1</div></pre></td></tr></table></figure>
<p>新分区已经格式化成功，下面可以挂载了。</p>
<h1 id="挂载新分区"><a href="#挂载新分区" class="headerlink" title="挂载新分区"></a>挂载新分区</h1><p>因为我使用的是httpd搭建的内网yum源，需要放置CDH的文件目录为<code>/var/www/html/cdh</code>，因此我需要将新分区挂载到该目录下.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# mount /dev/sdb1 /var/www/html/cdh</div></pre></td></tr></table></figure>
<p>已经挂载了5G大小的硬盘分区到该目录了，下面可以将CDH的包解压到该目录下了。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> VMware </tag>
            
            <tag> 新增硬盘 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MapReduce中的shuffle详解]]></title>
      <url>/2017/10/10/shuffle/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>shuffle在某些情况下，表达的意义为reduce任务获取map输出的这部分过程，也就是通常意义上的“map-shuffle-reduce”。如果是这种情况下，shuffle表示的是将map输出的键值对，按照key值进行了一个groupby操作，最后得到&lt; key, list[key] &gt;的过程。而在这里，shuffle包含了从map输出到reducer的整个过程，包括了写入磁盘、分区、排序等步骤，有利于理解工作机制，优化MapReduce程序。</p>
<a id="more"></a>
<h1 id="shuffle简述"><a href="#shuffle简述" class="headerlink" title="shuffle简述"></a>shuffle简述</h1><p><img src="http://ow9czedj7.bkt.clouddn.com/17-10-9/56739194.jpg" alt="shuffle"></p>
<p>由上图(<em>引用自<a href="http://www.cnblogs.com/yangyquin/p/5021234.html" target="_blank" rel="external">shuffle和排序</a></em>)所示，shuffle是一个横跨map task 和reduce task的过程，它是map 和 reduce的一个数据桥梁，负责将map输出作为输入传给reducer。在map端包括了写入缓冲区，溢出到磁盘，分区与排序等步骤；在reduce端则包括了复制数据、归并数据、reduce阶段等步骤。</p>
<h1 id="map端"><a href="#map端" class="headerlink" title="map端"></a>map端</h1><p>map函数产生输出时，出于效率的原因并不会直接写入硬盘，而是先放到一个环形内存缓存区中，并将缓存的数据按照key值进行一个预排序。缓冲区默认为100MB，该值可以通过io.sort.mb属性来调整。一旦达到阈值(io.sort.spill.percent, 默认为0.8)，则后台进程开始将内容溢出到磁盘。溢出过程中，map输出仍写入缓冲区，在此期间缓冲区被填满，则会将map阻塞，知道该溢出过程结束。</p>
<p>每个溢出过程都会产生一个文件存到mapred.local.dir属性指定的目录中，在上图中，共产生了三个溢出到磁盘的文件。在溢出到磁盘之前，会根据reducer的数量划分分区，如图中共划分了3个分区，每个分区中，都按键进行内排序，如果指定了combiner，则在排序后的输出上进行，以减少写到磁盘和传递给reducer的数据。上图中每个溢出文件都有3个分区，每个分区内数据都是排好序的。</p>
<p>当map任务结束后，会将溢出到磁盘的文件进行一个合并，如图中，将3个文件合并成了一个文件，合并好的文件中每个分区内的数据也是排好序的。在map输出到磁盘时，可以通过设置mapred.compress.map.output为true和指定mapred.map.output.compression.codec指定压缩格式，这样可以加快溢出到磁盘的速度。</p>
<p>reducer是通过http方式获得输出文件的分区的，如上图中，第一个reducer获取了第一个分区。</p>
<h1 id="reduce端"><a href="#reduce端" class="headerlink" title="reduce端"></a>reduce端</h1><p>reducer会将各个map task上最后溢出的那个文件的对应分区复制到本地，由于map任务的完成时间可能不同，因此只要一个任务完成，reduce任务就开始复制其输出。reduce可以并行的复制map的输出，默认为5个线程，可以通过设置mapred.reduce.parallel.copies属性来改变。对于指定的作业，jobtracker（或App master）知道map输出和tasktracker的映射关系。reducer线程定期询问jobtracker以获取map输出的位置，直到获取全部的输出位置</p>
<p>复制完所有map输出后，就进入到上图中的“sort phase”，但它并不是一个严格意义上的排序过程，可以将它理解成归并排序中的merge过程，将若干个排好序的序列，归并成一个有序文件。这个过程根据合并因子(io.sort.factor设置，默认为10)进行，如果有50个map的输出，而合并因子为10，则每次最多合并10个map输出，因此最后会有5个中间文件。</p>
<p>在reduce阶段，直接将上面的5个中间文件合并成一个已排序的文件输入给reduce函数，最后的合并不需要磁盘的读写，只需要内存和磁盘片段的配合即可。</p>
<p>在“sort phase”时，由于最后一趟的合并总是将结果直接输入给reduce，而没有磁盘写入过程，因此可以据此进行优化。比如如果合并因子为10，有40个文件，此时不会再四趟中每次合并10个文件而得到4个文件，相反，第一趟只合并4个文件，随后的三趟每次合并10个文件，在最后一趟中，4个已合并的文件（4，10，10，10）和6个未合并的文件合并给reduce函数，这并不改变合并次数，却使得合并过程中磁盘只写入了4+10+10+10=34个文件，从而减少了磁盘的数据量。</p>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文是结合《Hadoop权威指南》shuffle和排序章节整理的读书笔记，方便日后的查阅。shuffle是MapReduce中数据传输的核心步骤，深入理解该部分的实现细节，有助于MapReduce程序的优化，通过减少网络上的数据传输，可以有效的提高MapReduce程序的执行效率。</p>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> MapReduce </tag>
            
            <tag> shuffle </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Zookeeper是动物管理员吗]]></title>
      <url>/2017/09/29/zookeeper1/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>熟悉Hadoop的同学肯定听过这么一句话：“Zookeeper是动物管理员，管着大象（Hadoop）、蜜蜂（Hive）和小猪（Pig）”。刚开始接触到的时候感觉，哇，Zookeeper好厉害啊，都可以管理Hadoop、Hive、Pig了。但后面接触到Hive和Pig的时候，发现他们好像只跟MapReduce有关系啊，因此，我不禁有了以下的疑问。</p>
<a id="more"></a>
<h1 id="Zookeeper到底是不是动物管理员？"><a href="#Zookeeper到底是不是动物管理员？" class="headerlink" title="Zookeeper到底是不是动物管理员？"></a>Zookeeper到底是不是动物管理员？</h1><p>这个问题的答案可以从Zookeeper的的官网标志图初探端倪。</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/93495054.jpg" alt="Zookeeper slogan"></p>
<p>由上图，Zookeeper是一个穿着工装，拿着铁锹的工人啊，这不符合管理员的形象吧，管理员不应该是西装革履的吗？好吧，有些牵强，那我们来看看keeper这个词的翻译，使用百度在线翻译的结果如下：</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/36748004.jpg" alt=""></p>
<p>门将是什么鬼？ 还好下面还有翻译，饲养员、保管人、负责人、监护人。这几个词好像都跟管理员有一些差距，有了初步的认识后，是时候深入Zookeeper的原理来进行分析了。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这里我只做简单的介绍，更加详细的内容可以参看最后的参考博客。</p>
<h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Zookeeper中的角色主要分类如下表</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-18/22845559.jpg" alt="zookeeper roles"></p>
<ul>
<li>注意：zkServer默认存在Observer角色，具体配置参看<a href="http://zookeeper.apache.org/doc/trunk/zookeeperObservers.html" target="_blank" rel="external">ZooKeeper Observers</a></li>
</ul>
<p>集群模型如下:</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-18/13063958.jpg" alt="zookeeper service"></p>
<p>结合角色说明表格和上图进行说明，Hadoop中使用Zookeeper的组件如YARN和HBase，都是上图中的client，client通过与server进行连接获取Zookeeper server的服务。那么通过什么方式连接呢？</p>
<h2 id="会话-session"><a href="#会话-session" class="headerlink" title="会话(session)"></a>会话(session)</h2><p>会话记录client与server的连接，client不需要连接所有的server，只需要连接其中一个就可以获得一致性的读写服务。session对应到两种连接方式：心跳连接和watcher监听。</p>
<h2 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h2><p>上一节中说的一致性读写服务所操作的对象就是数据节点。Zookeeper的数据模型如下图：</p>
<p><img src="http://www.wuzesheng.com/wp-content/uploads/2013/12/zookeeper-tree.jpg" alt="image"></p>
<p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每个ZNode都可以通过其路径唯一标识，图中每个节点左侧即为其路径唯一标识。</p>
<p>注：<br>这里的ZNode可以理解成既是Unix里的文件，又是Unix里的目录。因为每个ZNode不仅本身可以写数据（相当于Unix里的文件），还可以有下一级文件或目录（相当于Unix里的目录）。</p>
<p>在ZooKeeper中，ZNode可以分为持久节点和临时节点两类。</p>
<p><strong>持久节点</strong></p>
<p>所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。</p>
<p><strong>临时节点</strong></p>
<p>临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>Watcher（事件监听器），是ZooKeeper中一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。该机制是ZooKeeper实现分布式协调服务的重要特性。</p>
<h1 id="管理者-or-协调者"><a href="#管理者-or-协调者" class="headerlink" title="管理者 or 协调者"></a>管理者 or 协调者</h1><p>通过Zookeeper的数据节点（临时节点特性）和watcher的组合，可以满足诸如服务发布/订阅、命名服务、master选举、分布式锁等功能。而Zookeeper之所以是keeper而不是manager，正是因为它在Hadoop生态中的两大功能是选举和元数据存储，才使得它有了分布式协调者的称号。</p>
<p>元数据指的是配置信息、服务注册列表等，这使得Zookeeper更像是一个分布式的注册表。当client需要使用Zookeeper时，如HBase Master需要选举一个主节点，那么他们就并发的去Zookeeper上创建一个临时节点（节点名称一样），Zookeeper的分布式锁可以保证只有一个client创建成功，最后创建成功的那个节点，就当选为主节点。</p>
<p>Zookeeper在Hadoop中的应用是HDFS和YARN的HA，在HBase中的应用有选举与主备切换、系统容错（RegionServer挂掉后，HMaster获知）、Region状态信息的管理。下面我们来看一下Zookeeper是如何让HMaster获知RegionServer挂掉的信息的。</p>
<p>当HBase启动时，每个RegionServer都会到ZooKeeper的/hbase/rs节点下创建一个信息节点（临时节点，下文中，我们称该节点为”rs状态节点”），例如/hbase/rs/[Hostname]，同时，HMaster会对这个节点注册监听。当某个 RegionServer 挂掉的时候，ZooKeeper会因为在一段时间内无法接受其心跳（即 Session 失效），而删除掉该 RegionServer 服务器对应的 rs 状态节点。与此同时，HMaster 则会接收到 ZooKeeper 的 NodeDelete 通知，从而感知到某个节点断开，并立即开始容错工作。也就是说，Zookeeper是通过心跳机制来维护临时节点信息的，如果心跳发生了timeout，则Zookeeper删除该临时节点，然后通知注册过该临时节点监听的HMaster，所以Zookeeper默认临时节点删除后，该RegionServer处于无法工作状态，至于是网络延时原因还是该RegionServer确实挂掉了，Zookeeper不管。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Zookeeper在Hadoop生态中十分重要，但它并没有上升到管理员的高度，Hadoop中使用Zookeeper服务的组件都有自己的master（NameNode、ResourManager、HMaster），各组件视自己的需求，交付给Zookeeper不同程度的权力。NameNode在实现HA的时候，需要用到Zookeeper的选举和watcher功能，因此交付给Zookeeper两个NameNode，让它来决定谁为Active；YARN的HA也是如此。HMaster交给Zookeeper的权力比较大，HMaster选举与主备切换、系统容错、RootRegion管理、Region状态管理和分布式SplitWAL任务管理等都交给了Zookeeper，让Zookeeper来管理HMaster的主备以及RegionServer信息等。Zookeeper相当于是古代的丞相，皇帝（NameNode、HMaster）给它多少权力，它就执行多大的功能。或许有一天，Zookeeper会成为Hadoop生态的“管仲”、“商鞅”，而那一天会不会实现，就要看Hadoop生态的发展了。。。</p>
<h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ul>
<li><a href="http://www.wangjialong.cc/2017/09/27/etcd&amp;zookeeper/">Zookeeper与etcd的对比</a></li>
<li><a href="http://linbingdong.com/2017/01/10/ZooKeeper原理及其在Hadoop和HBase中的应用/" target="_blank" rel="external">ZooKeeper原理及其在Hadoop和HBase中的应用</a></li>
<li><a href="http://cailin.iteye.com/blog/2014486" target="_blank" rel="external">Zookeeper原理</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> zookeeper </tag>
            
            <tag> HBase </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode 55 Jump Game从回溯到动态规划]]></title>
      <url>/2017/09/29/leetcode55/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>动态规划是一个降低时间的很有效的方法，通常一个可以使用递归从上到下来解决的题目，必定可以转化为动态规划，从下往上计算，并通过设置一个数组存放子问题的解，来降低问题的求解步骤。LeetCode上的第55题可以使用回溯法和动态规划来解决，但回溯法会造成栈溢出，下面讲解我的解题思路。</p>
<a id="more"></a>
<h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>给定一个正整数的数组，你起始的位置位于数组的第一个下标处（也就是0），数组中的每个元素代表在该位置可以跳跃的最大距离（只能向index增加的方向跳跃），判断是否有一条跳跃路径，可以使得你跳到最后一个下标处（也就是length-1）。<br>示例：<br>A = [2,3,1,1,4], return true.</p>
<p>A = [3,2,1,0,4], return false.</p>
<p>原题链接 <a href="https://leetcode.com/problems/jump-game/description/" target="_blank" rel="external">55. Jump Game</a></p>
<h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>相信玩过类似大富豪这样的游戏的同学，理解起这个问题来不会太困难。它相当于有一个起点、一个目的地，从起点到目的地是一个个的格子（只能跳整数个），每个格子规定了当前格子能够跳跃的最大值，让我们来求是否有一条路径可以从起点到终点，文字不太直观，下面我们通过图来展示一下上面的示例。</p>
<p>当 A = [2,3,1,1,4]</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/90212410.jpg" alt=""></p>
<p>由上图，从0的位置最大可以跳2格，选择跳一格，到达下标为1的位置，此时最大可以跳3格，选择跳3格到达终点。因此，应该返回 true。A = [3,2,1,0,4]的情况在此不再做分析。下面开始正式解题。</p>
<h1 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h1><p>第一个回合，根据从起点到终点的特性，理所当然的想到了将问题转化为图问题，于是，我画了下图。</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/75746144.jpg" alt=""></p>
<p>圆形中的数字代表下标，箭头为单向的，因此，问题转变为从0到4的图遍历。但刚定义为Node类我就卡住了。两个原因：</p>
<ul>
<li>每个节点的孩子节点（单向箭头指向的节点）个数不确定</li>
<li>太占内存了，每个node都是一个对象</li>
</ul>
<p>Round 1， defeated ！</p>
<h1 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h1><p>虽然上面的图使我的图遍历解法宣告失败，但是却给了我另一个灵感，就是树遍历的深度优先算法，当到达叶子节点的时候，算法开始回溯，直到回到一个有没有遍历到的叶子节点，再接着向下遍历。</p>
<p>此问题也可以使用回溯算法进行求解，算法的核心思想如下：</p>
<ol>
<li>从index的位置开始，取得当前能够跳跃的最大值n</li>
<li>让i从1到n开始遍历，循环判断当前跳i步，到达的位置是否可以到达终点</li>
<li>若跳i步后，index &gt;最后的位置，则可以到达终点，返回true，否则，递归判断跳i步之后的位置是否可以到达终点</li>
<li>若递归返回false的话，则让i+1,进行下一步循环判断是否可以到达终点</li>
<li>若所有的循环和递归都返回后还没有返回true，则返回false</li>
</ol>
<p>上面那段叙述可能连我自己也看不懂啥意思，没关系，“talk is cheap, show me the code”，下面立即上代码，一目了然。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc55</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</div><div class="line">        lc55 test = <span class="keyword">new</span> lc55();</div><div class="line">        System.out.println(<span class="string">"res ? "</span> + test.canJump(nums));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span>[] flag;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.fill(flag, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">if</span> (check(nums, <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || !flag[index]) &#123;</div><div class="line">            flag[index] = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(index + nums[index] + <span class="number">1</span> &gt;= nums.length)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> n = nums[index];</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (check(nums, index + n)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            --n;</div><div class="line">        &#125;</div><div class="line">        flag[index] = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码应当返回false，结果正确，于是粘贴到LeetCode上run了一下，期望输出一致，赶紧提交吧，傻眼了，栈溢出。。。</p>
<p>回溯算法由于频繁的递归调用，而每次方法的调用都需要进行压榨动作，当方法的嵌套调用过深的时候，就形成了栈溢出问题，虽然算法是正确的，然而AC不了啊，下面继续优化。</p>
<h1 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a>Round 3</h1><p>解决回溯问题的栈溢出，我们一下子就想到了将递归变成循环，因为循环是递归的逆过程。细心的朋友可能发现了，上面代码中，我已经用flag数组来存放子问题的解了，当子问题为false的时候，无需在进行判断，直接返回false，因为我们之前已经求解了一遍了。因此，结合循环和子问题两个思路，我想到了使用动态规划来解决栈溢出的问题。</p>
<p>动态规划最重要的就是确定子问题了，通过之前的分析，不难看出，如果从3的位置可以调到终点，而从0的位置可以跳到3的位置的话，那么从0的位置也可以跳到终点。因此，我们的动态规划算法应当是从后向前遍历的，递推公式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flag[i] = flag[i+1] || flag[i+2] || ... || flag[i+n]</div></pre></td></tr></table></figure></p>
<p>其中n为i位置可以跳的最大步数，有一个特殊情况，如果i+n &gt; last_index的话，则可以直接判断flag[i]为true。<br>有了递推公式，不难写出相应的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc55</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</div><div class="line">        lc55 test = <span class="keyword">new</span> lc55();</div><div class="line">        System.out.println(<span class="string">"res ? "</span> + test.canJump(nums));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span>[] flag;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.fill(flag, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span>(i + nums[i] + <span class="number">1</span> &gt;= nums.length) &#123;</div><div class="line">                flag[i] = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> n = nums[i];</div><div class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (((i + n) &lt; nums.length ) &amp;&amp; flag[i + n]) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i+n &gt; nums.length) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        --n;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这下应该稳了吧，开开心心提交上去，栈溢出倒是解决了，但是出现了一个新的问题，超时！ 纳尼？！ 动态规划不是不计算子问题了吗？怎么还会超时呢，这不科学！</p>
<h1 id="Final-Round"><a href="#Final-Round" class="headerlink" title="Final Round"></a>Final Round</h1><p>通过查看LeetCode上提交的错误信息，可以发现测试用例形如 [29999,29998,29997,…,4,3,2,1,1,0,0]。 聪明的你可能已经发现了，数字从后往前每一步都只加一，也就是说后一格为false的话，那向前一格，数字只增加一的话，那前一格也必定为false啊，文字不清楚，下面通过画图分析。</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/77658785.jpg" alt=""></p>
<p>由上图可知，2所在的格子已经求得为false，i–到达3所在的格子，由于3后面的为2的格子求得为false，所以两个1所在的格子也为false，因此3在求解flag的时候，不需要求解2、1、1这三个格子，因为他们都为false。总结就是如果i所在的格子最大跳n格，i+1所在的格子最大跳n1格，而i+1的格子为false，则只需要求解从i+2+n1格到i+n格的子问题即可，上图中两个0所在的格子。根据这个思想，可以得到下面的优化的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc55</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</div><div class="line">        lc55 test = <span class="keyword">new</span> lc55();</div><div class="line">        System.out.println(<span class="string">"res ? "</span> + test.canJump(nums));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span>[] flag;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.fill(flag, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span>(i + nums[i] + <span class="number">1</span> &gt;= nums.length) &#123;</div><div class="line">                flag[i] = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> n = nums[i];</div><div class="line">                <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</div><div class="line">                    flag[i] = flag[i + <span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span>(n - nums[i+<span class="number">1</span>] &lt; <span class="number">2</span>) &#123; <span class="comment">//若n只比nums[i+1]大1，则flag[i] = flag[i + 1];</span></div><div class="line">                    n = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">while</span>(n - <span class="number">1</span> &gt; nums[i+<span class="number">1</span>]) &#123;   <span class="comment">//只计算从i+2+n1格到i+n格的子问</span></div><div class="line">                    <span class="keyword">if</span> (((i + n) &lt; nums.length ) &amp;&amp; flag[i + n]) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i+n &gt; nums.length) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        --n;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>再次提交代码，终于Accept了，看到绿色的返回值真是开心</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析问题和解决问题的过程是最让人兴奋的，遇到一下子解决不了的问题时，不要轻易的放弃，尝试着继续改进一下，等看到绿色的AC时，往往是最开心的一刻。而即使自己最后真的败下阵来，也没关系，这时候去看大神的解法，会让自己有更多的感受和收获，记忆也会更加的牢固。好了，毒鸡汤撒完了，我去看大神界面工整且逻辑清晰的代码去了。</p>
]]></content>
      
        <categories>
            
            <category> algorithm </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> LeetCode、动态规划 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[zookeeper与etcd的类比]]></title>
      <url>/2017/09/27/etcd&amp;zookeeper/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在看到Pachyderm的介绍时，看到作者拿YARN和Kubernetes做类比，拿Zookeeper和etcd做对比。YARN和Kubernetes的类比还相对比较好理解，毕竟他们都有资源管理和调度的职能，只不过YARN上运行的对象是JVM，而Kubernetes上运行的是容器。但是拿Zookeeper和etcd来类比我就有些不懂了，在我之前的概念里zookeeper并不是一个存储组件啊，因此有了本文的过程。</p>
<a id="more"></a>
<h1 id="Zookeeper和etcd可以做类比吗？"><a href="#Zookeeper和etcd可以做类比吗？" class="headerlink" title="Zookeeper和etcd可以做类比吗？"></a>Zookeeper和etcd可以做类比吗？</h1><p>etcd的官网介绍是一个分布式的K/V存储，而Zookeeper的官网介绍是一个高度可用的分布式协调者。看起来他们做的事情完全不同啊，那我们来比较一下功能介绍。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>etcd</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody>
<tr>
<td>分布式锁</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>watcher</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>一致性算法</td>
<td>raft</td>
<td>zab</td>
</tr>
<tr>
<td>选举</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>元数据(metadata)存储</td>
<td>有</td>
<td>有</td>
</tr>
</tbody>
</table>
<ul>
<li>watcher指的是订阅/通知，当一个值改变时，通知订阅过的节点，在etcd中是K/V值对的改变，在Zookeeper中是znode的改变（值改变、节点删除等）</li>
<li>raft和zab都是paxos算法的变形，都是为了解决分布式系统中的读写一致性问题</li>
<li>选举都是通过相应的一致性算法实现的</li>
</ul>
<blockquote>
<p>功能总结的不到位，欢迎补充</p>
</blockquote>
<p>从功能上看，他们干的事好像也都差不多，分布式的一致性、选举算法、分布式锁，那么，我们来看一下各自的典型应用吧。</p>
<table>
<thead>
<tr>
<th>应用场景</th>
<th>etcd</th>
<th>Zookeeper</th>
</tr>
</thead>
<tbody>
<tr>
<td>发布与订阅（配置中心）</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>软负载均衡</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>命名服务(Naming Service)</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>服务发现</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>分布式通知/协调</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>集群管理与Master选举</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>分布式锁</td>
<td>有</td>
<td>有</td>
</tr>
<tr>
<td>分布式队列</td>
<td>有</td>
<td>有</td>
</tr>
</tbody>
</table>
<blockquote>
<p>分别参考了<a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="external">ZooKeeper典型应用场景一览</a>和<a href="http://www.sel.zju.edu.cn/?p=523" target="_blank" rel="external">ETCD：从应用场景到实现原理的全方位解读</a></p>
</blockquote>
<h1 id="zookeeper可以作为分布式存储吗"><a href="#zookeeper可以作为分布式存储吗" class="headerlink" title="zookeeper可以作为分布式存储吗?"></a>zookeeper可以作为分布式存储吗?</h1><p>在应用场景上，etcd和Zookeeper也很一致，难道Zookeeper本质上是分布式存储组件，为此，我查了下 Zookeeper是否可以作为分布式存储系统？ 在知乎上的答案为 <a href="https://www.zhihu.com/question/22116083" target="_blank" rel="external">zookeeper只存元数据</a>，总结几点原因如下</p>
<ul>
<li>znode只能存1M以内的数据</li>
<li>写入性能低，为保证一致性，每次需要n/2+1的写入完成才算完成</li>
<li>zookeeper的数据是全部存储在内存,只适合存元数据</li>
<li>Zookeeper的使用场景是有高一致性的</li>
</ul>
<p>所以，逻辑上来说，可以。因为Zookeeper本质上是一个内存式的文件系统，它的znode就相当于dictionary和file的结合体，但是由于性能和存储容量以及使用场景来看，Zookeeper适合存有强一致性要求的配置信息，也就是元数据。</p>
<p>到这一步，基本搞清楚了Zookeeper的应用场景了，如果etcd可以和Zookeeper作类比的话，难道etcd不是一个分布式存储组件？</p>
<h1 id="etcd究竟是干啥的？"><a href="#etcd究竟是干啥的？" class="headerlink" title="etcd究竟是干啥的？"></a>etcd究竟是干啥的？</h1><p>回到etcd的官方文档，在Reference下看到一个<a href="https://coreos.com/etcd/docs/latest/learning/why.html" target="_blank" rel="external">etcd versus other key-value stores</a>目录，发现了etcd的名称由来，原来它是”/etc”和”d” for distributed 的结合体， 它存的也是大型分布式系统的配置信息，也就是distributed “/etc”</p>
<p>到此可知，Zookeeper和etcd解决的问题是一样的，都解决分布式系统的协调和元数据的存储，所以它们都不是一个存储组件，或者说都不是一个分布式数据库。etcd灵感来源于Zookeeper，但在实现的时候有了很多的改进。</p>
<ul>
<li>更轻量级、更易用</li>
<li>高负载下的稳定读写</li>
<li>数据模型的多版本并发控制</li>
<li>稳定的watcher功能，通知订阅者监听值的变化</li>
<li>客户端协议使用gRPC协议，支持go、C++、Java等，而Zookeeper的RPC协议是自定制的，目前只支持C和Java</li>
<li>可以容忍脑裂现象的发生</li>
</ul>
<p>脑裂现象指的是，在一个分布式集群中，只允许一个leader协调工作，由于网络或其他原因，导致一个集群分成了两个集群，产生了两个leader同时工作，此时集群不在具备读写一致性。</p>
<blockquote>
<p>etcd是使用raft算法解决的脑裂问题，raft算法具体参考 <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">大神制作的动画</a></p>
</blockquote>
<p>关于脑裂现象的一些推荐资料</p>
<ul>
<li><a href="http://linux-ha.org/wiki/Split_Brain" target="_blank" rel="external">Linuex-ha split-brain</a></li>
<li><a href="http://techthoughts.typepad.com/managing_computers/2007/10/split-brain-quo.html" target="_blank" rel="external">Split-brain, Quorum, and Fencing - updated</a></li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前在使用etcd的时候，只是在官网看到了分布式存储，就默认它为一个存储组件，导致了对etcd的误解，这也是第一次用到的时候没有深入了解导致的，在经过和Zookeeper的比较学习之后，发现两者在很多方面有着相同的特性。以前我对Zookeeper也有一定的误解，以为它是一个协调者，一定有管理的功能，可以控制很多东西，但经过这番学习之后，发现其实Zookeeper本质上也是一个存储单元，用于存放配置信息，解决分布式中的读写一致性问题。总的来说，etcd和Zookeeper有相似的功能，做的事情也大同小异，只是可能具体的应用场景不太一样，我目前的了解是Zookeeper主要用于Hadoop组件的协调上，etcd主要用与Kubernetes上对于容器的协调上，两者都是用于存放配置信息等元数据的，随着以后的深入学习，希望可以慢慢把他们的区别理清晰。</p>
<blockquote>
<p>唉，学习就像解bug，当我知道哪错了的时候，离真相也就不远了 (ಥ_ಥ)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> zookeeper </tag>
            
            <tag> etcd </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[MapReduce1的工作原理]]></title>
      <url>/2017/09/26/mapreduce1/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>《Hadoop权威指南》这本书上关于MapReduce的工作机制进行了详细的介绍，job运行过程每一步的讲解比较清晰，在此进行整理和汇总。</p>
<a id="more"></a>
<h1 id="MapReduce1-简介"><a href="#MapReduce1-简介" class="headerlink" title="MapReduce1 简介"></a>MapReduce1 简介</h1><p>MapReduce1 是Hadoop2.0之前的MapReduce程序调度机制，也就是YARN出现之前的经典调度模型，最顶层包含了4个独立的实体。</p>
<ul>
<li>客户端， 提交MapReduce程序</li>
<li>jobtracker，协调作业的运行。它是一个Java应用程序，主类为JobTracker，扮演的角色是一个协调者的角色，是一个调度中心。负责的工作是作业的分配，tasktracker的监控</li>
<li>tasktracker，运行作业划分后的任务。也是一个Java应用程序，主类为TaskTracker，它是MapReduce程序实际的运行者，受jobtracker的调度和指挥，并向jobtracker报告自己的状态，可以分为maptask、reducetask等</li>
<li>分布式文件系统（一般为HDFS），用于存放共享作业，如作业的jar文件，配置文件，计算所得的输入分片等，不存放计算的中间数据，中间数据存放在task所在节点的磁盘上。</li>
</ul>
<p>下图简单介绍了MapReduce程序的工作流程及上述几个实体扮演的角色</p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-26/78433226.jpg" alt=""></p>
<p>一个job的完整流程包括了作业的提交，作业的初始化，任务的分配，任务的执行，进度和状态的更新，作业的完成六大步骤，下面进行分步介绍。为了方便，下面将job执行的工作原理图放上，并添加标题，方便后面文字说明时进行查找。</p>
<div id="img1" style="font-weight:bold">MapReduce作业的工作原理图</div>

<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-26/37217492.jpg" alt="图1"></p>
<h1 id="作业（job）的提交"><a href="#作业（job）的提交" class="headerlink" title="作业（job）的提交"></a>作业（job）的提交</h1><p>job的提交涉及到的实体是客户端（job client）、JobTracker和分布式文件系统（HDFS）。它的步骤主要是<a href="#img1">工作原理图</a>中的第1-4步。</p>
<ol>
<li>启动job。会创建一个JobSubmmiter对象，之后的作业提交交给它来完成。</li>
<li>向JobTracker请求一个作业ID（调用JobTracker的getNewJobId方法）</li>
<li>在作业信息发给HDFS之前，需要先检查作业的输出、输出路劲是否存在，满足后将作业JAR文件、配置文件和输入分片等复制到一个以作业ID命名的目录下（位于JobTracker的文件系统子目录中）。作业jar有多个副本，默认为10，运行作业是以供tasktracker访问</li>
<li>告知jobtracker准备执行（调用JobTracker的submitJob方法）</li>
</ol>
<p>提交作业后，waitForCompletion()每秒轮询作业的进度，更新进度报告。作业完成后，若成功，则输出作业计数器，否则，报告作业失败信息。</p>
<h1 id="作业的初始化"><a href="#作业的初始化" class="headerlink" title="作业的初始化"></a>作业的初始化</h1><ol>
<li>JobTracker将提交上来的作业进行初始化，创建一个表示作业的对象，用于封装任务和记录信息，以便跟踪任务状态。之后，将他们放入一个内部队列中，交由job scheduler来调度。</li>
<li>job scheduler创建任务运行列表。首先从HDFS中获取客户端计算好的输入分片，为每个分片创建一个map任务。然后根据Job中设置的mapred.reduce.tasks属性n创建相应数量的reduce任务，并指定任务ID。同时创建作业创建和作业清理两个任务，他们在tasktracker中运行，负责map之前的创建作业和reduce之后的作业清理。</li>
</ol>
<h1 id="任务的分配"><a href="#任务的分配" class="headerlink" title="任务的分配"></a>任务的分配</h1><ol>
<li>tasktracker定期发送“心跳信息”给jobtracker，来表示自己的存活和是否准备好运行任务。jobtracker为ready状态的tasktracker分配一个任务（map或reduce）。 任务的分配取决于调度算法，如tasktracker上有固定的map槽和reduce槽（取决于tasktracker的核和内存)，默认调度算法优先占用map槽。但对于map任务，jobtracker会考虑距离输入分片文件最近的tasktracker进行调度，map任务可能有数据本地化（任务运行在输入分片所在的节点上）、机架本地化（运行在所在机架），无本地化三种状态。</li>
</ol>
<h1 id="任务的执行"><a href="#任务的执行" class="headerlink" title="任务的执行"></a>任务的执行</h1><ol>
<li>taskTracker将作业的jar文件从HDFS上复制到本地，然后将应用所需的全部文件从分布式缓存复制到本地磁盘，然后创建一个本地目录，将jar文件内容解压到该目录下。之后tasktracker新建一个TaskRunner对象。</li>
<li>TaskRunner启动一个新的jvm来运行每一个任务，以便用户定义的map和reduce不会影响到tasktracker。</li>
<li>任务在JVM中运行，并定期汇报自己的进度，直到任务完成。</li>
</ol>
<h1 id="进度和状态的更新"><a href="#进度和状态的更新" class="headerlink" title="进度和状态的更新"></a>进度和状态的更新</h1><p>MapReduce程序是一个耗时较长的任务，对于用户来说，需要得知作业的进度。任务在运行时，对于map任务来说，进度是已经处理的输入所占的比例。对于reduce任务来说，系统会估计已处理reduce输入的比例。</p>
<p>MapReduce中改变进度状态的操作为：</p>
<ul>
<li>读入一条输入记录（mapper或reducer）</li>
<li>写入一条输出记录</li>
<li>在一个Reporter中设置状态描述</li>
<li>增加计数器(Reporter)</li>
<li>调用Reporter的progress()任务</li>
</ul>
<p>进度最终会由tasktracker汇总到JobTracker中，JobClient每秒查询JobTracker来获取最新状态，也可以显式调用Job的getStatus方法来获取所有状态信息。</p>
<h1 id="作业的完成"><a href="#作业的完成" class="headerlink" title="作业的完成"></a>作业的完成</h1><p>作业完成后，客户端从waitForCompletion()方法返回，Job的统计信息和计数值也输出到控制台。最后JobTracker清空作业的工作状态，并指示tasktracker也清空作业的工作状态(如删除中间输出)</p>
<h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>第一代的MapReduce虽然已经不在被使用，但对于学习MapReduce程序的流程还是有很大的帮助的，通过整理，了解了一些细微的知识点，相信对于理解YARN也会有很大的帮助。</p>
<blockquote>
<p>Know one thing, Know it well.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> MapReduce1 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ambari 功能简介]]></title>
      <url>/2017/09/25/ambari_info/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在做关于Hadoop集群的可视化部署相关的调研，发现了Ambari这个有趣的东西，在使用的过程中，整理了一部分功能列表，在此分享。</p>
<a id="more"></a>
<h1 id="Ambari简介"><a href="#Ambari简介" class="headerlink" title="Ambari简介"></a>Ambari简介</h1><p>Ambari是Hortonworks开源的Hadoop平台的管理软件，具备Hadoop组件的安装、数据管理等基本功能，提供Web UI进行可视化的集群管理，简化了大数据平台的安装、使用难度。</p>
<h1 id="功能列表"><a href="#功能列表" class="headerlink" title="功能列表"></a>功能列表</h1><p>操作级别：</p>
<ul>
<li>Host Level Action（机器级别的操作）</li>
<li>Component Level Action（模块级别的操作）</li>
</ul>
<p>基于角色的用户管理，角色分为：</p>
<ul>
<li>Cluster User。 查看集群和Service的信息，如配置、service状态、健康状态等。Read-only</li>
<li>Service Operator。 能够操作Service的生命周期，如启动，停止，也可以进行一些如Rebalance DataNode和YARN refresh的操作</li>
<li>Service Administrator。 在Service Operator的基础上增加了配置service，移动NameNode，启用HA等操作</li>
<li>Cluster Operator。 在Service Administrator的基础上增加了对hosts和components的操作，如增加，删除等</li>
<li>Cluster Administrator。集群的超级管理员，拥有无上的权利，可以操作任何组件。</li>
</ul>
<p>Dashboard 监控</p>
<ul>
<li>Roll Start功能。根据Service的依赖关系，按照一定的顺序启动每个Service。比如HBase依赖HDFS和Zookeeper，Ambari会先启动HDFS和Zookeeper，之后启动HBase。如图所示</li>
<li>关键的运维指标（metrics）–metrics 是“度量,指标”的意思</li>
<li>在左侧的 Service 列表,中间部分是 Service 的模块（Component）信息，也就是该 Service 有哪些模块及其数目。右上角有个 Service Action 的按钮，包括service的启动、停止、删除等操作。</li>
<li>Quick links（导向组件原生管理界面）  <ul>
<li>NameNode UI、ResourceManage UI、HBase Master UI</li>
<li><a href="http://unix191:50070/logs/" target="_blank" rel="external">http://unix191:50070/logs/</a>   HDFS的NameNode的logs</li>
<li><a href="http://unix192:8088/logs/" target="_blank" rel="external">http://unix192:8088/logs/</a>    YARN的ResourceManage 的logs</li>
<li><a href="http://unix191:16010/logs/" target="_blank" rel="external">http://unix191:16010/logs/</a>   Hbase的logs<br>Alert介绍</li>
</ul>
</li>
<li>Alert 告警级别 Status：<br>   OK  、Warning、Critical、Unknown、None</li>
<li>Alert 告警类型：<br>   WEB、Port、Metric、Aggregate 和 Script</li>
<li>表 1. Ambari 中的 Alert 类型对比</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>用途</th>
<th>告警级别</th>
<th>阀值是否可配置</th>
<th>单位</th>
</tr>
</thead>
<tbody>
<tr>
<td>PORT</td>
<td>用来监测机器上的一个端口是否可用</td>
<td>OK, WARN, CRIT</td>
<td>是</td>
<td>秒</td>
</tr>
<tr>
<td>METRIC</td>
<td>用来监测 Metric 相关的配置属性</td>
<td>OK, WARN, CRIT</td>
<td>是</td>
<td>变量</td>
</tr>
<tr>
<td>AGGREGATE</td>
<td>用于收集其他某些 Alert 的状态</td>
<td>OK, WARN, CRIT</td>
<td>是</td>
<td>百分比</td>
</tr>
<tr>
<td>WEB</td>
<td>用于监测一个 WEB UI（URL）地址是否可用</td>
<td>OK, WARN, CRIT</td>
<td>否</td>
<td>无</td>
</tr>
<tr>
<td>SCRIPT</td>
<td>Alert 的监测逻辑由一个自定义的 python 脚本执行</td>
<td>OK, CRIT</td>
<td>否</td>
<td>无</td>
</tr>
</tbody>
</table>
<h1 id="Hadoop代表组件功能说明"><a href="#Hadoop代表组件功能说明" class="headerlink" title="Hadoop代表组件功能说明"></a>Hadoop代表组件功能说明</h1><p>1）HDFS</p>
<ul>
<li>启动、停止、重启HDFS，也支持HDFS的删除，前提是删除依赖HDFS的其他service</li>
<li>高级配置<br>支持对core-site.xml、hdfs-site.xml的高级配置</li>
<li>下载配置文件</li>
<li>状态查看<br>NameNode和SNameNode的健康状况以及所在的节点、硬盘使用率、块的状态（丢失、冲突的个数）</li>
<li>文件查看<br>嵌入了HDFS原生的文件目录查看功能，没有一键上传、下载文件的功能</li>
<li>日志查看<br>日志查看可以通过QuickLinks中导向HDFS原生日志查看Web UI界面，没有经过界面的优化，日志查看也没有辅助功能（如检索）</li>
<li>移动NameNode、SNameNode</li>
<li>Rebalancing HDFS<br>使得DataNodes上的块分布均匀</li>
<li>NameNode UI<br>通过QuickLinks导向HDFS原生UI</li>
<li>HA<br>一键配置NameNode的高可用，使用JournalNode、NFS为共享存储</li>
</ul>
<p>2）Zookeeper</p>
<ul>
<li>启动、停止、重启Zookeeper集群</li>
<li>状态查看<br>Zookeeper Server和Client的健康状况，所在的节点</li>
<li>高级配置<br>zoo.cfg、日志输出格式(log4j的配置)</li>
<li>添加Zookeeper Server节点</li>
<li>下载配置文件</li>
</ul>
<p>3）HBase</p>
<ul>
<li>启动HBase集群，启动RegionServer，停止集群，删除HBase集群</li>
<li>添加HBase Master节点</li>
<li>状态查看<br>HBase Master、RegionServers的状态及其所处节点，master启动时间，平均负载（regions/regionsServer）</li>
<li>高级配置<br>HBase Master、RegionServer、Client的内存限制、心跳时间等。可以启用Kerberos（前提是安装该Service），也可以开启Phoenix SQL</li>
<li>日志查看<br>日志查看可以通过QuickLinks中导向原生日志查看Web UI界面</li>
<li>Master UI界面<br>通过QuickLinks导向HDFS原生UI</li>
</ul>
<p>4）Kafka</p>
<ul>
<li>Kafka的启动、停止、重启，Brokers的重启，Service的删除</li>
<li>高级配置<br>对Kafka Broker、Producer、Consumer的配置。Broker支持连接参数设置、Topic配置、日志配置等，</li>
<li>状态查看<br>Broker的状态、所在节点位置，结合Ambari Metrics可以查看更多状态，如Topics、Controller、Replica</li>
</ul>
<h1 id="Ambari使用感想"><a href="#Ambari使用感想" class="headerlink" title="Ambari使用感想"></a>Ambari使用感想</h1><p>Ambari通过HDP将Hadoop的组件进行集成，通过栈的形式提供Service的组合使用，它主要解决的问题如下：</p>
<ul>
<li>简化了部署过程，在HDP栈中支持的Service只需要图形化的安装即可，可以方便的指定master所在的节点，使集群快速运行起来</li>
<li>通过Ambari Metrics实现集群状态的监控，并通过集成Grafana进行数据的展示（CPU、内存、负载等）</li>
<li>Service的高级配置。集群部署之后，可以方便的通过dashboard进行参数的修改（如HDFS的core-site等）</li>
<li>快速链接。Ambari提供快速导向Hadoop组件原生管理界面的链接</li>
<li>节点的扩展。如HBase Master的增加。</li>
<li>可定制的Alert功能。Ambari的报警信息可以自定义，使得用户可以根据自己的需要，设置哪些情况下需要报警，哪些不需要。</li>
<li>增值功能。如HDFS的Rebalance DataNode、NameNode的HA等</li>
<li>Ambari自身的用户管理，基于RBAC赋予用户对Hadoop集群的管理权限。角色分为</li>
</ul>
<p>Ambari并没有对Hadoop组件进行过多的功能集成，如日志分析等，只是提供了安装，配置，启停等功能，尽量保持了跟原生Hadoop组件的隔离性，对于该组件的具体操作，通过Quick Links 直接导向原生的管理界面（如HBase Master UI），它的做法保持了对于Hadoop组件的低侵入性。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 部署 </tag>
            
            <tag> hadoop </tag>
            
            <tag> Ambari </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[（翻译）Pachyderm介绍-建造一个现代的Hadoop]]></title>
      <url>/2017/09/21/pachyderm_desc/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在调研时发现了Pachyderm这个项目，感觉他们做的工作挺有意思的。Pachyderm将Docker和Hadoop联合起来，旨在使得大数据分析的过程更加便捷，众多非Java语言的工具也可以方便的使用到大数据的分析中来，并在HDFS的基础上增加了版本控制，使得数据可以进行增量分析。我在Medium上看到一篇相关介绍，讲的比较详细，原文是英文的，因此翻译下来分享一下，也方便自己之后的查阅。 原文链接 <a href="https://medium.com/pachyderm-data/lets-build-a-modern-hadoop-4fc160f8d74f" target="_blank" rel="external">Let’s Build a modern Hadoop</a></p>
<a id="more"></a>
<h1 id="翻译正文"><a href="#翻译正文" class="headerlink" title="翻译正文"></a>翻译正文</h1><h2 id="让我们建造一个现代的Hadoop"><a href="#让我们建造一个现代的Hadoop" class="headerlink" title="让我们建造一个现代的Hadoop"></a>让我们建造一个现代的Hadoop</h2><blockquote>
<p>我承诺，这不仅仅是另一个Hadoop的激情演说</p>
</blockquote>
<p>如果你做过大数据的相关工作，那么你很可能已经感受到Hadoop带来的烦恼。但我们仍然坚持使用它，因为我们告诉自己：“这就是Hadoop作为基础设施软件必须工作的方式”。然而，在过去的十年内，像NoSQL数据库，分布式部署工具，云计算等工具，都随着量级的由小到大产生了很大的改进。为什么大数据分析软件就要被远远甩在身后？是什么让Redis，Docker和CoreOS看起来那么年轻和酷炫而Hadoop却如此老迈？</p>
<blockquote>
<p>Hadoop是一个不可挽回的分裂的生态  </p>
</blockquote>
<p>现代开源项目信奉Unix的哲理——“做一件事，把它做到极致，并能和其他相关的工具结合使用”。上面提到的每一个项目，从创建伊始，就有一个清晰的创建者，培养着一个健康的生态并给予项目正确的方向和目标。在一个蓬勃的生态中，每个部分都流畅的集成在一起以给开发者提供弹性的可结合的技术栈。</p>
<p>Hadoop从来没有考虑过这些。它像是一匹野马，被释放在一片旷野之上，没有缰绳也没有方向。每一个主要的Hadoop用户都必须自己增加丢失的功能。有一些被回馈给了社区，但很多并没有。Facebook大概是Hadoop世界中最大的使用者。他们六年前(根据文章的时间，推算为2009年)fork出Hadoop并将他们的改进版本闭源。</p>
<p>这不是一个现代开源项目应当工作的方式。我认为是时候创造一个现代的Hadoop了，那也是我们对于Pachyderm的期许。Pachyderm是一个架构在现代工具上的全新的存储和计算引擎。最大的好处就是我们得以使用开源基础设施中令人惊叹的功能，比如Docker和Kubernetes。</p>
<p>这也是为什么我们在数量级上比Hadoop好的原因。Pachyderm只关注数据分析平台而对于其他部分，我们使用强大的成品工具。当Hadoop出来的时候，他们需要自己建造每一个轮子，但我们不需要。文章接下来我们对于现在数据分析技术栈的设计蓝图。Pachyderm现在还很年轻，开源项目需要健康的讨论以不断的提高。请分享你的观点并帮助我们建造<a href="https://github.com/pachyderm/pachyderm" target="_blank" rel="external">Pachyderm</a></p>
<p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-15/28759688.jpg" alt=""></p>
<p><strong>注意：</strong> Hadoop生态已经形成十多年了，因此是很成熟的。Pachyderm要拥有每一个相应的替代品（如Hive，Pig）之后，才能完美使用。上图仅仅比较两者都有的功能，像分布式文件系统，计算框架等。</p>
<h2 id="分布式计算"><a href="#分布式计算" class="headerlink" title="分布式计算"></a>分布式计算</h2><p>在Hadoop中，MapReduce的任务只能是Java的。这对于Java专家来说OK，但不适用与任何人。现在有很多解决方法使用的不是Java，比如Hadoop Streaming。但是通常来说，如果你要广泛的使用Hadoop，那么你最好使用Java或者Scala。</p>
<p>任务管道在分布式计算中经常是一个挑战。当Hadoop MapReduce显示正在运行的Jobs时，它原生不支持任何Job pipeline的标识(DAG).有很多的任务调度工具在解决这个问题上获得了不同程度的成功(比如 <a href="https://github.com/mesos/chronos" target="_blank" rel="external">Chronos</a>, <a href="http://oozie.apache.org/" target="_blank" rel="external">Oozie</a>, <a href="https://github.com/spotify/luigi" target="_blank" rel="external">Luigi</a>, <a href="https://github.com/apache/incubator-airflow" target="_blank" rel="external">Airflow</a>),但最终，公司选择整合第三方工具并自己添加功能。整合自己的代码和外部工具的任务成为一件让人头疼的事情。</p>
<p>Pachyderm Pipelines与此正好相反。在Pachyderm中为了处理数据，你只需要简单的创建一个容器化的应用将其读写到本地文件系统上即可。你可以使用任何你想要的工具因为它是跑在一个容器中的。Pachyderm将会使用一个FUSE存储卷把数据注入到你的容器中，之后自动的复制这个容器，并展示给每个容器不同的数据块。通过这项技术，Pachyderm可以并行的扩展任何你写的代码来处理大量的数据集。再也没有Java和JVM的什么事了，只要使用你最爱的编程语言写数据处理逻辑就可以了。如果你的代码可以跑在Docker上，你就可以使用它来做数据分析。</p>
<p>Pachyderm也会为所有的任务和他们的依赖创建一个DAG。DAG自动的调度pipeline使得每个任务等待他们的依赖完成之后运行。Pachyderm中的每个部分互相通知不同之处，因此它们准确的知道哪些数据改变了以及pipeline中的哪个子集需要重启。</p>
<h2 id="Job执行平台"><a href="#Job执行平台" class="headerlink" title="Job执行平台"></a>Job执行平台</h2><p>将Docker和JVM进行比较是有一点难度的，我们将它们分类为“job platform”，因为他们定义了job的输入格式。</p>
<p>JVM是Hadoop生态的骨干，如果你想要在Hadoop之上建造点什么，你要么需要用Java写要么需要一个特定的工具来将你原来的代码转换过去。Hive是一个HDFS的SQL_like接口，是目前为止最受欢迎且支持度最高的。也有常用的第三方库，比如图像处理，但是他们通常很不标准且不经常维护。如果你尝试做一些复杂的事情，比如说分析象棋比赛，通常你需要结合很多第三方工具，统一使用。</p>
<p>Docker则大不一样，它完全不依赖任何的语言和库。你不用局限于JVM指定的工具，只需要使用那些库并把他们打包进Docker即可。比如，你可以使用<code>npm install opencv</code>来做PB级的计算机视觉任务！工具可以使用任何语言来编写，它非常容易被整合进Pachyderm的技术栈里。</p>
<p>最后，Pachyderm数据分析管道是可插拔和共享的。因为每个部分都是在容器里，它可以保证在不同的集群和数据集上运行一个可预测的环境。就像某人可以从Docker Hub上pull下来镜像，并立即使用在生产环境中，也可以通过镜像创建一个自然语言处理的容器。它的工作不依赖任何基础设施。那就是我们通过Pachyderm pipeline想要做的事。</p>
<h2 id="分布式存储"><a href="#分布式存储" class="headerlink" title="分布式存储"></a>分布式存储</h2><p>HDFS是Hadoop生态中最稳定和鲁棒的一个了。它非常适用于分布式的存储大量的数据集，但是缺乏协作。大规模的数据分析和流水线是一个天然的合作结果，但是HDFS从来不是被设计成用于并发的。相反，它防止用户之间产生任何影响。如果有人改变了管道的输入流，很容易导致一个任务失败或者改变。每个公司使用不同的方式解决这个问题。有时候的方法是单纯的使得每个用户得到数据的一份拷贝，而这需要大量的额外存储空间。</p>
<p>Pachyderm File System（PFS）是一个分布式文件系统，它受git的启发。在一个空间中，Pfs给予你数据的完全版本控制。整个文件系统是基于commit的，这意味着你拥有数据的每一个版本。就像git那样，Pachyderm提供了分支功能，允许每个用户有他自己的完全独立的数据分支。用户可以无所顾忌的使用自己的文件，而不需考虑会影响到其他的用户。</p>
<p>Pfs使用对象存储你的数据(S3, GCS, Ceph)。你不需要担心把数据交给全新的技术是否安全。相反，你得到所有你之前习惯的冗余和一致性保证，但使用的是Pachyderm的数据管理特性。</p>
<p>数据的版本控制也是和管道系统高度协作的。Pachyderm了解你的数据怎样变化，因此，当新的数据进来时，你可以仅仅在变化的那部分数据上运行你的任务，而不需要读取整个文件。这不仅使得集群性能大幅提高，而且使得Pachyderm的批处理和流处理没有任何区别，相同的代码可以支持两种操作。</p>
<h2 id="集群管理"><a href="#集群管理" class="headerlink" title="集群管理"></a>集群管理</h2><p>集群管理层帮助你管理存储数据和执行任务的机器。</p>
<p>在Hadoop中，两个主要的工具是YARN和Zookeeper。YARN用于任务调度和资源管理，Zookeeper则提供了配置信息的强一致性。在Hadoop概念中，没有太好的其他工具解决这些问题，所以Hadoop是强烈依赖YARN和Zookeeper的。这两个工具早期促成了Hadoop的成功，但现在却成为了新特性的重要障碍。模块化的缺失，毫无疑问是Hadoop最大的缺点。</p>
<p>Pachyderm遵循了Docker的哲学——“包含电池，但可以移除”。我们聚焦于把大数据分析做到最好，其他的部分全部使用现成的组件。我们选择Kubernetes用于集群管理，选择Docker用于容器化，但他们都可以使用其他的组件替换。</p>
<p>在Pachyderm技术栈中，集群管理使用Kubernetes和CoreOS的工具etcd。他们的功能是类似于YARN和Zookeeper的。Kubernetes是一个调度者，根据资源的可用性来调度服务。Etcd是一个容错的分布式数据库用于存放配置信息并在网络分裂后进行节点的管理。如果一个节点挂掉了，Etcd注册这个信息并使得Kubernetes重新手机节点的进程。其他的集群管理工具如Mesos，可以用于替代CoreOS和Kubernetes，但没有被正式的支持。</p>
<p>使用现成的工具有两大好处。第一，它节省了我们“重复造轮子”的时间并且给了我们很好的抽象和剥离。第二，Etcd和Kubernetes本身就是模块化的，因此它们也支持其他的部署方案。</p>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>两个技术栈都是运行在Linux之上的。</p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>可扩展，分布式是数据分析软件的重要基本特性。现代的Web公司收集持续不断的数据用于制定面向数据的决策。世界需要一个现代的开源软件，Hadoop的过时已经成为数据驱动时代的负担，是时候让我们的数据分析工具来拥抱未来了。</p>
<h2 id="我的感想"><a href="#我的感想" class="headerlink" title="我的感想"></a>我的感想</h2><p>通读下来后，原作者对于Hadoop的一些弊端的论述我是很难理解的（<em>我就觉得Zookeeper挺优秀的啊，为什么要换~~~</em>），毕竟我的水平太低<code>o(╥﹏╥)o</code>，但作者的一些观点还是很新颖的，比如借鉴Git来改进文件系统，使用数据的增量进行数据分析等。Docker和Hadoop都是很牛的项目，期待他们的碰撞会迸发怎样的火花 <code>^_^</code></p>
<blockquote>
<p>翻译不易，转载请注明出处 Thanks♪(･ω･)ﾉ</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> hadoop </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hadoop </tag>
            
            <tag> docker </tag>
            
            <tag> pachyderm </tag>
            
            <tag> 翻译 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2n+1个数中，n个数出现两次，找出只出现一次的数]]></title>
      <url>/2017/09/17/weiyu/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>算法题目中很多经典的题型使用到的是二进制的位运算，对于与、或、非、异或等都有一些经典的题，下面介绍一道关于异或的经典题和它的相关变形。</p>
<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>在一个长度为2n+1的数组中，n个数出现两次，只有一个数出现一次，找出这个只出现一次的数x.</p>
<a id="more"></a>
<p>示例：<br>假设输入的为 [1, 2, 3, 4, 3, 2, 1]，其中1，2，3都出现了两次，只有4出现一次，因此算法输出为4.</p>
<h2 id="基本解法"><a href="#基本解法" class="headerlink" title="基本解法"></a>基本解法</h2><p>最容易想到的解法便是对数组进行两层循环遍历，这种算法的平均时间复杂度为<code>$O(n^2)$</code>  </p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</div><div class="line">            System.out.print(a[i] + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"\nres: "</span>+findNumber(a, a.length));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNumber</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">        <span class="keyword">boolean</span> flag;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</div><div class="line">            x = a[i];</div><div class="line">            flag = <span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;n; j++) &#123;</div><div class="line">                <span class="keyword">if</span>(a[j] == x &amp;&amp; j != i)</div><div class="line">                    flag = <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(flag)</div><div class="line">                <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<blockquote>
<p>1 2 3 4 3 2 1 5 5<br>res: 4</p>
</blockquote>
<h2 id="位异或解法"><a href="#位异或解法" class="headerlink" title="位异或解法"></a>位异或解法</h2><p>位异或的解法使用到的思想主要有两个</p>
<ol>
<li>相同的两个数异或结果为0， 如 3 ^ 3 = 0</li>
<li>异或满足交换律，也就是 A ^ B ^ C ^ A = A ^ A ^ B ^ C = B ^ C</li>
</ol>
<p>算法： 将数组依次进行疑惑，其结果就是只出现了一次的数x</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</div><div class="line">            System.out.print(a[i] + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"\nres: "</span>+findNumber(a, a.length));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNumber</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">            x ^= a[i];</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为：</p>
<blockquote>
<p>1 2 3 4 3 2 1 5 5<br>res: 4</p>
</blockquote>
<h1 id="题目变形1"><a href="#题目变形1" class="headerlink" title="题目变形1"></a>题目变形1</h1><p>在一个长度为2n+2的数组中，n个数出现两次，有两个数出现一次，找出这两个只出现一次的数x， y.</p>
<h2 id="算法的解决思想"><a href="#算法的解决思想" class="headerlink" title="算法的解决思想"></a>算法的解决思想</h2><ol>
<li>仍然使用位异或的算法，将数组依次进行异或操作，得到 res = x ^ y</li>
<li>找到res从低位数第一个出现1的位置i，得到 <code>$pivot = 2^i$</code>(2的i次方).<br>如 res = 1001000(2进制数)， 则 pivot = 1000(2进制)= 8 = <code>$2^3$</code><ul>
<li>解释： 因为第一个出现1的位置相当于说是 x 和 y 第一个不同的位置，也就是x和y在该位置要么x为0，y为1；要么x为1，y为零。从第i位往下数，x和y的值相同</li>
</ul>
</li>
<li>将数组每个数字a[i]和 pivot进行与运算，如果为零， 则 res_1 ^= a[i];<br>否则， res_2 ^= a[i]， 则  res_1 为 x, res_2 为 y.   <ul>
<li>解释： 将 a[i] &amp; pivot 本质上将数组中的数分为了两类：一类结果为0，一类结果为1。而x,y必定被分在两个不同的类中，因为x,y在第i位不同，且<code>$pivot=2^i$</code>,也就是说pivot除第i位外，其余位均为0，因此x,y和pivot的与必定一个为0，一个为1。最终res_1 = a[i] ^ x; res_2 = a[i] ^ y; a[i]中相同的两个数异或后相互抵消，所以 res_1 = x; res_2 = y;</li>
</ul>
</li>
</ol>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main1</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">20</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</div><div class="line">            System.out.print(a[i] + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.print(<span class="string">"\nres: "</span>);</div><div class="line">        <span class="keyword">int</span>[] res = findTwoNumber(a, a.length);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;res.length; i++)</div><div class="line">            System.out.print(res[i]+<span class="string">" "</span>);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] findTwoNumber(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n) &#123;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">            res ^= a[i];</div><div class="line"></div><div class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">        <span class="keyword">while</span> ((res &amp; <span class="number">1</span>) ==<span class="number">0</span>) &#123;</div><div class="line">            res = res &gt;&gt; <span class="number">1</span>;   </div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">int</span> pivot = <span class="number">1</span> &lt;&lt; index;</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</div><div class="line">            <span class="keyword">if</span>((a[i] &amp; pivot) == <span class="number">0</span>)</div><div class="line">                arr[<span class="number">0</span>] ^= a[i];</div><div class="line">            <span class="keyword">else</span></div><div class="line">                arr[<span class="number">1</span>] ^= a[i];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> arr;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为:</p>
<blockquote>
<p>1 2 3 4 3 2 1 5 5 20<br>res: 4 20</p>
</blockquote>
<h1 id="题目变形2"><a href="#题目变形2" class="headerlink" title="题目变形2"></a>题目变形2</h1><p>在一个长度为3n+1的数组中，n个数出现3次，只有一个数出现一次，找出这个只出现一次的数x.</p>
<h2 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h2><p>如果数组中没有x，那么数组中所有的数字都出现了3次，在二进制上，每位上1的个数肯定也能被3整除。如{1, 5, 1, 5, 1, 5}从二进制上看有：</p>
<p>1：0001</p>
<p>5：0101</p>
<p>1：0001</p>
<p>5：0101</p>
<p>1：0001</p>
<p>5：0101</p>
<p>二进制第0位上有6个1，第2位上有3个1.第1位和第3位上都是0个1，每一位上的统计结果都可以被3整除。而再对该数组添加任何一个数，如果这个数在二进制的某位上为1都将导致该位上1的个数不能被3整除。因此通过统计二进制上每位1的个数就可以推断出x在该位置上是0还是1了，这样就能计算出x了。</p>
<p>推广一下，所有其他数字出现m（m&gt;=2）次，而一个数字出现1次都可以用这种解法来推导出这个出现1次的数字。</p>
<p>代码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main2</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">10</span>&#125;;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;a.length; i++) &#123;</div><div class="line">            System.out.print(a[i] + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"\nres: "</span>+findNumber(a, a.length));</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findNumber</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span> bits[] = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">32</span>];</div><div class="line">        Arrays.fill(bits,<span class="number">0</span>);</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;n; i++)</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</div><div class="line">                bits[j] += ((a[i] &gt;&gt; j) &amp; <span class="number">1</span>);</div><div class="line">            &#125;</div><div class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;<span class="number">32</span>; j++)</div><div class="line">            <span class="keyword">if</span>(bits[j] % <span class="number">3</span> != <span class="number">0</span>)</div><div class="line">                res += (<span class="number">1</span> &lt;&lt; j);</div><div class="line">        <span class="keyword">return</span> res;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出为:</p>
<blockquote>
<p>1 2 2 1 3 3 4 5 3 2 1 5 5 4 4 10<br>res: 10</p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>无论是2n+1，还是3n+1，其实都是所有其他数字出现m次，而一个数出现1次。这种情况之下，都可以使用3n+1 的算法的核心思想，也就是统计每个二进制位上的1的个数，然后对2求余或者对3求余（<em>异或其实就是一种对2求余的快捷方式</em>）。只要掌握了这种核心思想，不管是几n+1， 都可以在 O(n)的时间复杂度中求出。</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法 </tag>
            
            <tag> 位与 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashSet的存储机制]]></title>
      <url>/2017/09/15/hash_set(java)/</url>
      <content type="html"><![CDATA[<p>Java中Set接口下的HashSet类是一个存储不可重复数据的集合，可是我们在用的时候往往发现，明明看似重复的数据，HashSet仍然存储了进去，这不免让我们感到疑惑，不是说存储不可重复的数据的吗？下面通过实验一步一步搞懂HashSet的存储机制。<br><a id="more"></a></p>
<ol>
<li>假设有以下类  </li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">  String  stuName;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String s)</span></span>&#123;</div><div class="line">    <span class="keyword">this</span>.stuName = s;</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getStu</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stuName;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在test类中主函数中写入如下代码</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Set&lt;Student&gt;  testSet = <span class="keyword">new</span> HashSet&lt;Student&gt;();</div><div class="line">Student s1 = <span class="keyword">new</span> Student(<span class="string">"stu1"</span>);</div><div class="line">Student s2 =<span class="keyword">new</span> Student(<span class="string">"stu1"</span>);</div><div class="line">Student s3 =<span class="keyword">new</span> Student(<span class="string">"stu2"</span>);</div><div class="line">testSet.add(s1);</div><div class="line">testSet.add(s2);</div><div class="line">testSet.add(s3);</div><div class="line">Iterator&lt;Student&gt; it = testSet.iterator();</div><div class="line"><span class="keyword">while</span>(it.hasNext())&#123;</div><div class="line">     Student tempStu =it.next();</div><div class="line">     System.out.println(tempStu.getStu());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Eclipse中的输出为  stu1,stu1,stu2</p>
<p>大家会说，当然了，因为Student类没有比较嘛，下面我们在Student类中重写Object的equals方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">  <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">  Student s =(Student)obj;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.stuName.equals(s.getStu());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>仍然是输出三个结果，通过观察Object类的方法，我们发现一个hashCode()方法，HashSet会不会跟这个方法有点关系呢？下面重写这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// TODO Auto-generated method stub</span></div><div class="line">  <span class="keyword">if</span>(stuName==<span class="string">"stu1"</span>)</div><div class="line">    <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.hashCode();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Eclipse的输出为stu1 ,stu2</p>
<p>通过给stuName为stu1的Student对象的hashCode赋值为相同的1，我们得到的输出是一个stu1，满足了存储不可重复的目的。下面我们做个有趣的事情。将上面重写的equals方法改为如下代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">    <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line"><span class="comment">// TODO Auto-generated method stub</span></div><div class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出  stu1,stu2,stu1</p>
<p>通过给equals方法重写，使其始终返回false，导致即使两个stu1的hashCode相同，仍然可以插入，至此，我们明白了HashSet的存储机制。<br>HashSet在存一个新的对象的时候，先比较其跟已有的对象中的hashCode是否有相同的，如果没有相同的，则直接添加，不会调用equals方法进行判断，所以导致即使我们重写了equals方法也无法避免重复值的插入，只有当有两个hashCode相同的时候，它才会调用equals方法进行比较，如果返回的是true，则不添加，如果返回false，则添加进集合，所以在最后我们给定stu1的hashCode为1的时候，因为equals始终返回false，所有两个stu1均存到了集合中。</p>
<p>至此，我们搞清楚了HashSet的存储机制，但对于hashCode方法的重写，又会使得我们头疼了，如何使属性相同的hashCode不同呢？好在有Eclipse帮助我们，只要在Student类中右击-&gt;source-&gt;重写hashCode方法和equals方法,在弹出的窗口中选择相关属性即可，作为小白的我，不得不感叹Eclipse的伟大之处</p>
]]></content>
      
        <categories>
            
            <category> Java </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> HashSet </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我的第一篇博客]]></title>
      <url>/2017/09/14/hello-world/</url>
      <content type="html"><![CDATA[<p>很早之前就在github上申请了github pages，想着搭建一个属于自己的博客，但因为人懒，很多笔记都记在了有道云笔记上，没有整理成博客的好习惯。用有道云笔记虽然也可以起到一定的总结作用，但是毕竟只是给自己看的，所以并没有很用心，<br>所以写成的东西也只是用到的时候，自己再翻出了笔记回忆一下，没有起到温故知新的作用。<br><a id="more"></a></p>
<p>最近看到一个学长的博客，感触良多，觉得养成一个总结知识，整理成博客的好习惯是多么的重要，一方面是对自己学习的督促，另一方面，也是与他人学习交流的好途径，因此，得空用hexo搭建了这个博客。因为是穷学生，用不起长期的电脑，就用很早之前的github pages托管了，而且我要整理的内容也不多，这个方案完全可以满足我的需求。</p>
<p>有了平台之后，接下来就是好习惯的培养了。近期的计划是先将之前的一些笔记整理上来，之后再陆续把学习生活中的心得记录到此，希望自己可以养成一个好习惯吧。 (*￣︶￣)</p>
]]></content>
      
        <categories>
            
            <category> 随想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 随想 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用httpd搭建内网yum源]]></title>
      <url>/2017/09/14/private_yum/</url>
      <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在使用CentOS时，由于众所周知的原因，在安装软件时总是会因为超市而导致安装失败的问题，尤其是在安装文件偏大的软件时，这种现象发生的异常频繁，常见的解决方法是：</p>
<ul>
<li>将Base Repo配置成阿里的yum源<blockquote>
<p>具体方法参看 <a href="https://mirrors.aliyun.com/help/centos" target="_blank" rel="external">Ali-OSM</a>进行配置</p>
</blockquote>
</li>
<li>搭建梯子，科学上网</li>
</ul>
<p>阿里的yum源虽然解决了大部分软件的安装问题，但它毕竟没有包罗万象，总是有一些软件是阿里源中没有的（如ambari); 而搭建梯子对于安装动辄上百兆的软件来说可以说是杯水车薪。因此，我们有必要搭建内网的yum源，方便软件的下载与版本的统一。这篇文章是我在使用Ambari的时候，由于安装hadoop集群时多个组件出现网络超时问题，搭建了一个内网hdp的yum源。</p>
<a id="more"></a>
<h1 id="搭建准备"><a href="#搭建准备" class="headerlink" title="搭建准备"></a>搭建准备</h1><p>内网yum源的实质是在内网环境中，选择一台电脑搭建一个服务器，将下载好的压缩包解压到服务器的目录下，作为静态资源以供内网中的电脑进行访问。<br>本次搭建使用了三台虚拟机中的一台进行搭建。使用httpd作为服务器。</p>
<h1 id="使用httpd搭建静态资源服务器"><a href="#使用httpd搭建静态资源服务器" class="headerlink" title="使用httpd搭建静态资源服务器"></a>使用httpd搭建静态资源服务器</h1><ol>
<li><p>安装httpd  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum install -y httpd</div></pre></td></tr></table></figure>
</li>
<li><p>配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ whereis httpd</div><div class="line">httpd: /usr/sbin/httpd /usr/lib64/httpd /etc/httpd /usr/share/httpd /usr/share/man/man8/httpd.8.gz</div><div class="line">$ vi /etc/httpd/conf/httpd.conf</div><div class="line"># port</div><div class="line">Listen 8081</div></pre></td></tr></table></figure>
</li>
<li><p>启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ apachectl start</div></pre></td></tr></table></figure>
</li>
<li><p>验证是否启动成功<br>在浏览器中输入 <code>http://{IP}:8081</code>，查看是否可以访问<br><img src="http://ow9czedj7.bkt.clouddn.com/17-9-14/7223940.jpg" alt="image"><br>由上图所示，httpd服务器搭建完成，它的存放目录在<code>/var/www/html/</code>下</p>
</li>
</ol>
<h1 id="准备源包"><a href="#准备源包" class="headerlink" title="准备源包"></a>准备源包</h1><ol>
<li><p>下载Ambari源包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.4.2.0/ambari-2.4.2.0-centos7.tar.gz</div></pre></td></tr></table></figure>
</li>
<li><p>创建ambari目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cd /var/www/html/ &amp;&amp; mkdir ambari</div></pre></td></tr></table></figure>
</li>
<li><p>将源包解压到ambari目录下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ tar zxvf ambari-2.4.2.0-centos7.tar.gz -C /var/www/html/ambari/AMBARI-2.4.2.0</div></pre></td></tr></table></figure>
</li>
<li><p>验证<br>浏览器访问<code>http://{IP}:8081/ambari</code>,可以看到AMBARI-2.4.2.0目录<br><img src="http://ow9czedj7.bkt.clouddn.com/17-9-14/46506246.jpg" alt="image"></p>
</li>
</ol>
<h1 id="配置repo文件"><a href="#配置repo文件" class="headerlink" title="配置repo文件"></a>配置repo文件</h1><ol>
<li><p>下载repo文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ wget http://public-repo-1.hortonworks.com/ambari/centos7/2.x/updates/2.4.2.0/ambari.repo</div></pre></td></tr></table></figure>
</li>
<li><p>配置Ambari本地源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ cp ambari.repo /etc/yum.repos.d/</div></pre></td></tr></table></figure>
</li>
<li><p>修改repo文件，使其访问内网yum源</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$ cat /etc/yum.repos.d/ambari.repo</div><div class="line">#VERSION_NUMBER=2.1.1-236</div><div class="line"></div><div class="line">[Updates-ambari-2.1.1]</div><div class="line">name=ambari-2.1.1 - Updates</div><div class="line">baseurl=http://&#123;IP&#125;:8081/ambari/AMBARI-2.4.2.0/AMBARI-2.4.2.0/centos7/2.4.2.0-136/</div><div class="line">gpgcheck=1</div><div class="line">gpgkey=http://&#123;IP&#125;:8081/ambari/AMBARI-2.4.2.0/AMBARI-2.4.2.0/centos7/2.4.2.0-136/RPM-GPG-KEY/RPM-GPG-KEY-Jenkins</div><div class="line">enabled=1</div><div class="line">priority=1</div></pre></td></tr></table></figure>
<ul>
<li><strong>注意：</strong> baseurl和gpgkey的路径必须可以访问</li>
</ul>
</li>
<li>生成缓存<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ yum makecache</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果没有任何报错的话，说明内网yum源配置成功，可以开心的安装ambari了，速度溜溜的。</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 内网yum源 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Green Blue Deployment]]></title>
      <url>/2017/09/14/greenBlueDeploy/</url>
      <content type="html"><![CDATA[<p>自动部署中的一种技术，通过保持一个Blue版本的Deployment，来确保Green版的发布失败后可以进行回滚，类似于建立快照，在Caas（Container as a service）中，通过健康检查（http/tcp)确保每个节点都正常部署到了Green状态，如果发生了异常，则所有节点回滚到Blue状态，主要是因为微服务架构下，service通常会进行冗余部署，以达到高可用性（一个节点挂了，有stand-by node），因此版本更新时，通常是要保证所有节点正常部署的。<br><a id="more"></a></p>
<p>原理：<br><img src="http://ow9czedj7.bkt.clouddn.com/17-9-14/82455068.jpg" alt="Green-Blue-Deployment"></p>
<p>如图，为了保证服务的downtime最小化，通常建立一个单独的Green版本进行测试，当全部测试通过后，将路由转移到Green版本中，此时Blue版本的空闲了出来。<br> 优势：<br>1）发生故障后，可以快速回滚，仅仅通过将路由转移到Blue版本即可，<br>此时可能会有丢失Transaction的问题，一种方法是，当Green版本工作时，也会将Transaction同步给Blue版本，以保证一个backup； 另一种方法是，当部署没有完全cut-over的时候，让application处于read-only的状态，此时不会有transaction，当完成后，置于read-write状态<br>2）永远都有一个standby在工作，当发生灾难时，可以快速恢复<br>两个环境必须尽可能的独立</p>
]]></content>
      
        <categories>
            
            <category> 运维 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> 部署 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
