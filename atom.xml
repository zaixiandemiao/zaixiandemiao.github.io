<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>记忆碎片</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wangjialong.cc/"/>
  <updated>2018-04-09T08:46:21.443Z</updated>
  <id>http://www.wangjialong.cc/</id>
  
  <author>
    <name>zaixiandemiao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AQS（AbstractQueuedSynchronizer）源码解析</title>
    <link href="http://www.wangjialong.cc/2018/04/06/aqs_info/"/>
    <id>http://www.wangjialong.cc/2018/04/06/aqs_info/</id>
    <published>2018-04-05T16:00:00.000Z</published>
    <updated>2018-04-09T08:46:21.443Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>java.util.concurrent包（之后简称JUC包）中，提供了大量的同步与并发的工具类，是多线程编程的“利器”。其中locks包下，包含了多种锁，如ReentrantLock独占锁、ReentrantReadWriteLock读写锁、Semaphore信号量（共享锁）等，而这些锁有一个共同的基础类：AbstractQueuedSynchronizer。</p><a id="more"></a><h1 id="AQS简介"><a href="#AQS简介" class="headerlink" title="AQS简介"></a>AQS简介</h1><p>AQS是一个抽象类，不可以被实例化，它的设计之初就是为了让子类通过继承来实现多样的功能的。它内部提供了一个FIFO的等待队列，用于多个线程等待一个事件（锁）。它有一个重要的状态标志——state，该属性是一个int值，表示对象的当前状态（如0表示lock，1表示unlock）。AQS提供了三个protected final的方法来改变state的值，分别是：getState、setState(int)、compareAndSetState(int, int)。根据修饰符，它们是不可以被子类重写的，但可以在子类中进行调用，这也就意味着子类可以根据自己的逻辑来决定如何使用state值。</p><blockquote><p>java的修饰符作用域如下：</p><table><thead><tr><th>/</th><th>同一类中</th><th>同一包中</th><th>同包内的子类</th><th>不同包内的子类</th><th>全局</th></tr></thead><tbody><tr><td>public</td><td>+</td><td>+</td><td>+</td><td>+</td><td>+</td></tr><tr><td>protected</td><td>+</td><td>+</td><td>+</td><td>+</td><td></td></tr><tr><td>default（无修饰符）</td><td>+</td><td>+</td><td>+</td><td></td><td></td></tr><tr><td>private</td><td>+</td><td></td><td></td><td></td><td></td></tr></tbody></table><p>表中 + 表示可以访问， 空白表示无法访问</p></blockquote><p>AQS的子类应当被定义为内部类，作为内部的helper对象。事实上，这也是juc种锁的做法，如ReentrantLock，便是通过内部的Sync对象来继承AQS的。AQS中定义了一些未实现的方法（抛出UnsupportedOperationException异常）</p><ul><li>tryAcquire(int)       尝试获取state</li><li>tryRelease(int)       尝试释放state</li><li>tryAcquireShared(int) 共享的方式尝试获取</li><li>tryReleaseShared(int) 共享的方式尝试释放</li><li>isHeldExclusively()   判断当前是否为独占锁  </li></ul><p>这些方法是子类需要实现的，可以选择实现其中的一部分。根据实现方式的不同，可以分为两种：独占锁和共享锁。其中JUC中锁的分类为:</p><ul><li>独占锁：ReentrantLock、ReentrantReadWriteLock.WriteLock</li><li>共享锁：ReentrantReadWriteLock.ReadLock、CountDownLatch、CyclicBarrier、Semaphore</li></ul><p>其实现方式为：</p><ul><li>独占锁实现的是tryAcquire(int)、tryRelease(int)</li><li>共享锁实现的是tryAcquireShared(int)、tryReleaseShared(int)</li></ul><p>如独占锁的实现方式是：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Acquire:</div><div class="line">     <span class="keyword">while</span> (!tryAcquire(arg)) &#123;</div><div class="line">        <span class="comment">//将当前线程加入FIFO队列中;</span></div><div class="line">        <span class="comment">//自旋或阻塞当前线程;</span></div><div class="line">     &#125;</div><div class="line"></div><div class="line">Release:</div><div class="line">     <span class="keyword">if</span> (tryRelease(arg))</div><div class="line">        <span class="comment">//唤醒队列中的第一个线程(head);</span></div></pre></td></tr></table></figure></p><p>AQS中还提供了一个内部类ConditionObject，它实现了Condition接口，可以用于await/signal。采用CLH队列的算法，唤醒当前线程的下一个节点对应的线程，而signalAll唤醒所有线程。</p><p>总的来说，AQS提供了三个功能：</p><ol><li>实现独占锁</li><li>实现共享锁</li><li>实现Condition模型</li></ol><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Node解析"><a href="#Node解析" class="headerlink" title="Node解析"></a>Node解析</h2><p>AQS内部定义了一个static final的内部类Node，用于实现等待队列CLH，满足FIFO结构，其队列结构如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">     +------+  prev +-----+       +-----+</div><div class="line">head |      | &lt;---- |     | &lt;---- |     |  tail</div><div class="line">     |      | ----&gt; |     | ----&gt; |     |</div><div class="line">     +------+  next +-----+       +-----+</div></pre></td></tr></table></figure><p>队列为一个双向链表结构，保存了head、tail两个指针，分别指向链表头部、尾部。当需要添加节点时，直接在tail位置添加，而dequeue操作直接对head节点进行。Node中定义如下常量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Marker to indicate a node is waiting in shared mode */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</div><div class="line"></div><div class="line"><span class="comment">/** Marker to indicate a node is waiting in exclusive mode */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="comment">/** waitStatus value to indicate thread has cancelled */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED =  <span class="number">1</span>;</div><div class="line"><span class="comment">/** waitStatus value to indicate successor's thread needs unparking */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL    = -<span class="number">1</span>;</div><div class="line"><span class="comment">/** waitStatus value to indicate thread is waiting on condition */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">* waitStatus value to indicate the next acquireShared should</span></div><div class="line"><span class="comment">* unconditionally propagate</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</div></pre></td></tr></table></figure></p><p>以上常量分别用于设置如下属性的值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</div><div class="line"><span class="keyword">volatile</span> Node prev;</div><div class="line"><span class="keyword">volatile</span> Node next;</div><div class="line"><span class="keyword">volatile</span> Thread thread;</div><div class="line">Node nextWaiter;</div></pre></td></tr></table></figure></p><p>Node类型的常量SHARED、EXCLUSIVE用于设置nextWaiter，用于表示当前节点是共享的，还是互斥的，分别用于共享锁和独占锁。int类型的常量CANCELLED、SIGNAL、CONDITION、PROPAGATE用于设置waitStatus，用于在ConditionObject中使用，可以实现await/signal模型。</p><p>Node有三个构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不存放任何线程，用于生成哨兵节点</span></div><div class="line">Node() ;</div><div class="line"><span class="comment">//用于锁</span></div><div class="line">Node(Thread thread, Node mode) ;</div><div class="line"><span class="comment">//用于Condition</span></div><div class="line">Node(Thread thread, <span class="keyword">int</span> waitStatus) ;</div></pre></td></tr></table></figure></p><h2 id="AQS属性"><a href="#AQS属性" class="headerlink" title="AQS属性"></a>AQS属性</h2><p>AQS使用内部类Node，构造一个双向链表，用作FIFO队列；除此之外，AQS还存放一个int类型的属性state，用于表示当前的同步状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//链表头节点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</div><div class="line"><span class="comment">//链表尾节点</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</div><div class="line"><span class="comment">//同步状态</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div></pre></td></tr></table></figure><p>head节点是一个哨兵节点，不存放实际的“线程”节点（使用Node的无参构造函数）。tail指向链表的最后一个节点，当新增节点时，将新节点作为当前tail的下一个节点，通过CAS设置成功后,将新节点设为新的tail节点即可。新增节点的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (;;) &#123; <span class="comment">//死循环</span></div><div class="line">        Node t = tail;</div><div class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 空链表，head、tail都为空</span></div><div class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</div><div class="line">                tail = head;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            node.prev = t;</div><div class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</div><div class="line">                t.next = node;</div><div class="line">                <span class="keyword">return</span> t;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>enq操作是一个无限循环的操作，最终总会成功，但根据代码可知，AQS应不是starvation free的，因为某个线程可能会持续的enq失败。AQS提供了形如doAcquireNanos方法，但其超时返回false操作是在addWaiter方法(内部调用enq)之后，也无法回避enq的starvation。在此顺便说一下，AQS也是无法保证fair的，也就是说先入队列的线程不一定先获取到锁。节点的CAS是通过Unsafe来实现的，在state中统一说明。</p><p>state表示AQS当前的同步状态，如0表示lock，1表示unlock状态。对state的操作，提供了三个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//读取当前state</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> state;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//直接写入，不考虑当前值</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</div><div class="line">    state = newState;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//保证读-写的原子性</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</div><div class="line">    <span class="comment">// See below for intrinsics setup to support this</span></div><div class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到compareAndSetState使用的是unsafe对象的compareAndSwapInt方法，传入this指针，state属性的偏移地址，期待值expect，更新值update，可以实现CAS操作。state属性的偏移地址获取方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> stateOffset;</div><div class="line"><span class="keyword">static</span> &#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        stateOffset = unsafe.objectFieldOffset</div><div class="line">                        (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="string">"state"</span>));</div><div class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>实际上，AQS的head、tail节点，内部类Node的waitStatus、next属性均使用unsafe对象，通过偏移地址来进行CAS操作。Unsafe是sun.misc包下的类，在Java API中没有官方文档，因为它是用于实现Java库的，Java中有一个功能类似的类，可以实现对象属性的CAS操作，可以参考我的另一篇博客<a href="http://www.wangjialong.cc/2018/01/18/atomicXFieldHelper/">AtomicXFieldUpdater，属性原子修改的外部工具类</a>，关于Unsafe的使用，可以参考<a href="http://www.baeldung.com/java-unsafe" target="_blank" rel="external">Guide to Unsafe</a>。</p><p>AQS还有一个属性<code>static final long spinForTimeoutThreshold = 1000L;</code>，用于表示自旋的时间，小于1000纳秒的采用自旋锁，大于1000纳秒，使用LockSupport.park方法，将线程挂起。</p><h2 id="重要方法分析"><a href="#重要方法分析" class="headerlink" title="重要方法分析"></a>重要方法分析</h2><p>AQS是用于实现独占锁或共享锁的，对于一个锁来说，最重要的就是lock和unlock操作了，对应到AQS中，为acquire、release方法，由于AQS需要和子类进行“<strong>合作</strong>”，因此需要子类的定义来进行联合分析，为简单起见，使用AQS官方文档中的示例，定义独占锁如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">   <span class="comment">// Our internal helper class</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</div><div class="line">     <span class="comment">// Reports whether in locked state</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</div><div class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Acquires the lock if state is zero</span></div><div class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">         setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Releases the lock by setting state to zero</span></div><div class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">       setState(<span class="number">0</span>);</div><div class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Provides a Condition</span></div><div class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</div><div class="line"></div><div class="line">     <span class="comment">// Deserializes properly</span></div><div class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></div><div class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">       s.defaultReadObject();</div><div class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></div><div class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</div><div class="line"></div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</div><div class="line">   &#125;</div><div class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>可以看到，lock方法调用内部类的acquire方法，也就是AQS的acquire方法。unlock方法调用release方法。<br>下面对两个流程进行分析</p><h3 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h3><p>acquire是独占锁的获取锁的方法，其源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</div><div class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</div><div class="line">        selfInterrupt();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>acquire方法非常简单，如果tryAcquire失败（返回false），则调用acquireQueued方法，将当前线程加入到等待队列中，并中断当前线程，等待唤醒。</p><p>tryAcquire由子类实现，下面先分析acquireQueued方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">final</span> Node p = node.predecessor();</div><div class="line">            <span class="comment">//若当前节点为链表第一个节点</span></div><div class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</div><div class="line">                setHead(node);</div><div class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></div><div class="line">                failed = <span class="keyword">false</span>;</div><div class="line">                <span class="keyword">return</span> interrupted;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//park当前线程</span></div><div class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</div><div class="line">                parkAndCheckInterrupt())</div><div class="line">                interrupted = <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="keyword">if</span> (failed)</div><div class="line">            cancelAcquire(node);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>acquireQueued在addWaiter之后，再次尝试获取锁，与tryAcquire不同的是，返回值代表的是当前线程在等待时是否可中断，通过返回interrupted，true表示可中断，false表示不可中断。通过判断当前节点是否为队列第一个节点，来决定是否获取成功，acquireQueued方法相当于提供了一个默认方法，会被子类的tryAcquire方法屏蔽掉（若tryAcquire返回true的话）。acquireQueued使用了死循环来判断当前节点前一节点是否为head，是，则获取到锁。但这个方法真的是死循环吗？其实不是的，trick就在shouldParkAfterFailedAcquire方法中，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * This node has already set status asking a release</span></div><div class="line"><span class="comment">         * to signal it, so it can safely park.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * Predecessor was cancelled. Skip over predecessors and</span></div><div class="line"><span class="comment">         * indicate retry.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            node.prev = pred = pred.prev;</div><div class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</div><div class="line">        pred.next = node;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line"><span class="comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></div><div class="line"><span class="comment">         * need a signal, but don't park yet.  Caller will need to</span></div><div class="line"><span class="comment">         * retry to make sure it cannot acquire before parking.</span></div><div class="line"><span class="comment">         */</span></div><div class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由于在锁的使用情景内，Node的waitStatus初始必定是0，因此获取锁的时候shouldParkAfterFailedAcquire方法首次进入，前一节点的waitStatus必定为0，执行compareAndSet将其设置为Node.SIGNAL(-1),再次调用shouldParkAfterFailedAcquire时，必定返回true。因此acquireQueued方法并不是死循环，而是在调用两次shouldParkAfterFailedAcquire方法之后（第一次将waitStatus设为-1，第二次返回true），执行了parkAndCheckInterrupt方法，挂起了当前线程。parkAndCheckInterrupt内调用了LockSupport.park(this)，查阅API可知，park方法挂起当前线程，并在以下三种情况下立即返回。</p><ul><li>其他线程调用unpark，唤醒了当前线程</li><li>其他线程调用了interrupt，中断了当前线程</li><li>方法虚假返回（for no reason）</li></ul><p>在AQS中，常见的为调用unpark(其他线程执行release释放锁时)唤醒了当前线程。当前线程唤醒之后，继续调用acquireQueue中的for循环，判断是否可以获取锁。</p><p>tryAcquire会调用子类Mutex.Sync的实现，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 如果state为0，则获取到锁</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</div><div class="line">   <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">   <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</div><div class="line">     setExclusiveOwnerThread(Thread.currentThread());</div><div class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>由此可见,AQS提供了一个模板，子类需要实现其tryAcquire方法，实现具体的获取锁逻辑（通过对state的读、写），子类lock方法直接调用AQS的acquire方法即可。</p><h3 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h3><p>Mutex的unlock方法调用了release方法，在AQS中定义，源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</div><div class="line">        Node h = head;</div><div class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</div><div class="line">            unparkSuccessor(h);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>还是同样的配方，release方法调用子类实现的tryRelease，返回true后，表示获取成功，之后判断头节点，由于锁的实现中，waitStatus必定为0或者-1，而当一个线程lock成功后，waitStatus必定为-1，所以执行unparkSuccessor方法，该方法首先将head节点的waitStatus设为0，之后判断head下一节点是否为空，若不为空且waitStatus不大于0（大于0表示线程被取消），则调用LockSupport.unpark唤醒下一节点对应的线程；若为空或线程被取消，从tail节点开始遍历队列，找到队列中距离head节点最近的、未被cancel（waitStatus小于0）的节点，调用LockSupport.unpark唤醒它。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * If status is negative (i.e., possibly needing signal) try</span></div><div class="line"><span class="comment">     * to clear in anticipation of signalling.  It is OK if this</span></div><div class="line"><span class="comment">     * fails or if status is changed by waiting thread.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keyword">int</span> ws = node.waitStatus;</div><div class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</div><div class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</div><div class="line"></div><div class="line">    <span class="comment">/*</span></div><div class="line"><span class="comment">     * Thread to unpark is held in successor, which is normally</span></div><div class="line"><span class="comment">     * just the next node.  But if cancelled or apparently null,</span></div><div class="line"><span class="comment">     * traverse backwards from tail to find the actual</span></div><div class="line"><span class="comment">     * non-cancelled successor.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    Node s = node.next;</div><div class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</div><div class="line">        s = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</div><div class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</div><div class="line">                s = t;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</div><div class="line">        LockSupport.unpark(s.thread);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这里简单介绍一下为什么循环是从tail往前遍历，这是因为CAS操作无法对双向链表进行原子插入，在enq中，具体的插入是，先将新节点指向tail，然后CAS将tail设为新节点，因此对于pred指针的设置时原子性的，可以保证从tail向前遍历可以找到所有的节点。而next指针只是一种优化路径，方便查找，并不能保证next为null，则该节点为队列的最后一个节点。</p><p>tryRelease方法的源码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将state设置为0，解锁</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</div><div class="line">   <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></div><div class="line">   <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</div><div class="line">   setExclusiveOwnerThread(<span class="keyword">null</span>);</div><div class="line">   setState(<span class="number">0</span>);</div><div class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p><p>由源码可知，tryRelease只需要将state设置为0即可，因为调用unlock方法的必定是之前调用lock成功的，因此当前state必定为1，为安全起见，使用getState判断是否为0，若为0，说明线程出错。state设置时，不需要调用CAS方法，只需要setState即可，保证write对于其他线程可见即可（通过volatile内存屏障保证）。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>AQS提供了一个框架，在其上可以构建丰富的线程同步工具类，JUC包中ReadWriteLock、CountDownLatch都是基于AQS实现的，AQS在JUC包中的地位相当重要。其类图如下：</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-4-6/46576757.jpg" alt=""></p><blockquote><p>盗图使用,详见<a href="http://www.cnblogs.com/skywang12345/p/3496098.html" target="_blank" rel="external">“JUC锁”01之 框架</a></p></blockquote><p>AQS提供了三大功能：独占锁、共享锁、ConditionObject。子类在实现中，可以实现其一部分方法。其编程思想值得借鉴，通过超类实现基本的处理流程，将其中部分抽成未实现方法，默认抛出异常，由子类实现，这种解耦方式，最大化的减少了代码的重复，且便于子类在实现中个性化自己的处理逻辑。</p><blockquote><p>很久没写博客了，准备以AQS入手，深入分析一下JUC包，flag就这么立起来了，希望可以实现吧~~</p></blockquote><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="external">AQS论文</a></li><li><a href="https://stackoverflow.com/questions/215497/in-java-difference-between-package-private-public-protected-and-private" target="_blank" rel="external">stackOverflow</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="external">java API: AbstractQueuedSynchronizer</a></li><li><a href="http://www.baeldung.com/java-unsafe" target="_blank" rel="external">Guide to Unsafe</a></li><li><a href="http://mishadoff.com/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/" target="_blank" rel="external">java magic: sun.misc.Unsafe</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3496098.html" target="_blank" rel="external">“JUC锁”01之 框架</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;java.util.concurrent包（之后简称JUC包）中，提供了大量的同步与并发的工具类，是多线程编程的“利器”。其中locks包下，包含了多种锁，如ReentrantLock独占锁、ReentrantReadWriteLock读写锁、Semaphore信号量（共享锁）等，而这些锁有一个共同的基础类：AbstractQueuedSynchronizer。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.wangjialong.cc/categories/java/"/>
    
    
      <category term="java" scheme="http://www.wangjialong.cc/tags/java/"/>
    
      <category term="juc" scheme="http://www.wangjialong.cc/tags/juc/"/>
    
      <category term="AQS" scheme="http://www.wangjialong.cc/tags/AQS/"/>
    
      <category term="Lock" scheme="http://www.wangjialong.cc/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>final和volatile在thread-safe中的作用</title>
    <link href="http://www.wangjialong.cc/2018/01/29/finalVsVolatile/"/>
    <id>http://www.wangjialong.cc/2018/01/29/finalVsVolatile/</id>
    <published>2018-01-28T16:00:00.000Z</published>
    <updated>2018-01-29T05:40:29.588Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>final和volatile都是Java中的关键字，对于它们的使用有过一定的了解，但并不能完整掌握，最近在学习中发现了它们在多线程中保证线程安全时的使用，在此进行总结并理清它们的使用范围。博客原文地址<a href="http://www.wangjialong.cc/2018/01/29/finalVsVolatile/#more">final和volatile在thread-safe中的作用</a></p><a id="more"></a><h1 id="常见用法"><a href="#常见用法" class="headerlink" title="常见用法"></a>常见用法</h1><h2 id="final的常规用法"><a href="#final的常规用法" class="headerlink" title="final的常规用法"></a>final的常规用法</h2><p>final关键字可以用来修饰类、方法、属性，它在各自不同的位置中的含义是不同的。</p><ul><li>修饰类、方法时，表示该类不能被继承，该方法不能被重写(override)。</li><li>修饰属性变量时，表示它为一个常量，一经初始化，便不可进行修改。</li></ul><p>虽然上面分开来两条进行讲述，但其实究其根本，final关键字最根本的含义就是，它所修饰的“对象”（这里并不是指面向对象编程中的对象）都是不能进行“=”操作的，也就是说不能进行赋值操作，它是一个“final decision”，是一个最终的决定。</p><p>怎么理解呢？试想，我们用final来修饰classA，此时classA就不能被继承，是不是可以理解为classA这个“对象”不能进行其他的赋值操作，它已经确定了！那么此时的赋值操作赋的是什么值呢？内存地址。试想任何变量在JVM中都是需要指向一个地址，类的定义也是一样，因此如果类classA在定义是被final修饰，那么该类的地址就不能进行修改以指向另一个地址，如果地址不能修改，那么classA就只能指向JVM最开始加载该类时的地址，因此classA也就不能被继承了。同理，final修饰方法也是一样，该方法的引用地址不能进行修改，因此也就不能进行重写了。final修饰属性、变量时就更是如此了。</p><p>需要注意的是，final在修饰属性、变量时，如果它的类型是一个引用类，此时不能进行赋值指的是不能进行“=”将其指向另一个引用，但是其引用内部的值时可以改变的。如final修饰了 List, 则该list不能进行 = 操作，可以进行 add操作。</p><p>综上，final修饰的不能进行 <strong>“=”</strong> 操作。</p><h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><p>volatile其实大家了解的已经够多了，用一句话来解释的话就是“volatile修饰的属性的读、写必须通过主内存”，这句话具体的理解可以通过下图进行。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-29/63258372.jpg" alt=""></p><p>如图所示，每个线程都有自己的“local storage”，对于主内存中的变量a的读写，线程都会先从主内存复制a的一份拷贝到线程本地内存中，之后的读写都是在本地内存中执行，因此，多个线程对同一个变量的读写就各自不可见，这就违反了thread-safe。</p><p>volatile通过强制变量的读写都在主内存进行，保证了多线程的thread-safe，如果volatile修饰了变量a，此时线程A和线程B对变量a的读写都是通过主内存进行的，因此，任一线程对a的修改都会对其他线程立即可见，就避免了多线程间变量值不一致的问题。</p><blockquote><p>具体的原理是和内存屏障有关系，感兴趣的同学可以深入了解一下,<a href="http://blog.csdn.net/u014307117/article/details/47746883" target="_blank" rel="external">浅析Java内存模型</a></p></blockquote><p>两个关键字的常用用法已经进行了介绍，看起来似乎volatile才在thread-safe中起作用，那么final的作用是什么呢？</p><h1 id="thread-safe用途"><a href="#thread-safe用途" class="headerlink" title="thread-safe用途"></a>thread-safe用途</h1><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><p>上面介绍了final的常用用途，一句话概括就是“不可修改引用地址”，由于这个特性，使得final在修饰属性变量时可以达到一定程度的thread-safe。</p><p>假设我们有如下类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiReadResource</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">final</span> List list;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MultiReadResource</span><span class="params">(<span class="keyword">int</span> id, List list)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">        <span class="keyword">this</span>.list = list;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>该类是一个多线程读的资源，内部有两个公有属性：id和list，都是由final来进行修饰，它们的赋值通过唯一的构造函数来进行。如果我们在主线程中进行了MultiReadResource的一个对象obj的初始化，在子线程中threadA、threadB并发的读取，因此，如果一旦obj初始化了，则id, list 一定也有值。什么意思？就是说多线程对于obj的访问(access)是不需要任何额外同步措施，就可以原子访问的，线程读取obj要么为null，要么obj引用存在且id、list也存在，这是JVM做的保证。</p><blockquote><p>原子访问的定义： 对于对象的访问要么为空，要么为最终状态，不能访问到中间状态，在此处的含义是，不存在obj的id有值，list为空的状态（除非obj初始化的时候list赋值为null）。</p></blockquote><p>由此可知，如果一个类的属性在初始化后引用不会改变，我们可以简单的将其用final修饰，此时无须任何额外同步操作，JVM可以保证该属性并发访问的thread-safe。</p><h2 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h2><p>volatile与final相反，它修饰的为需要多线程<strong>修改</strong>的变量，如果一个属性变量被volatile修改，那么这意味着：</p><ul><li>该变量不能进行线程的本地缓存，任何的读写都是直接针对主内存的。</li><li>对该变量的访问看起来就像是原子访问的一样，且读、写都是无锁的。</li></ul><p>什么叫“<em>看起来就像是原子访问</em>”？我们可以借助事务来理解，事务的原子性是很重要的，单机事务中保证原子性的两大手段是：加锁和MVCC（多版本控制）（<a href="http://blog.csdn.net/a60782885/article/details/71698814" target="_blank" rel="external">单机事务拾遗</a>）。对于volatile变量，我们既没有加锁，又没有MVCC，因此，我们的原子访问也只是看起来像是了。具体请看下面的例子，假设我们有下面的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleField</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line">        a++;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> a;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> t)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.a = t;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>对于上面定义的类来说，get、set方法都是原子的，但是add并不是，因为add方法具体分解为下面三步<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> temp = a;</div><div class="line">    temp = temp + <span class="number">1</span>;</div><div class="line">    a = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>因此该方法可能存在两个线程调用后，只加了1个的情况，违反了原子性的要求（两个线程调用add，最终a应该+2）。要实现add方法的原子性可以通过两种手段：</p><ul><li>用synchronized修饰add方法，相当于给方法加了锁</li><li>使用Atomic update工具类，具体可以参考<a href="http://www.wangjialong.cc/2018/01/18/atomicXFieldHelper/#more">AtomicXFieldUpdater，属性原子修改的外部工具类</a></li></ul><p>使用AtomicIntegerFieldUpdater后的类定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleField</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;Record&gt; ADDER =</div><div class="line">      AtomicIntegerFieldUpdater.newUpdater(SingleField.class, <span class="string">"a"</span>);</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> a;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</div><div class="line">        ADDER.incrementAndGet(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// get、set方法省略</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>其本质上是使用了CAS原语。</p><p>synchronized本质上是加锁，其和volatile的使用区别如下：</p><table><thead><tr><th>/</th><th>synchronized</th><th>volatile</th></tr></thead><tbody><tr><td>变量类型</td><td>Object</td><td>Object 或 基本类型（int，long)</td></tr><tr><td>允许null?</td><td>no</td><td>yes</td></tr><tr><td>是否阻塞？</td><td>yes</td><td>no</td></tr><tr><td>任何缓存变量访问同步?</td><td>yes</td><td>jdk5之后</td></tr><tr><td>同步何时发生？</td><td>进入/退出 synchronized 语法块</td><td>volatile变量被访问时</td></tr><tr><td>能够支持多步的原子操作（上面的add方法）</td><td>yes</td><td>jdk5之后可以通过Atomic 的 get、set来完成</td></tr></tbody></table><p>需要注意的是，如果volatile修饰的是一个复合元素，如int[] array，此时，如果某个线程将array指向另一个数组的地址，则其他线程可以读取到该修改；但如果该线程执行了 array[3]=10， 其他线程不一定能获取到array[3]，此时需要额外的同步方法。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>final和volatile都在多线程中有着自己的适用范围，我的简单的理解是：final可以用于常量（初始化之后，引用不被修改），volatile可以用于多个线程的并发读写。当然，这两个修饰符只能保证最低级别的线程安全，在高并发中，我们需要更多的手段（如锁、CAS）来处理复杂的场景。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://javamex.com/tutorials/synchronization_volatile.shtml" target="_blank" rel="external">The volatile keyword in Java</a></li><li><a href="https://javamex.com/tutorials/synchronization_final.shtml" target="_blank" rel="external">Thread-safety with the Java final keyword</a></li><li><a href="http://blog.csdn.net/u014307117/article/details/47746883" target="_blank" rel="external">浅析Java内存模型</a></li><li><a href="http://blog.csdn.net/suifeng3051/article/details/52611310" target="_blank" rel="external">全面理解Java内存模型</a></li><li><a href="https://segmentfault.com/a/1190000004487149" target="_blank" rel="external">如何使用 volatile, synchronized, final 进行线程间通信</a></li><li><a href="https://www.zhihu.com/question/33515481" target="_blank" rel="external">并发与并行的区别</a></li><li><a href="http://blog.csdn.net/a60782885/article/details/71698814" target="_blank" rel="external">单机事务拾遗</a></li><li><a href="https://www.imooc.com/learn/272" target="_blank" rel="external">视频课程：单机事务到分布式事务</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;final和volatile都是Java中的关键字，对于它们的使用有过一定的了解，但并不能完整掌握，最近在学习中发现了它们在多线程中保证线程安全时的使用，在此进行总结并理清它们的使用范围。博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2018/01/29/finalVsVolatile/#more&quot;&gt;final和volatile在thread-safe中的作用&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="final" scheme="http://www.wangjialong.cc/tags/final/"/>
    
      <category term="volatile" scheme="http://www.wangjialong.cc/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>AtomicXFieldUpdater，属性原子修改的外部工具类</title>
    <link href="http://www.wangjialong.cc/2018/01/18/atomicXFieldHelper/"/>
    <id>http://www.wangjialong.cc/2018/01/18/atomicXFieldHelper/</id>
    <published>2018-01-17T16:00:00.000Z</published>
    <updated>2018-01-20T01:55:59.345Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看资料的时候偶然间看到了AtomicLongFieldUpdater这个工具类，觉得新鲜就查阅了相关的资料，发现居然是jdk1.5就有的工具类，不禁感叹自己对Java的理解还是太浅了，于是在此整理一下该类的资料，作为知识储备。本篇博客原文地址<a href="http://www.wangjialong.cc/2018/01/18/atomicXFieldHelper/#more">AtomicXFieldUpdater，属性原子修改的外部工具类</a></p><a id="more"></a><h1 id="AtomicXFieldUpdater"><a href="#AtomicXFieldUpdater" class="headerlink" title="AtomicXFieldUpdater"></a>AtomicXFieldUpdater</h1><p>根据名字，我们可以知道<code>AtomicLongFieldUpdater</code>是对long型field进行原子update的，它是一个工具类，那么有long型的话是不是就有其他类型？通过查看相应的包，发现还有<code>AtomicIntegerFieldUpdater</code>和<code>AtomicReferenceFieldUpdater</code>两个“同胞兄弟”，它们3个加起来，支持了对Integer、long、Reference的原子操作，分别对应的原子类为AtomicInteger、AtomicLong、AtomicReference，那么updater和对应的原子类有什么区别呢？</p><p>拿<code>AtomicLongFieldUpdater</code>来说，通过API文档，其中写了一句：“通过反射技术来对volatile修饰的long型属性进行原子更新”。这里面有几个关键词：<strong>反射</strong>、<strong>volatile</strong>、<strong>原子更新</strong>。</p><p>本着<code>talk is cheap, show me the code</code>的原则，直接上代码来展示它的用法，代码来自<a href="http://www.cnblogs.com/skywang12345/p/3514635.html" target="_blank" rel="external">博客3</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// LongTest.java的源码</span></div><div class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLongFieldUpdater;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LongFieldTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// 获取Person的class对象</span></div><div class="line">        Class cls = Person.class;</div><div class="line">        <span class="comment">// 新建AtomicLongFieldUpdater对象，传递参数是“class对象”和要update的属性名"id"</span></div><div class="line">        AtomicLongFieldUpdater mAtoLong = AtomicLongFieldUpdater.newUpdater(cls, <span class="string">"id"</span>);</div><div class="line">        Person person = <span class="keyword">new</span> Person(<span class="number">12345678L</span>);</div><div class="line"></div><div class="line">        <span class="comment">// 比较person的"id"属性，如果id的值为12345678L，则设置为1000。</span></div><div class="line">        mAtoLong.compareAndSet(person, <span class="number">12345678L</span>, <span class="number">1000</span>);</div><div class="line">        System.out.println(<span class="string">"id="</span>+person.getId());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> id;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.id = id;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> id;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面代码最终输出的为1000，有几个需要关注的点</p><ol><li>updater通过<code>AtomicLongFieldUpdater.newUpdater</code>来构造，通过传入类对应的class和要修改的属性名”id”指定该updater所要修改的类的属性，此处为Person的id</li><li>通过compareAndSet(CAS)来进行原子的修改，12345678L是expectedValue，如果传入的person对象的id不为12345678L，则修改失败，这里保证了线程安全，试想在多线程环境下，threadA和threadB同时执行CAS操作，12345678L是传入的expectedValue，只有第一个到达的线程可以成功的执行CAS，将该id修改成希望修改的值</li></ol><p>根据Java API的说法，这个工具类不能保证完全的原子性，它只能保证相同updater上执行CAS和set操作的原子性，因此它的原子性是弱与AtomicLong的。为什么呢？因为AtomicLong是对long型属性加了一层原子引用，任何想要修改该long值的操作都需要先获得该原子引用，而updater不会为属性增加原子引用，它是通过反射技术，通过外部操作去修改long型属性值，因此它的原子保证也是通过外部限制的，因此只能保证同一updater进行CAS和set的原子性。</p><p>可以说上面的特性既是<code>AtomicLongFieldUpdater</code>的优点，也是它的缺点，为什么说呢？试想对于下面的类(代码来源于<a href="http://www.infoq.com/cn/articles/A-Post-Apocalyptic-sun.misc.Unsafe-World" target="_blank" rel="external">博客1</a>)，Record是一个记录类，保存了系统中的一条记录信息，version属性是版本的计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>&#123;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> AtomicLong version = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> version.incrementAndGet();</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>update方法更新版本号使其加一。这个类看起来逻辑十分清晰，但有一个隐藏的缺陷，就是每个Record都有一个对应的AtomicLong与之对应，如果系统有上亿条Record(<em>夸张而谈</em>)，而我们对于update方法的调用并不是很多，更多的是读取version的值，那么这会对堆空间造成严重的污染，大量的AtomicLong存在于堆上(<em>栈上存引用，堆上存实际的对象值</em>)，造成了内存的浪费，且AtomicLong的读取需要使用get方法，效率比正常变量的读取要慢，那么如何优化呢？</p><p>使用<code>AtomicLongFieldUpdater</code>，我们可以把Record类定义如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Record</span> </span>&#123;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLongFieldUpdater&lt;Record&gt; VERSION =</div><div class="line">      AtomicLongFieldUpdater.newUpdater(Record.class, <span class="string">"version"</span>);</div><div class="line"></div><div class="line"> <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> version = <span class="number">0</span>;</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> VERSION.incrementAndGet(<span class="keyword">this</span>);</div><div class="line"> &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>通过改造，对于version属性正常的读取操作可以像普通属性读取那样进行，而当需要update的时候，使用<code>AtomicLongFieldUpdater</code>的<code>incrementAndGet</code>方法来进行，这样内存空间节省了下来(1. AtomicLong对象的引用和值统统不需要，对于拥有大量Record的系统无疑是很大的内存空间 2. version的读取和普通属性读取相同)，还有一个好处是<code>AtomicLongFieldUpdater</code>是一个静态常量，它在Record类加载的时候就放在了堆空间的常量池中，对于N个Record，只需要一个<code>AtomicLongFieldUpdater</code>即可（类静态常量），如何还不清晰的话，可以把static final修饰的看作一个”全局常量”，整个系统只存在一个。</p><p>因此，虽然原子性不如<code>AtomicLong</code>，但它的效率很高，在特定的场景下有着很好的应用。Stack Overflow有一个回答比较好<a href="https://stackoverflow.com/questions/17239568/real-life-use-and-explanation-of-the-atomiclongfieldupdate-class" target="_blank" rel="external">引文3</a>，对于CPU的消耗来说，其从小到大依次为：</p><ul><li><code>long</code>: 最小， 多线程不安全</li><li><code>volatile long</code>: 消耗&gt;long, 多线程读取安全，但无法进行原子操作</li><li><code>AtomicLong</code>:消耗&gt;volatile long,多线程读安全，可进行原子操作</li><li><code>AtomicLongFieldUpdate</code>：消耗&gt;AtomicLong，因为其使用反射技术，多线程安全和可原子操作</li></ul><p>因此<code>AtomicLongFieldUpdate</code>的场景是，对于long的正常读写是占比很大的操作，原子操作只占很小的比例，并且多线程读取时必要的，此时可以使用<code>AtomicLongFieldUpdate</code>+<code>volatile</code>的组合。</p><h1 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h1><p>如果我们有一个双向链表，想要对链表中节点的替换进行原子操作，此时我们可以使用如下的代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</div><div class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> Node left, right;</div><div class="line"></div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;Node, Node&gt; leftUpdater =</div><div class="line">     AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, <span class="string">"left"</span>);</div><div class="line">   <span class="keyword">private</span> <span class="keyword">static</span> AtomicReferenceFieldUpdater&lt;Node, Node&gt; rightUpdater =</div><div class="line">     AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, <span class="string">"right"</span>);</div><div class="line"></div><div class="line">   <span class="function">Node <span class="title">getLeft</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> left; &#125;</div><div class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSetLeft</span><span class="params">(Node expect, Node update)</span> </span>&#123;</div><div class="line">     <span class="keyword">return</span> leftUpdater.compareAndSet(<span class="keyword">this</span>, expect, update);</div><div class="line">   &#125;</div><div class="line">   <span class="comment">// ... and so on</span></div><div class="line"> &#125;</div></pre></td></tr></table></figure><p><code>compareAndSetLeft</code>方法原子的将left指针从expect修改为update。我们知道，通过CAS实现的并发链表，其并发访问性能是最好的，因为无需给节点进行加锁，上面的代码是一个多线程访问的双向链表，拥有良好的读性能。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过上文的分析，总结<code>AtomicLongFieldUpdate</code>的使用场景主要如下(对另外两个也适用)：</p><ul><li>多数情况下对属性操作为正常的读写，偶尔需要原子操作(CAS)</li><li>该对象在系统中大量存在(如Record)，需要节省AtomicLong的内置原子引用所带来的内存消耗.</li></ul><p>据说ConcurrentHashMap, ConcurrentLinkedQueue和ConcurrentSkipListMap中有对AtomicXFieldUpdater工具类的使用，有机会可以通过源码加深一下理解，也可以读一下AtomicXFieldUpdater类的源码，对于AtomicLong和AtomicLongFieldUpdate的内存空间比较可以参考<a href="http://normanmaurer.me/blog/2013/10/28/Lesser-known-concurrent-classes-Part-1/" target="_blank" rel="external">引文6</a></p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="http://www.infoq.com/cn/articles/A-Post-Apocalyptic-sun.misc.Unsafe-World" target="_blank" rel="external">sun.misc.Unsafe的后启示录</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/AtomicLongFieldUpdater.html" target="_blank" rel="external">AtomicLongFieldUpdater API</a></li><li><a href="https://stackoverflow.com/questions/17239568/real-life-use-and-explanation-of-the-atomiclongfieldupdate-class" target="_blank" rel="external">Real life use and explanation of the AtomicLongFieldUpdate class</a></li><li><a href="http://www.cnblogs.com/skywang12345/p/3514635.html" target="_blank" rel="external">AtomicLongFieldUpdater原子类</a></li><li><a href="https://javamex.com/tutorials/synchronization_concurrency_7_atomic_updaters.shtml" target="_blank" rel="external">Atomic field updaters</a></li><li><a href="http://normanmaurer.me/blog/2013/10/28/Lesser-known-concurrent-classes-Part-1/" target="_blank" rel="external">Lesser known concurrent classes - Atomic*FieldUpdater</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看资料的时候偶然间看到了AtomicLongFieldUpdater这个工具类，觉得新鲜就查阅了相关的资料，发现居然是jdk1.5就有的工具类，不禁感叹自己对Java的理解还是太浅了，于是在此整理一下该类的资料，作为知识储备。本篇博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2018/01/18/atomicXFieldHelper/#more&quot;&gt;AtomicXFieldUpdater，属性原子修改的外部工具类&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="AtomicXFieldUpdater" scheme="http://www.wangjialong.cc/tags/AtomicXFieldUpdater/"/>
    
      <category term="concurrent" scheme="http://www.wangjialong.cc/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>【译文】Apache HAWQ：MPP的进化</title>
    <link href="http://www.wangjialong.cc/2018/01/11/hwaq_info/"/>
    <id>http://www.wangjialong.cc/2018/01/11/hwaq_info/</id>
    <published>2018-01-10T16:00:00.000Z</published>
    <updated>2018-01-20T02:02:44.126Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近研究Hive和Impala的时候，发现了它们的计算方式的不同，Hive是使用Map Reduce或Tez来执行tasks，而Impala使用的是MPP，以前在课上也对MPP有所了解，但不是很懂，因此到网上查阅了很多资料。最后发现了这篇英文的博客比较好<a href="https://content.pivotal.io/blog/apache-hawq-next-step-in-massively-parallel-processing" target="_blank" rel="external">Apache HAWQ</a>，对两者的比较也较为详细，在此将它翻译一下，加深一下自己的理解。博客原文地址<a href="http://www.wangjialong.cc/2018/01/11/hwaq_info/#more">【译文】Apache HAWQ：MPP的进化</a></p><a id="more"></a><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><a href="http://hawq.incubator.apache.org/" target="_blank" rel="external">Apache HAWQ(incubating)</a>的第一个版本受益于ASF(Apache software foundation)组织，通过将MPP(Massively Parallel Processing)和批处理系统(batch system)有效的结合，在性能上有了很大的提升，并且克服了一些关键的限制问题。一个新的重新设计的执行引擎在以下的几个问题在总体系统性能上有了很大的提高：</p><ul><li>硬件错误引起的短板问题(straggler)</li><li>并发限制</li><li>存储中间数据的必要</li><li>扩展性</li><li>执行速度</li></ul><p>Pivotal HAWQ的开发工作基于<a href="http://greenplum.org/" target="_blank" rel="external">GreenPlum数据库</a>的一个分支，至今(2016年8月)已经有超过3年了。最主要的目的就是在Hadoop集群上运行SQL语句查询存储于HDFS上的数据。在三年前的第一个公开的发行版中已经介绍了HAWQ的很多改进手段。但是对于查询执行引擎来说，Pivotal HAWQ仍然使用的是和GreenPlum一样的架构——MPP执行引擎。</p><p>HAWQ的基本代码已经贡献到了ASF项目中，并且保持了<a href="https://pivotal.io/products" target="_blank" rel="external">Piotal HDB</a>（我们提供的Hadoop原生SQL的商业支持）的核心部分。这周，Hortonworks刚刚宣布了跟Pivotal合作的使用了HAWQ支持的产品。</p><p>在这篇文章中，我将介绍Apache HAWQ新设计架构的核心思想。</p><h2 id="MPP架构"><a href="#MPP架构" class="headerlink" title="MPP架构"></a>MPP架构</h2><p>MPP解决方案的最原始想法就是消除共享资源。每个执行器有单独的CPU，内存和硬盘资源。一个执行器无法直接访问另一个执行器上的资源，除非通过网络上的受控的数据交换。这种资源独立的概念，对于MPP架构来说很完美的解决了可扩展性的问题。</p><p>MPP的第二个主要概念就是并行。每个执行器运行着完全一致的数据处理逻辑，使用着本地存储上的私有数据块。在不同的执行阶段中间有一些同步点(<em>我的理解：了解Java Gc机制的，可以对比GC中stop-the-world,在这个同步点，所有执行器处于等待状态</em>)，这些同步点通常被用于进行数据交换(像Spark和MapReduce中的shuffle阶段)。这里有一个经典的MPP查询时间线的例子： 每个垂直的虚线是一个同步点。例如：同步阶段要求在集群中”shuffle”数据以用于join和聚合(aggregations)操作,因此同步阶段可能执行一些数据聚合，表join，数据排序的操作，而每个执行器执行剩下的计算任务。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-8/41372192.jpg" alt=""></p><h2 id="MPP的设计缺陷"><a href="#MPP的设计缺陷" class="headerlink" title="MPP的设计缺陷"></a>MPP的设计缺陷</h2><p>但是，这样的设计对于所有的MPP解决方案来说都有一个主要的问题——短板效应。如果一个节点总是执行的慢于集群中其他的节点，整个集群的性能就会受限于这个故障节点的执行速度(所谓木桶的短板效应)，无论集群有多少节点，都不会有所提高。这里有一个例子展示了故障节点(下图中的Executor 7)是如何降低集群的执行速度的。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-8/29605991.jpg" alt=""></p><p>大多数情况下，除了Executor 7 其他的所有执行器都是空闲状态。这是因为他们都在等待Executor 7执行完成后才能执行同步过程，这也是我们的问题的根本。比如，当MPP系统中某个节点的RAID由于磁盘问题导致的性能很慢，或者硬件或者系统问题带来的CPU性能问题等等，都会产生这样的问题。所有的MPP系统都面临这样的问题。</p><p>如果你看一下Google的<a href="https://www.usenix.org/legacy/events/fast07/tech/full_papers/pinheiro/pinheiro_old.pdf" target="_blank" rel="external">磁盘错误率统计报告</a>，你就能发现观察到的AFR(annualized failure rate,年度故障率)在最好情况下，磁盘在刚开始使用的3个月内有百分之二十会发生故障。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-8/59595807.jpg" alt=""></p><p>如果一个集群有1000个磁盘，一年中将会有20个出现故障或者说每两周会有一个故障发生。如果有2000个磁盘，你将每周都会有故障发生，如果有4000个，将每周会有两次错误发生。两年的使用之后，你将把这个数字乘以4，也就是说，一个1000个磁盘的集群每周会有两次故障发生。</p><p>事实上，在一个确定的量级，你的MPP系统将总会有一个节点的磁盘队列出现问题，这将导致该节点的性能降低，从而像上面所说的那样限制整个集群的性能。这也是为什么在这个世界上没有一个MPP集群是超过50个节点服务器的。</p><p>MPP和批处理方案如MapReduce之间有一个更重要的不同就是并发度。并发度就是同一时刻可以高效运行的查询数。MPP是完美对称的，当查询运行的时候，集群中每个节点并发的执行同一个任务。这也就意味着MPP集群的并发度和集群中节点的数量是完全没有关系的。比如说，4个节点的集群和400个节点的集群将支持同一级别的并发度，而且他们性能下降的点基本上是同样。下面是我所说情况的一个例子。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-9/4237473.jpg" alt=""></p><p>正如你所见，10-18个并行查询会话产生了整个集群最大的吞吐量。如果你将会话数提高到20个以上的时候，吞吐量将慢慢下降到70%甚至更低。在此声明，吞吐量是在一个固定的时间区间内(时间足够长以产生一个代表性的结果)，执行的相同种类的查询任务的数量。<a href="https://hortonworks.com/blog/impala-vs-hive-performance-benchmark/" target="_blank" rel="external">Yahoo团队</a>调查Impala并发度限制时产生了一个相似的测试结果。Impala是一个基于Hadoop的MPP引擎。因此从根本上来说，较低的并发度是MPP方案必须承担的以提供它的低查询延迟和高数据处理速度。</p><h2 id="批处理架构"><a href="#批处理架构" class="headerlink" title="批处理架构"></a>批处理架构</h2><p>为了解决这个问题，伴随着<a href="http://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="external">MapReduce论文</a>的发表和其衍生技术的出现，一种新的解决方案诞生。这种设计原则被应用到了<a href="https://hadoop.apache.org/docs/r1.2.1/mapred_tutorial.html" target="_blank" rel="external">Apache Hadoop MapReduce</a>，<a href="http://spark.apache.org/" target="_blank" rel="external">Apache Spark</a>以及其他的工具上。主要的思想是将两个同步点之间的每个单个的执行阶段(“step”)，切分为一系列的独立的”tasks”，”tasks”的数目跟”exexutors”的数量完全没有相关性。比如说，HDFS上，MapReduce的”tasks”数目等于输入文件切片的数量，也就是说等于输入文件所对应的HDFS block数量(单个节点上)。在同步点之间，这些”tasks”被随机的分配在空闲的”executors”上。与此相反，MPP上每个处理数据的task被绑定到持有该数据切片的指定executor上。MapReduce的同步点执行Job的启动，shuffle，和job的停止。对于Apache Spark来说，同步点执行的是Job的启动，shuffle，缓存数据集(dataset)，和Job的停止。下图是Apache Spark工作的一个实例，每个不同颜色的bar代表了不同的task，每个executor可以并行的执行3个tasks。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-9/55097613.jpg" alt=""></p><p>你可以看到Executor 3是一个故障节点——它执行task的时间大约是其他Executor的两倍慢。但这不是一个问题，Executor 3会慢慢分配到更少的task执行。如果这个问题更加的严重，<a href="https://en.wikipedia.org/wiki/Speculative_execution" target="_blank" rel="external">推测执行</a>将会起作用，速度慢的节点上的task将会在其他节点上重新执行(<em>MapReduce的机制之一，若某个task执行时间过长，会在其他节点上重新运行该task，取最先执行结束的task的结果</em>)。</p><p>这项技术(推测执行)之所以可以实施是因为使用了共享存储。为了处理一块数据，你不需要将这块数据存储在你指定的机器上。相反，你可以从远程节点上获取需要的数据块。当然，远程处理相对于本地来说总是更加昂贵的，因为数据需要移动，所以机器节点尽可能的在本地处理数据。但是为了防止故障节点和完成批处理过程，推测执行将解决故障节点的问题，这在MPP中是完全无法解决的。</p><p>这里有个云端执行推测执行的<a href="https://www.usenix.org/legacy/event/osdi08/tech/full_papers/zaharia/zaharia.pdf" target="_blank" rel="external">研究</a>.</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-9/22349184.jpg" alt=""></p><p>这张图表是关于WordCount程序性能的。正如你所见的，在云环境下，推测执行将执行速度加快了2.5倍之多，而云环境的<a href="http://blog.scalyr.com/2012/10/a-systematic-look-at-ec2-io/" target="_blank" rel="external">短板效应</a>是众所周知的。共享存储和更加细粒度的调度(task）)两种技术的结合使得批处理系统比MPP集群具有更好的可扩展性——可以支持上千个节点和上万个HDD。</p><h2 id="批处理架构的问题"><a href="#批处理架构的问题" class="headerlink" title="批处理架构的问题"></a>批处理架构的问题</h2><p>但是，每件事都是有代价的.MPP上，你不需要将中间数据写入HDD因为一个单一的Executor只处理一个单个的task，因此你可以简单地直接将数据stream到下一个执行阶段。这被叫作”pipelining”，它提供了很大的性能提升。</p><blockquote><p>在大牛博客讨论去中提到，要实现两个大表的join操作，Spark将会写HDD 3次(1. 表1根据join key 进行shuffle 2. 表2根据join key 进行shuffle 3. Hash表写入HDD)， 而MPP只需要一次写入(Hash表写入)。这是因为MPP将mapper和reducer同时运行，而MapReduce将它们分成有依赖关系的tasks(DAG),这些task是异步执行的，因此必须通过写入中间数据共享内存来解决数据的依赖。</p></blockquote><p>当你有一些不相关的tasks，且它们可以顺序的在单一的Executor上执行时，就像批处理那样，你除了<a href="https://0x0fff.com/spark-architecture-shuffle/" target="_blank" rel="external">将中间数据存储到本地磁盘上</a>，别无它选。下一个执行阶段将会从本地磁盘读取中间数据并进行处理。这也是使得系统变慢的原因。</p><p>根据我的经验所知，将一个现代的MPP系统和Spark在一个相同的硬件集群上进行性能比较的话，Spark通常是慢3-5倍的。50个机器的MPP集群将会提供大约250个节点的Spark相同的处理能力，但Spark可以扩展到250个节点以上，这对于MPP来说是不可能的。</p><h2 id="将MPP和Batch进行结合"><a href="#将MPP和Batch进行结合" class="headerlink" title="将MPP和Batch进行结合"></a>将MPP和Batch进行结合</h2><p>我们现在可以看到两个架构的优点和短板。MPP是更快的，但是有两个关键痛点——短板效应和并发限制。而对于像MapReduce这样的批处理系统，我们需要花费时间来存储中间数据到磁盘上，但与此同时，我们获得了更高的扩展度而因此可以获得远远大于MPP的集群规模。我们如何才能将两者结合来获得MPP低延迟和高速处理，使用batch-like的设计来降低短板效应和并发度低的问题？我想如果我告诉你答案是新的Apache HAWQ的架构你是不会惊讶的。</p><p>再一次提出问题，MPP的查询是如何执行的？通过一定数量的平行执行的进程运行完全相同的代码，进程数目和集群的节点数量是完全一致的，在每个节点上处理本地数据。但是，当我们介绍HDFS的时候，你不会把数据和本地Executor绑定在一起，这也就意味着你可以摆脱Executor数目的限制，你也就不需要在固定的节点上处理本地存在的数据(在传统MPP上，你不能处理远程节点的数据).为什么？因为HDFS默认对同样的block存储3个备份，也就意味着集群中至少有3个节点上，你可以选择创建一个Executor并处理本地的数据。并且，HDFS支持远程读取数据，也就意味着至少有两个机架上可以处理本地机架上的数据，这样就可以通过最少的拓扑数来远程获取数据。</p><p>这也就是为什么Apache HAWQ提出了”virtual segments”的概念——GreenPlum中的”segment” 是改进版的PostgreSQL数据库中的一个单一实例，它在每个节点上存在一个，并且在每次查询中产生”executor”进程。如果你有一个小的查询，它可以被4个executors执行甚至是一个。如果你有一个大的查询，你可以用100个甚至1000个executor执行。每个查询仍然是以MPP风格对本地数据进行处理，而且不需要将中间数据写入到HDD上，但是”virtual segments”允许executor运行在任何地方。下面是它的一个工作示例图（不同颜色代表了不同的查询，虚线代表了查询中的shuffle操作）</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-9/73954191.jpg" alt=""></p><p>这赋予了你以下的特性：</p><ol><li>减轻MPP系统的短板问题：因为我们可以动态的添加节点和删除节点。因此，严重的磁盘故障将不会影响整个集群的性能，系统可以拥有比传统MPP更大量级的集群。现在，我们可以暂时的将一个故障节点从集群中移除，那么就不会有更多的executor在上面开始运行。并且，移除节点时不会有停机时间。</li><li>一次查询现在被一个动态数量的executors进行执行，这也就带来了更高的并发度，缓和了MPP系统的限制并加入了batch系统的灵活性。想象一下拥有50个节点的集群，每个节点最多可以运行200个并行的进程。这就意味着你一共拥有了”50*200=10,000”个”execution slot”。你可以对20个查询每个执行500个executor，也可以对200个查询每个执行50个executor，甚至于你可以对1个查询运行10000个executor。在这里是完全灵活可控的。你也可能有一个大的查询要使用4000个segments和600个小的查询每个需要10个executors，这也是可以的。</li><li>数据管道的完美应用：实时的从一个executor中将数据转移到另一个executor中。在执行阶段，单独的查询仍然是MPP的，而不是batch。因此，不需要将中间数据存储到本地磁盘中(无论何时，操作都允许数据管道)。这意味着我们离MPP的速度更近一步了。</li><li>像MPP那样，我们仍然尽可能的使用本地数据来执行查询，这一点可以通过HDFS的short-circuit read(当client和数据在同一节点上，可以通过直接读取本地文件来绕过DataNode，参考<a href="http://hadoop.apache.org/docs/r2.7.2/hadoop-project-dist/hadoop-hdfs/ShortCircuitLocalReads.html" target="_blank" rel="external">HDFS Short-Circuit Local Reads</a>)来实现。每个executor会在拥有该文件最多块数的节点上创建并执行，这也最大化了执行效率。</li></ol><h2 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h2><p>Apache HAWQ提出了一种新的设计方案，基本上是MPP和Batch的结合体，包含了两者的优点并抵消了各自的关键缺陷。当然，不存在一个理想的数据处理解决方案——MPP仍然是更快的且Batch仍然有更高的并发度和可扩展性。这也正是为什么为一个特定的场景选择一个特定的方案的关键所在，我们有很多的专家来提供支持。作为深入的了解，你可以阅读<a href="https://www.slideshare.net/AGrishchenko/apache-hawq-architecture" target="_blank" rel="external">Apache HAWQ架构介绍</a>,也可查看<a href="https://blog.pivotal.io/big-data-pivotal/products/introducing-the-newly-redesigned-apache-hawq" target="_blank" rel="external">这里</a>和<a href="https://events.static.linuxfound.org/sites/events/files/slides/hawq-apachecon-final-slides.pptx_.pdf" target="_blank" rel="external">这里</a>.</p><h1 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h1><p>MPP和Batch各有各自的优点和缺陷，正如原文所说，不存在一个完美的解决方案，关键是为自己的场景选择一个合适的架构。如果说对实时性有更高的要求且集群规模不会很大的时候，可以选择使用MPP的结构，这样会提供更快的查询速度；如果集群规模很大，对可扩展性有着更高的要求，那么可以选择Batch类型的架构(如Spark)。HAWQ可以说中和了两者的优缺点，提供了一个比较性能均衡的解决方案，我个人觉得它更多的是偏向于MPP的设计风格，但为了解决其扩展性的缺陷和短板效应，引入了Batch的设计思想，部分提高了扩展性，且不再局限于查询被一个固定数量的executor执行。在参考资料的第3篇博客的评论区，大牛们也对Spark和MPP进行了激烈的讨论，正如他们所说，每项技术都是在不断发展的，不是被”放在一个box中”，MPP和Batch的区别不会再有那么明显，Spark也正在向MPP的方向努力，以提供更快的查询速度。相信未来的技术发展，会逐渐弥补两者间的差距，提供更完美的解决方案。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://0x0fff.com/hadoop-vs-mpp/" target="_blank" rel="external">hadoop vs MPP</a></li><li><a href="https://www.zhihu.com/question/22037987" target="_blank" rel="external">知乎回答：Hadoop和MPP的关系是什么</a></li><li><a href="https://0x0fff.com/apache-spark-future/" target="_blank" rel="external">Apache Spark Future</a>(<em>重点看大牛的讨论过程</em>)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近研究Hive和Impala的时候，发现了它们的计算方式的不同，Hive是使用Map Reduce或Tez来执行tasks，而Impala使用的是MPP，以前在课上也对MPP有所了解，但不是很懂，因此到网上查阅了很多资料。最后发现了这篇英文的博客比较好&lt;a href=&quot;https://content.pivotal.io/blog/apache-hawq-next-step-in-massively-parallel-processing&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Apache HAWQ&lt;/a&gt;，对两者的比较也较为详细，在此将它翻译一下，加深一下自己的理解。博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2018/01/11/hwaq_info/#more&quot;&gt;【译文】Apache HAWQ：MPP的进化&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/tags/hadoop/"/>
    
      <category term="HAWQ" scheme="http://www.wangjialong.cc/tags/HAWQ/"/>
    
      <category term="MPP" scheme="http://www.wangjialong.cc/tags/MPP/"/>
    
  </entry>
  
  <entry>
    <title>Sentry源码之HiveServer2鉴权过程</title>
    <link href="http://www.wangjialong.cc/2018/01/04/sentry_authorize/"/>
    <id>http://www.wangjialong.cc/2018/01/04/sentry_authorize/</id>
    <published>2018-01-03T16:00:00.000Z</published>
    <updated>2018-01-20T01:55:05.668Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Sentry是Hadoop生态中的一员，扮演着“守门人”的角色，看守着大数据平台的数据安全的访问。它以Plugin的形式运行于组件中，通过关系型数据库（PostgreSQL、MySQL）或本地文件来存取访问策略，对数据使用者提供细粒度的访问控制。本文试图在源码层剖析Sentry的鉴权过程，以帮助更好的理解权限的鉴定过程。博客地址<a href="http://www.wangjialong.cc/2018/01/04/sentry_authorize/#more">Sentry源码之HiveServer2鉴权过程</a></p><a id="more"></a><h1 id="Sentry架构简述"><a href="#Sentry架构简述" class="headerlink" title="Sentry架构简述"></a>Sentry架构简述</h1><p>Sentry的设计目标是作为一层独立的访问控制层来对Hadoop组件（目前支持HDFS，Hive，Impala，solr，kafka，sqoop）进行授权/鉴权操作，因此它的耦合度很低，以插件的形式工作于组件之上。可以把它看作Java web中的filter，当用户请求过来的时候，sentry截获了用户的信息，对用户的权限进行验证，如果成功，则让该请求通过；否则，抛出异常，阻断该请求。</p><p>Sentry是一个分层的结构，如下图所示</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-3/37903285.jpg" alt=""></p><ul><li><strong>Binding层</strong> 负责将用户对Hadoop组件的访问请求截获，并解析出其中的用户信息，以便进行鉴权</li><li><strong>Provider层</strong> 是一个较通用的权限策略验证层，在这里抽象了权限对象，并对用户所具备的权限对象进行验证</li><li><strong>Policy Metadata Store</strong> 负责与策略的存储和读取，目前支持文件存储和关系型数据库存储方式。</li></ul><p>由上图结合源码分析，Sentry的大致工作流程为：</p><ol><li>Binding层拦截用户的访问，并将用户信息解析出来，暂存到一个subject对象中</li><li>Policy Metadata Store层根据用户访问的资源对象（表名）和用户信息（subject）从底层存储（文件或关系型数据库）中读取两个权限对象列表：requireList（需要有的权限）和obtainList（用户当前的权限）</li><li>Policy Engine根据读取到的两个权限对象列表，逐一进行权限的比对，缺少任何一个权限都要抛出异常，只有当完全满足时，将此访问请求通过</li></ol><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>下面以HiveServer2为例，分析Sentry是如何进行鉴权工作的，以此为切入点，剖析Sentry的通用鉴权模型。上面提到，Sentry的鉴权过程中主要分为了Binding、Policy Engine和Policy MetadataStore三层的协作，下面逐一进行分析。</p><h2 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h2><p>上面谈到Binding的主要工作是解析用户信息，那么Sentry是如何截获用户对Hadoop组件的请求的呢？拿HiveServer2为例，用户在连接的时候，会由HiveServer2创建一个session，该session中保存了用户的用户名等信息，该session在该用户的整个TCP连接中都会保留，因此如果可以获得该session，便可以获得用户名。</p><p>HiveServer2中提供了一个方便的接口叫作HiveSessionHook，其中只有一个run方法，在session manager创建一个session的时候，会进行调用。这是一个Hive提供的hook机制，方便进行自定义的hook动作，Sentry使用了这个Hook，定义了一个HiveAuthzBindingSessionHookV2类实现了HiveSessionHook接口，重写了其中的run方法。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(HiveSessionHookContext sessionHookContext)</span> <span class="keyword">throws</span> HiveSQLException </span>&#123;</div><div class="line">  <span class="comment">// Add sentry hooks to the session configuration</span></div><div class="line">  HiveConf sessionConf = sessionHookContext.getSessionConf();</div><div class="line"></div><div class="line">  appendConfVar(sessionConf, ConfVars.SEMANTIC_ANALYZER_HOOK.varname, SEMANTIC_HOOK);</div><div class="line">  <span class="comment">// enable sentry authorization V2</span></div><div class="line">  sessionConf.setBoolean(HiveConf.ConfVars.HIVE_AUTHORIZATION_ENABLED.varname, <span class="keyword">true</span>);</div><div class="line">  sessionConf.setBoolean(HiveConf.ConfVars.HIVE_SERVER2_ENABLE_DOAS.varname, <span class="keyword">false</span>);</div><div class="line">  sessionConf.set(HiveConf.ConfVars.HIVE_AUTHENTICATOR_MANAGER.varname,</div><div class="line">      <span class="string">"org.apache.hadoop.hive.ql.security.SessionStateUserAuthenticator"</span>);</div><div class="line"></div><div class="line">  <span class="comment">// grant all privileges for table to its owner</span></div><div class="line">  sessionConf.setVar(ConfVars.HIVE_AUTHORIZATION_TABLE_OWNER_GRANTS, <span class="string">""</span>);</div><div class="line"></div><div class="line">  <span class="comment">// Enable compiler to capture transform URI referred in the query</span></div><div class="line">  sessionConf.setBoolVar(ConfVars.HIVE_CAPTURE_TRANSFORM_ENTITY, <span class="keyword">true</span>);</div><div class="line"></div><div class="line">  <span class="comment">// set security command list</span></div><div class="line">  HiveAuthzConf authzConf = HiveAuthzBindingHookBaseV2.loadAuthzConf(sessionConf);</div><div class="line">  String commandWhitelist =</div><div class="line">      authzConf.get(HiveAuthzConf.HIVE_SENTRY_SECURITY_COMMAND_WHITELIST,</div><div class="line">          HiveAuthzConf.HIVE_SENTRY_SECURITY_COMMAND_WHITELIST_DEFAULT);</div><div class="line">  sessionConf.setVar(ConfVars.HIVE_SECURITY_COMMAND_WHITELIST, commandWhitelist);</div><div class="line"></div><div class="line">  <span class="comment">// set additional configuration properties required for auth</span></div><div class="line">  sessionConf.setVar(ConfVars.SCRATCHDIRPERMISSION, SCRATCH_DIR_PERMISSIONS);</div><div class="line"></div><div class="line">  <span class="comment">// setup restrict list</span></div><div class="line">  sessionConf.addToRestrictList(ACCESS_RESTRICT_LIST);</div><div class="line"></div><div class="line">  <span class="comment">// set user name</span></div><div class="line">  sessionConf.set(HiveAuthzConf.HIVE_ACCESS_SUBJECT_NAME, sessionHookContext.getSessionUser());</div><div class="line">  sessionConf.set(HiveAuthzConf.HIVE_SENTRY_SUBJECT_NAME, sessionHookContext.getSessionUser());</div><div class="line"></div><div class="line">  <span class="comment">// Set MR ACLs to session user</span></div><div class="line">  updateJobACL(sessionConf, JobContext.JOB_ACL_VIEW_JOB, sessionHookContext.getSessionUser());</div><div class="line">  updateJobACL(sessionConf, JobContext.JOB_ACL_MODIFY_JOB, sessionHookContext.getSessionUser());</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>英文注释已经比较详细，在此有几点需要注意的是：</p><ul><li>HiveConf是Configuration的一个子类，可以把它看成一个Map集合，存放了Hive当前session的一些配置信息，默认会将hive-site.xml中的配置载入，因此通过HiveConf就可以获得hive-site.xml中的配置项。</li><li>semantic analyzer hook也被注入了进来，它也是一个hook，在SQL语句的语法分析阶段触发，可以在此完成一些鉴权的操作，但sentry的主要鉴权逻辑并不在此实现</li><li><code>SCRATCH_DIR_PERMISSIONS</code>的值为700，是对目录的权限赋值，对应为111000000，也就是对该用户有r、w、x权限</li><li><code>ACCESS_RESTRICT_LIST</code>是一个key的集合，该集合中的key值对应的value值不允许用户修改</li><li>HiveAuthzConf也是Configuration的一个子类，可以把它看做sentry-site.xml中的配置信息</li><li>设置subject name，这里为用户名，用于之后的用户鉴权，每个用户对应一定的权限。</li></ul><p>Binding层至此就分析完毕了，主要使用了HiveServer2中的session hook，将session的用户名读取并设置到一个key值中，以备之后的使用。</p><h2 id="权限验证"><a href="#权限验证" class="headerlink" title="权限验证"></a>权限验证</h2><p>HiveServer2原生提供了访问控制逻辑，Sentry在此基础上进行了RBAC概念的强化，使得权限只能赋予给角色，角色赋予给用户/用户组，由此就有了权限——角色——用户组——用户的链式关系。当拿到用户名之后，通过数据库中读取其角色和相应的权限集合，便可以进行权限的验证了。Sentry中跟权限验证相关的类关系如下图所示：</p><p><img src="http://ow9czedj7.bkt.clouddn.com/18-1-3/96935367.jpg" alt=""></p><blockquote><p>类/接口的右上角表示其属于Hive还是Sentry，空心菱形代表的是实现的接口，实心箭头指向的为内部的一个引用对象。</p></blockquote><ul><li><code>HiveAuthorizerFactory</code>和<code>HiveAuthorizer</code>都来自于Hive且都为接口，<code>HiveAuthorizerFactory</code>实现了一个抽象工厂模式，返回一个<code>HiveAuthorizer</code></li><li><code>SentryAuthorizerFactory</code>和<code>SentryHiveAuthorizer</code>分别是Sentry的两个对应实现，到此HiveServer2的访问控制就交给了Sentry处理</li><li><code>SentryHiveAuthorizer</code>内有两个引用接口，分别为<code>SentryHiveAccessController</code>和<code>SentryHiveAuthorizationValidator</code>,分别负责授权（grant/revoke)和鉴权（checkPrivileges）操作</li><li><code>SentryHiveAccessController</code>的默认实现为<code>DefaultSentryAccessController</code></li><li><code>SentryHiveAuthorizationValidator</code>的默认实现为<code>DefaultSentryValidator</code>,其中的checkPrivileges方法负责鉴权，在该方法中调用了<code>HiveAuthzBinding</code>的authorize方法完成最终的权限验证</li></ul><h1 id="authorize"><a href="#authorize" class="headerlink" title="authorize"></a>authorize</h1><p>上面说到DefaultSentryValidator中的checkPrivileges方法调用了authorize方法进行实际的权限验证，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hiveAuthzBinding.authorize(hiveOp, stmtAuthPrivileges,</div><div class="line">          <span class="keyword">new</span> Subject(authenticator.getUserName()), inputHierarchyList, outputHierarchyList);</div></pre></td></tr></table></figure><ul><li>hiveOp是本次sql语句转化为的HiveOperation枚举对象，它表示了当前SQL对应的操作</li><li>stmtAuthPrivileges表示本次操作所需的权限集合，它从一个预先定义好的系统常量表中根据hiveOp的类型取出</li><li>new Subject表示的是当前的用户</li><li>inputHierarchyList和outputHierarchyList分别表示输入对象和输出对象</li></ul><p>由上面传入的参数可以看出，除了subject是用户相关的信息外，其他全部都是本次SQL操作所需要的权限信息，其中stmtAuthPrivileges直接表示本次operation需要的权限，inputHierarchyList和outputHierarchyList表示了本次SQL需要访问的输入、输出资源，因此，鉴权验证需要分为两步：</p><ol><li>用户是否拥有对输入对象列表的该operation对应的访问权限</li><li>用户是否拥有对输出对象列表的该operation对应的访问权限</li></ol><p>下面我们进入authorize方法一探究竟</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authorize</span><span class="params">(HiveOperation hiveOp, HiveAuthzPrivileges stmtAuthPrivileges,</span></span></div><div class="line"><span class="function"><span class="params">    Subject subject, List&lt;List&lt;DBModelAuthorizable&gt;&gt; inputHierarchyList,</span></span></div><div class="line"><span class="function"><span class="params">    List&lt;List&lt;DBModelAuthorizable&gt;&gt; outputHierarchyList)</span></span></div><div class="line"><span class="function">        <span class="keyword">throws</span> AuthorizationException </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!open) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Binding has been closed"</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">boolean</span> isDebug = LOG.isDebugEnabled();</div><div class="line">  <span class="keyword">if</span>(isDebug) &#123;</div><div class="line">    LOG.debug(<span class="string">"Going to authorize statement "</span> + hiveOp.name() +</div><div class="line">        <span class="string">" for subject "</span> + subject.getName());</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/* for each read and write entity captured by the compiler -</span></div><div class="line"><span class="comment">   *    check if that object type is part of the input/output privilege list</span></div><div class="line"><span class="comment">   *    If it is, then validate the access.</span></div><div class="line"><span class="comment">   * Note the hive compiler gathers information on additional entities like partitions,</span></div><div class="line"><span class="comment">   * etc which are not of our interest at this point. Hence its very</span></div><div class="line"><span class="comment">   * much possible that the we won't be validating all the entities in the given list</span></div><div class="line"><span class="comment">   */</span></div><div class="line"></div><div class="line">  <span class="comment">// Check read entities</span></div><div class="line">  Map&lt;AuthorizableType, EnumSet&lt;DBModelAction&gt;&gt; requiredInputPrivileges =</div><div class="line">      stmtAuthPrivileges.getInputPrivileges();</div><div class="line">  <span class="keyword">if</span>(isDebug) &#123;</div><div class="line">    LOG.debug(<span class="string">"requiredInputPrivileges = "</span> + requiredInputPrivileges);</div><div class="line">    LOG.debug(<span class="string">"inputHierarchyList = "</span> + inputHierarchyList);</div><div class="line">  &#125;</div><div class="line">  Map&lt;AuthorizableType, EnumSet&lt;DBModelAction&gt;&gt; requiredOutputPrivileges =</div><div class="line">      stmtAuthPrivileges.getOutputPrivileges();</div><div class="line">  <span class="keyword">if</span>(isDebug) &#123;</div><div class="line">    LOG.debug(<span class="string">"requiredOuputPrivileges = "</span> + requiredOutputPrivileges);</div><div class="line">    LOG.debug(<span class="string">"outputHierarchyList = "</span> + outputHierarchyList);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">boolean</span> found = <span class="keyword">false</span>;</div><div class="line">  <span class="keyword">for</span> (Map.Entry&lt;AuthorizableType, EnumSet&lt;DBModelAction&gt;&gt; entry : requiredInputPrivileges.entrySet()) &#123;</div><div class="line">    AuthorizableType key = entry.getKey();</div><div class="line">    <span class="keyword">for</span> (List&lt;DBModelAuthorizable&gt; inputHierarchy : inputHierarchyList) &#123;</div><div class="line">      <span class="keyword">if</span> (getAuthzType(inputHierarchy).equals(key)) &#123;</div><div class="line">        found = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (!authProvider.hasAccess(subject, inputHierarchy, entry.getValue(), activeRoleSet)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException(<span class="string">"User "</span> + subject.getName() +</div><div class="line">              <span class="string">" does not have privileges for "</span> + hiveOp.name());</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!found &amp;&amp; !key.equals(AuthorizableType.URI) &amp;&amp; !(hiveOp.equals(HiveOperation.QUERY))</div><div class="line">        &amp;&amp; !(hiveOp.equals(HiveOperation.CREATETABLE_AS_SELECT))) &#123;</div><div class="line">      <span class="comment">//URI privileges are optional for some privileges: anyPrivilege, tableDDLAndOptionalUriPrivilege</span></div><div class="line">      <span class="comment">//Query can mean select/insert/analyze where all of them have different required privileges.</span></div><div class="line">      <span class="comment">//CreateAsSelect can has table/columns privileges with select.</span></div><div class="line">      <span class="comment">//For these alone we skip if there is no equivalent input privilege</span></div><div class="line">      <span class="comment">//<span class="doctag">TODO:</span> Even this case should be handled to make sure we do not skip the privilege check if we did not build</span></div><div class="line">      <span class="comment">//the input privileges correctly</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException(<span class="string">"Required privilege( "</span> + key.name() + <span class="string">") not available in input privileges"</span>);</div><div class="line">    &#125;</div><div class="line">    found = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (Map.Entry&lt;AuthorizableType, EnumSet&lt;DBModelAction&gt;&gt; entry : requiredOutputPrivileges.entrySet()) &#123;</div><div class="line">    AuthorizableType key = entry.getKey();</div><div class="line">    <span class="keyword">for</span> (List&lt;DBModelAuthorizable&gt; outputHierarchy : outputHierarchyList) &#123;</div><div class="line">      <span class="keyword">if</span> (getAuthzType(outputHierarchy).equals(key)) &#123;</div><div class="line">        found = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (!authProvider.hasAccess(subject, outputHierarchy, entry.getValue(), activeRoleSet)) &#123;</div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException(<span class="string">"User "</span> + subject.getName() +</div><div class="line">              <span class="string">" does not have privileges for "</span> + hiveOp.name());</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(!found &amp;&amp; !(key.equals(AuthorizableType.URI)) &amp;&amp;  !(hiveOp.equals(HiveOperation.QUERY))) &#123;</div><div class="line">      <span class="comment">//URI privileges are optional for some privileges: tableInsertPrivilege</span></div><div class="line">      <span class="comment">//Query can mean select/insert/analyze where all of them have different required privileges.</span></div><div class="line">      <span class="comment">//For these alone we skip if there is no equivalent output privilege</span></div><div class="line">      <span class="comment">//<span class="doctag">TODO:</span> Even this case should be handled to make sure we do not skip the privilege check if we did not build</span></div><div class="line">      <span class="comment">//the output privileges correctly</span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> AuthorizationException(<span class="string">"Required privilege( "</span> + key.name() + <span class="string">") not available in output privileges"</span>);</div><div class="line">    &#125;</div><div class="line">    found = <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由代码可知，传入的stmtAuthPrivileges包含了输入对象权限map和输出对象权限map，需要分别对它们进行权限的验证，map的key值为一个AuthorizableType枚举对象，取值为Server,Db,Table,Column,View,URI中的一种，对于每一个AuthorizableType，至少有一个inputList或outputList与其authzType相同,此时通过Provider的hasAccess方法判断该用户是否对该对象列表拥有相应的权限(entry.getValue代表了需要的权限)。</p><p>如果没有一个inputList或者outputList与之类型相同，且该AuthorizableType不是uri,hiveOp不是QUERY操作，则直接抛出异常，这里的意思说，如果对一个表A需要进行除去select之外的操作，则必须拥有相应的权限。</p><p>分析到这里发现，authorize并不是最终判断权限的方法，还需要调用Provider的hasAccess方法，这里也很好理解，因为我们这里只有本次操作的访问控制对象所需要的权限集合，并没有该用户当前获得的权限集合，因此，我们需要通过Provider来将用户的权限集合从存储介质中读出来，前面提到过，目前支持文件（本地/hdfs）和关系型数据库两种存储方式。</p><p>Provider中有三个相关的对象，分别为Policy Engine， Provider， Provider Backend。</p><ul><li>Policy engine 默认为org.apache.sentry.policy.engine.common.CommonPolicyEngine类</li><li>Provider默认为org.apache.sentry.provider.common.HadoopGroupResourceAuthorizationProvider</li><li>Backend默认为org.apache.sentry.provider.file.SimpleFileProviderBackend，可以在sentry-site.xml中配置sentry.hive.provider.backend为SimpleDBProviderBackend来使用数据库存储策略</li></ul><p>它们三者的关系是：Provider 包含 Policy Engine 包含 Provider Backend</p><p>hasAccess方法内部调用了私有方法doHasAccess，其定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">doHasAccess</span><span class="params">(Subject subject,</span></span></div><div class="line"><span class="function"><span class="params">    List&lt;? extends Authorizable&gt; authorizables, Set&lt;? extends Action&gt; actions,</span></span></div><div class="line"><span class="function"><span class="params">    ActiveRoleSet roleSet)</span> </span>&#123;</div><div class="line">  <span class="comment">//获得用户的组信息</span></div><div class="line">  Set&lt;String&gt; groups =  getGroups(subject);</div><div class="line">  <span class="comment">//用户名集合</span></div><div class="line">  Set&lt;String&gt; users = Sets.newHashSet(subject.getName());</div><div class="line">  <span class="comment">//授权对象集合， 形如 table=student</span></div><div class="line">  Set&lt;String&gt; hierarchy = <span class="keyword">new</span> HashSet&lt;String&gt;();</div><div class="line">  <span class="keyword">for</span> (Authorizable authorizable : authorizables) &#123;</div><div class="line">    hierarchy.add(KV_JOINER.join(authorizable.getTypeName(), authorizable.getName()));</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//形如 table=student-&gt;select的数组</span></div><div class="line">  List&lt;String&gt; requestPrivileges = buildPermissions(authorizables, actions);</div><div class="line">  <span class="comment">//使用policy engine获取用户，角色对应的权限集合,此时读取数据库或策略文件</span></div><div class="line">  Iterable&lt;Privilege&gt; privileges = getPrivileges(groups, users, roleSet,</div><div class="line">      authorizables.toArray(<span class="keyword">new</span> Authorizable[<span class="number">0</span>]));</div><div class="line">  lastFailedPrivileges.get().clear();</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (String requestPrivilege : requestPrivileges) &#123;</div><div class="line">    <span class="comment">//将形如table=student-&gt;select的字符串创建成Privilege对象，用于权限验证</span></div><div class="line">    Privilege priv = privilegeFactory.createPrivilege(requestPrivilege);</div><div class="line">    <span class="keyword">for</span> (Privilege permission : privileges) &#123;</div><div class="line">      <span class="comment">/*</span></div><div class="line"><span class="comment">       * Does the permission granted in the policy file imply the requested action?</span></div><div class="line"><span class="comment">       */</span></div><div class="line">      <span class="keyword">boolean</span> result = permission.implies(priv, model);</div><div class="line">      <span class="keyword">if</span> (LOGGER.isDebugEnabled()) &#123;</div><div class="line">        LOGGER.debug(<span class="string">"ProviderPrivilege &#123;&#125;, RequestPrivilege &#123;&#125;, RoleSet &#123;&#125;, Result &#123;&#125;"</span>,</div><div class="line">            <span class="keyword">new</span> Object[]&#123; permission, requestPrivilege, roleSet, result&#125;);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">if</span> (result) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  lastFailedPrivileges.get().addAll(requestPrivileges);</div><div class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>permission.implies(priv, model);是最终的权限验证步骤，调用的是Privilege的该方法，在此处，是Privilege的一个实现类CommonPrivilege，它通过传入一个字符串进行构造，将其解析为一个KeyValue的List，然后在implies方法中使用它来进行权限的验证，implies方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">implies</span><span class="params">(Privilege privilege, Model model)</span> </span>&#123;</div><div class="line">  <span class="comment">// By default only supports comparisons with other IndexerWildcardPermissions</span></div><div class="line">  <span class="keyword">if</span> (!(privilege <span class="keyword">instanceof</span> CommonPrivilege)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  List&lt;KeyValue&gt; otherParts = ((CommonPrivilege) privilege).getParts();</div><div class="line">  <span class="keyword">if</span>(parts.equals(otherParts)) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> index = <span class="number">0</span>;</div><div class="line">  <span class="keyword">for</span> (KeyValue otherPart : otherParts) &#123;</div><div class="line">    <span class="comment">// If this privilege has less parts than the other privilege, everything</span></div><div class="line">    <span class="comment">// after the number of parts contained</span></div><div class="line">    <span class="comment">// in this privilege is automatically implied, so return true</span></div><div class="line">    <span class="comment">//这里的含义是，如果用户对table拥有权限，当前访问的对象(other)为column，则用户默认拥有对column的权限，粗粒度的权限包含了细粒度的权限</span></div><div class="line">    <span class="keyword">if</span> (parts.size() - <span class="number">1</span> &lt; index) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      KeyValue part = parts.get(index);</div><div class="line">      String policyKey = part.getKey();</div><div class="line">      <span class="comment">// are the keys even equal</span></div><div class="line">      <span class="keyword">if</span>(!policyKey.equalsIgnoreCase(otherPart.getKey())) &#123;</div><div class="line">        <span class="comment">// Support for action inheritance from parent to child</span></div><div class="line">        <span class="keyword">if</span> (SentryConstants.PRIVILEGE_NAME.equalsIgnoreCase(policyKey)) &#123;</div><div class="line">          <span class="keyword">continue</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      <span class="comment">// do the imply for action</span></div><div class="line">      <span class="keyword">if</span> (SentryConstants.PRIVILEGE_NAME.equalsIgnoreCase(policyKey)) &#123;</div><div class="line">        <span class="keyword">if</span> (!impliesAction(part.getValue(), otherPart.getValue(), model.getBitFieldActionFactory())) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (!impliesResource(model.getImplyMethodMap().get(policyKey.toLowerCase()),</div><div class="line">                part.getValue(), otherPart.getValue())) &#123;</div><div class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line"></div><div class="line">      index++;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// If this privilege has more parts than the other parts, only imply it if</span></div><div class="line">  <span class="comment">// all of the other parts are wildcards</span></div><div class="line">  <span class="comment">//如果该用户有更细粒度的权限，只有其权限为*时，才让其通过验证</span></div><div class="line">  <span class="keyword">for</span> (; index &lt; parts.size(); index++) &#123;</div><div class="line">    KeyValue part = parts.get(index);</div><div class="line">    <span class="keyword">if</span> (!SentryConstants.PRIVILEGE_WILDCARD_VALUE.equals(part.getValue())) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>至此，权限的验证已经分析完成了，sentry在最终验证权限之前才根据用户的组、角色从数据库中读取其拥有的权限，并与需要的权限进行比对，用户信息的读取是在Policy backend中进行的，Policy provider层屏蔽了不同组件的权限分类，使用通用的形式进行验证，可以进行重复使用。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本文分析了Sentry是如何对HiveServer2进行用户的细粒度访问控制的，并详细介绍了从session hook设置用户信息，到Policy backend读取用户已有权限的代码逻辑，对sentry的工作原理和流程有了初步的认识。其鉴权的本质是将用户已有的权限与访问对象所需权限进行比对，如果全部满足，或者用户已有权限更加粗粒度，此时认为该用户拥有其资源的访问权限，可以理解为权限字符串的比对。sentry通过一个通用的Policy Provider来对屏蔽不同组件的权限对象的差异性，达到了一个通用模块来进行权限验证的目的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Sentry是Hadoop生态中的一员，扮演着“守门人”的角色，看守着大数据平台的数据安全的访问。它以Plugin的形式运行于组件中，通过关系型数据库（PostgreSQL、MySQL）或本地文件来存取访问策略，对数据使用者提供细粒度的访问控制。本文试图在源码层剖析Sentry的鉴权过程，以帮助更好的理解权限的鉴定过程。博客地址&lt;a href=&quot;http://www.wangjialong.cc/2018/01/04/sentry_authorize/#more&quot;&gt;Sentry源码之HiveServer2鉴权过程&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/tags/hadoop/"/>
    
      <category term="sentry" scheme="http://www.wangjialong.cc/tags/sentry/"/>
    
      <category term="细粒度访问控制" scheme="http://www.wangjialong.cc/tags/%E7%BB%86%E7%B2%92%E5%BA%A6%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>TreeMap源码阅读</title>
    <link href="http://www.wangjialong.cc/2017/12/19/TreeMap_info/"/>
    <id>http://www.wangjialong.cc/2017/12/19/TreeMap_info/</id>
    <published>2017-12-18T16:00:00.000Z</published>
    <updated>2018-01-20T02:03:40.309Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TreeMap算是要分析的Map家族中的最后一个成员了，它是AbstractMap的子类，并实现了NavigableMap接口，是Map家族中比较特殊的，支持元素排序插入的Map集合类。博客原文地址<a href="http://www.wangjialong.cc/2017/12/19/TreeMap_info/#more">TreeMap源码阅读</a></p><a id="more"></a><h1 id="TreeMap简介"><a href="#TreeMap简介" class="headerlink" title="TreeMap简介"></a>TreeMap简介</h1><p>TreeMap的类图如下：</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-12-18/6367000.jpg" alt=""></p><ul><li>虚线箭头代表的是实现接口；实线箭头代表的是继承关系</li></ul><p>由上图所示，它是AbstractMap的子类，因此就具备了一个普通Map的全部操作，如put、get、containsKey等方法，同时，它也实现了NavigableMap，由图中关系，NavigableMap是SortedMap的子接口，所以NavigableMap具备排序功能，且有它的名字可知，它也具备点查询(Navigable)功能。下面简单介绍一下NavigableMap。</p><h2 id="NavigableMap"><a href="#NavigableMap" class="headerlink" title="NavigableMap"></a>NavigableMap</h2><p>NavigableMap在SortedMap的基础上，增加了一些navigation方法，比如说lowerEntry、floorEntry、ceilingEntry和higherEntry，它们传入的参数都是一个键，类型为泛型K，返回值都为一个Map.Entry对象。这四个方法分别返回小于、小于或等于、大于或等于、大于传入的key的最接近的Entry，也就是说floorEntry方法，如果有小于key的entry1和等于key的entry2，则返回entry2。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>根据名字也可猜出，TreeMap的存储结构为树，树的节点为一个内部类Entry，它是Map.Entry的一个子类。它的属性包含了key,value,指向左兄弟节点的left和指向右兄弟节点的right，指向父节点的parent，表示颜色的布尔值color(为true表示黑色，false表示红色)，因此可知TreeMap是一个红黑树。在HashMap的分析中，1.8之后也增加了红黑树的实现，在此可以进行一下对比。TreeMap中没有指向前一个节点的prev指针，这比较容易理解，HashMap中红黑树是对开链法形成的大于8个节点的链表所进行的，其原型还是链表，只是通过增加了指针形成了红黑树，当节点小于8时，还需要进行untreeify，因此指向前一个节点的指针存储的为链表信息。而TreeMap本身就是树状结构，因此不需要保存链表信息的prev属性。另一个区别是TreeMap中表示颜色的属性为color，虽然也为布尔值，但它的赋值是通过定义好的两个常量进行的，常量定义如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED   = <span class="keyword">false</span>;</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">true</span>;</div></pre></td></tr></table></figure></p><p>修改颜色时将对应的常量赋值给color属性即可，这样的定义方式更加形象、直观。至于区别的原因，暂时理解为不同contributor的编程习惯。TreeMap的内部类Entry实现非常简单，只是实现了getValue、getKey、setValue、equals和hashCode方法。其中equals方法首先要求传入的为Map.Entry子对象，其次要求key和value同时相等时才返回true。hashCode返回的为key，value的hashCode的异或值。由于Entry的实现简洁，树的结构操作都放在了TreeMap的方法中，因此不禁产生疑问，TreeMap是如何进行插入和查询的呢？</p><p>带着疑问先来看get方法，其核心为getEntry方法，代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="comment">// Offload comparator-based version for sake of performance</span></div><div class="line">    <span class="keyword">if</span> (comparator != <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> getEntryUsingComparator(key);</div><div class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">    Entry&lt;K,V&gt; p = root;</div><div class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">int</span> cmp = k.compareTo(p.key);</div><div class="line">        <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">            p = p.right;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>getEntry实现的是二叉搜索树的查找算法，也就是与当前节点的key值比较，如果小于，则在左子树中遍历查找，大于的话则在右子树查找，等于返回当前节点。这里需要注意的是，为了查找的性能，这里有一个判断语句，如果comparator不为空，则调用了getEntryUsingComparator方法，该方法的实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntryUsingComparator</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">        K k = (K) key;</div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = root;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">int</span> cmp = cpr.compare(k, p.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                p = p.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                p = p.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> p;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到，在算法上，此方法仍然使用的是二叉搜索树的查找算法，因此在性能上不会有提升，它的性能提高主要体现在comparator的比较算法上，但大多数情况下comparator的比较算法不会有太大差别，本方法的存在只是为了以防万一。由此，get方法实现的是二叉搜索树的标准查找算法，下面分析put方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    Entry&lt;K,V&gt; t = root;</div><div class="line">    <span class="comment">//TreeMap为空</span></div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</div><div class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></div><div class="line"></div><div class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</div><div class="line">        size = <span class="number">1</span>;</div><div class="line">        modCount++;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">int</span> cmp;</div><div class="line">    Entry&lt;K,V&gt; parent;</div><div class="line">    <span class="comment">// split comparator and comparable paths</span></div><div class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</div><div class="line">    <span class="comment">//使用comparator进行比较</span></div><div class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = cpr.compare(key, t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key为Comparable，使用key.compareTo比较</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">            Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</div><div class="line">        <span class="keyword">do</span> &#123;</div><div class="line">            parent = t;</div><div class="line">            cmp = k.compareTo(t.key);</div><div class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">                t = t.left;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</div><div class="line">                t = t.right;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                <span class="keyword">return</span> t.setValue(value);</div><div class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</div><div class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</div><div class="line">        parent.left = e;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        parent.right = e;</div><div class="line">    <span class="comment">//修复以使得插入后仍然满足红黑树的特性</span></div><div class="line">    fixAfterInsertion(e);</div><div class="line">    size++;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>put方法的算法比价清晰，首先查找key值，如果找到了则用新值替换旧值，否则，在合适的位置插入一个新的Entry。由于TreeMap为红黑树，因此需要在插入节点之后进行fix操作，以使得插入后的仍然满足红黑树的特性，该方法为fixAfterInsertion,其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** From CLR */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    <span class="comment">//x为新插入的节点，赋为红色</span></div><div class="line">    x.color = RED;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</div><div class="line">        <span class="comment">//父节点为祖父节点的左子节点</span></div><div class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</div><div class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</div><div class="line">            <span class="comment">//叔叔节点为红色</span></div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(y, BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                x = parentOf(parentOf(x));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//x为右子节点，x.parent为左子节点，需要两次旋转进行调整</span></div><div class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);</div><div class="line">                    rotateLeft(x);</div><div class="line">                &#125;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                rotateRight(parentOf(parentOf(x)));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</div><div class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(y, BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                x = parentOf(parentOf(x));</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</div><div class="line">                    x = parentOf(x);</div><div class="line">                    rotateRight(x);</div><div class="line">                &#125;</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(parentOf(parentOf(x)), RED);</div><div class="line">                rotateLeft(parentOf(parentOf(x)));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    root.color = BLACK;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>方法的注释<code>From CLR</code>表示的是直接使用了C#中相应的代码，stackOverflow上有篇回答比较详细，感兴趣的可以看一下 <a href="https://stackoverflow.com/questions/38482750/from-clr-in-java-treemap-implementation" target="_blank" rel="external">/<em>From CLR</em>/  Java TreeMap implementation</a></li></ul><p>上面代码加上了必要的注释，总的来说就是分为下面几步解决红黑树的平衡问题：</p><ol><li>新插入的节点设为红色</li><li>通过循环，从新插入节点向上遍历，解决冲突，循环的终止条件是x.parent.color = BLACK,这里有一个隐含条件就是x.color = RED，因此当x的父节点为黑色时，红黑树已经调整完毕，其他的跳出循环为边界情况</li><li>循环中，根据x父节点是否为其祖父节点的左子节点分成了两个分支，在各自的分支中，根据x叔父节点是否为红色，又分为两个分支，为红色时不需要进行旋转，当前结构平衡，只需要进行颜色的修改；不为红色时，需要通过旋转来保持红黑树的平衡。这里的算法可以参考博客<a href="https://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">红黑树数据结构剖析</a></li></ol><p>这里可以对照我的另一篇关于HashMap的博客<a href="http://www.wangjialong.cc/2017/12/07/hashmap_info/#more">HashMap解析</a>，其中也有红黑树的相关实现，其算法一致，只是TreeMap中的更加直观，也更加具有语义化，比较容易理解。</p><p>get、put之后，我们来分析一下查询方法，get方法实际也有查询的作用，但由于containsValue方法并没有使用get方法，因此单独分析一下，这里也比较容易理解，因为TreeMap的节点是通过key的大小来进行排序的，因此查询value的存在时，不能通过二叉搜索算法来查询，只能通过遍历的方式，时间复杂度为Ω(n)。containsValue定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = getFirstEntry(); e != <span class="keyword">null</span>; e = successor(e))</div><div class="line">        <span class="keyword">if</span> (valEquals(value, e.value))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>getFirstEntry方法返回树的最左边的叶子节点，也就是key最小的节点</li><li>successor(e)返回e的下一个节点，也就是key值紧挨着e.key，且大于e.key的节点</li></ul><p>算法首先找到树中最左边叶子节点，然后successor每次返回当前节点的下一个节点，遍历整个树，直到找到该值或者到达树的最后一个节点。由于successor方法的时间复杂度并不是O(1)的，因此containsValue的时间复杂度大于n，又由于红黑树是二叉平衡树，因此successor时间复杂度不会到达O(n)的级别，因此containsValue的时间复杂度为Ω(n)。successor方法的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; TreeMap.<span class="function">Entry&lt;K,V&gt; <span class="title">successor</span><span class="params">(Entry&lt;K,V&gt; t)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="comment">//如果t有右子树，则返回其右子树中的最左边的叶子节点</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (t.right != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; p = t.right;</div><div class="line">        <span class="keyword">while</span> (p.left != <span class="keyword">null</span>)</div><div class="line">            p = p.left;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//t不存在右子树，需要向上遍历，找到t为左子节点的第一个父节点</span></div><div class="line">        Entry&lt;K,V&gt; p = t.parent;</div><div class="line">        Entry&lt;K,V&gt; ch = t;</div><div class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; ch == p.right) &#123;</div><div class="line">            ch = p;</div><div class="line">            p = p.parent;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>算法比较简单，已经在注释中说明，在此不再赘述。</p><p>下面分析remove方法，由于remove方法带来了红黑树的结构变化，因此必然也涉及到了删除节点之后的fix过程。remove方法的核心部分为deleteEntry方法，其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    size--;</div><div class="line"></div><div class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></div><div class="line">    <span class="comment">// point to successor.</span></div><div class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</div><div class="line">        Entry&lt;K,V&gt; s = successor(p);</div><div class="line">        p.key = s.key;</div><div class="line">        p.value = s.value;</div><div class="line">        p = s;</div><div class="line">    &#125; <span class="comment">// p has 2 children，实际删除的对象变为successor(p)</span></div><div class="line"></div><div class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></div><div class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123; <span class="comment">//p有孩子节点</span></div><div class="line">        <span class="comment">// Link replacement to parent</span></div><div class="line">        replacement.parent = p.parent;</div><div class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</div><div class="line">            root = replacement;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</div><div class="line">            p.parent.left  = replacement;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p.parent.right = replacement;</div><div class="line"></div><div class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></div><div class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Fix replacement，p为黑色的时候，删除p会影响到路径上黑色节点的个数，需要进行fix操作</span></div><div class="line">        <span class="keyword">if</span> (p.color == BLACK)</div><div class="line">            fixAfterDeletion(replacement);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></div><div class="line">        root = <span class="keyword">null</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></div><div class="line">        <span class="keyword">if</span> (p.color == BLACK)</div><div class="line">            fixAfterDeletion(p);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (p == p.parent.left)</div><div class="line">                p.parent.left = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</div><div class="line">                p.parent.right = <span class="keyword">null</span>;</div><div class="line">            p.parent = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码中，要实现的是删除节点p，在删除的过程中，p的状态有三种情况:p有两个子节点、有一个子节点、没有子节点。</p><ol><li>p有两个子节点的时候，会找到p的右子树中最左边的节点n，将n的值覆盖掉p的值，此时实际删除的节点变成了n，n没有左子节点，因此将n的右子树的根节点nLeftRoot嫁接到n的位置即可。</li><li>p有一个子节点的时候，直接删除的节点为p，将p的左/右子树的根节点childRoot嫁接到p的位置</li><li>p没有子节点的时候，需要先进行调整，然后删除节点p</li></ol><p>红黑树调整也不是每次删除都会发生的，只有当删除的节点p为黑色的时候，会导致其所在路径上的黑色节点数少一个，此时需要进行调整，通过方法fixAfterDeletion来进行，其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** From CLR */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123; <span class="comment">//x所在路径黑色节点少一个</span></div><div class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123; <span class="comment">//x为红色，直接终止循环，将x设为黑色，调整完毕</span></div><div class="line">        <span class="comment">//x为左子节点</span></div><div class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</div><div class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123; <span class="comment">//如果叔父节点为红色，</span></div><div class="line">                setColor(sib, BLACK);</div><div class="line">                setColor(parentOf(x), RED);</div><div class="line">                rotateLeft(parentOf(x));</div><div class="line">                sib = rightOf(parentOf(x));</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//此时sib必为黑色，若sib的两个子节点都为黑色，则此路径上黑色节点数多1个</span></div><div class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</div><div class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</div><div class="line">                setColor(sib, RED); <span class="comment">//将sib设为红色，黑色节点数-1</span></div><div class="line">                x = parentOf(x); <span class="comment">//x为sib的兄弟节点，x设为x.parent，递归调整红黑树</span></div><div class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">//sib的子节点一红一黑</span></div><div class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123; <span class="comment">//若右子节点为黑色</span></div><div class="line">                    setColor(leftOf(sib), BLACK); <span class="comment">//设左子节点为黑色, sib为红色</span></div><div class="line">                    setColor(sib, RED);</div><div class="line">                    rotateRight(sib); <span class="comment">//右旋sib</span></div><div class="line">                    sib = rightOf(parentOf(x));</div><div class="line">                &#125;</div><div class="line">                setColor(sib, colorOf(parentOf(x)));</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(rightOf(sib), BLACK);</div><div class="line">                rotateLeft(parentOf(x));</div><div class="line">                x = root; <span class="comment">//彻底解决平衡问题，直接返回到root</span></div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></div><div class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</div><div class="line">                setColor(sib, BLACK);</div><div class="line">                setColor(parentOf(x), RED);</div><div class="line">                rotateRight(parentOf(x));</div><div class="line">                sib = leftOf(parentOf(x));</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</div><div class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</div><div class="line">                setColor(sib, RED);</div><div class="line">                x = parentOf(x);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</div><div class="line">                    setColor(rightOf(sib), BLACK);</div><div class="line">                    setColor(sib, RED);</div><div class="line">                    rotateLeft(sib);</div><div class="line">                    sib = leftOf(parentOf(x));</div><div class="line">                &#125;</div><div class="line">                setColor(sib, colorOf(parentOf(x)));</div><div class="line">                setColor(parentOf(x), BLACK);</div><div class="line">                setColor(leftOf(sib), BLACK);</div><div class="line">                rotateRight(parentOf(x));</div><div class="line">                x = root;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    setColor(x, BLACK);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>该方法传入节点x，由删除方法的触发条件可知，本方法需要解决的问题是，由于x节点的删除，该节点所在的路径上黑色节点数少了一个，因此需要恢复从根节点到x节点上的黑色节点数，使其加一，这样才能恢复树的平衡状态。算法通过一个while循环来进行调整，终止条件为x到达根节点或者x的颜色为红色。x到达根节点时，直接将其设为黑色，方法返回，这比较好理解，因为到达根节点时说明下面各层的颜色调整结束，整棵树满足红黑树。而x为红色时，为什么也可以跳出呢？因为要调整的是x所在路径上的黑色节点数+1，因此如果x为红色的话，只需要将x设置为黑色，则其所在路径上黑色节点数达到要求，因此整棵树也达到了平衡状态。</p><p>算法的解释通过注释在上面进行了必要的解释，具体算法可以参考<a href="https://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">红黑树数据结构剖析</a>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TreeMap中很多东西和HashMap中的一部分东西非常类似，这是因为HashMap在开链法的链表长度大于8的时候，会将链表树化为一个红黑树，因此TreeMap中的插入，删除相当于HashMap中树化的插入、删除。但它们两者也大有不同，一个区别就是TreeMap是一个排序的map，可以通过指定comparator来指定排序规则，而HashMap中树化的比较是通过key的hashCode来进行的，且HashMap首先是一个Hash表，其次bucket对应的链表才是一个红黑树，因此HashMap可以理解为O(1)时间内查找到key值，而TreeMap是一个排序的Map，如果需要维护一个排好序的map时，可以使用TreeMap，且由于红黑树的性质，它可以保证O(logn)的时间内查找到你需要定位的Entry（通过key值来进行比较）。</p><blockquote><p>live long and prosper</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;TreeMap算是要分析的Map家族中的最后一个成员了，它是AbstractMap的子类，并实现了NavigableMap接口，是Map家族中比较特殊的，支持元素排序插入的Map集合类。博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2017/12/19/TreeMap_info/#more&quot;&gt;TreeMap源码阅读&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="Collection" scheme="http://www.wangjialong.cc/tags/Collection/"/>
    
      <category term="TreeMap" scheme="http://www.wangjialong.cc/tags/TreeMap/"/>
    
  </entry>
  
  <entry>
    <title>HashMap1.8源码解读</title>
    <link href="http://www.wangjialong.cc/2017/12/07/hashmap_info/"/>
    <id>http://www.wangjialong.cc/2017/12/07/hashmap_info/</id>
    <published>2017-12-06T16:00:00.000Z</published>
    <updated>2018-01-20T02:04:27.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>HashMap和HashTable可以说是Map家族中最常用的两个类了，而两者又都是通过Hash表来进行key值的映射的，因此选择将两者进行统一的比较分析，并借此了解jdk中是如何实现hash表结构的map对象的。这篇博客篇幅较长，但我觉得有很多是很有用的知识，希望读者可以耐心阅读。博客原文地址<a href="http://www.wangjialong.cc/2017/12/07/hashmap_info/#more">HashMap1.8源码解读</a></p><a id="more"></a><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><p>HashMap是Map的一个Hash表类型的实现，由于Hash表的常数时间内的寻址特性，使得HashMap可以在常数的时间内执行get(key), set(key, value)方法。HashMap支持存储key和value为null的元素。</p><p>HashMap有两个非常重要的初始化参数：initial capacity和load factor。initial capacity决定了存储hash(key)的返回值的bucket。因为HashMap是使用了数组加链表的形式进行元素的存储的（1.8之后增加了红黑树的支持，当链表长度大于8之后，会将链表进行<strong>树化</strong>）。</p><p>load factor是另一个重要的指标，它标示了这个HashMap什么时候需要扩容，默认值是0.75.举个例子，假如初始容量为100，则当hash(key)的返回值达到75个的时候，该HashMap需要扩容，并rehash，扩容后的大小是扩容前的两倍。load factor只和填充的bucket有关，而和该bucket对应的存储了多少个Node无关，即使该bucket只存了一个，也会将填充数+1。因此，如过initial capacity * load facotr &gt; entry数量，则HashMap不会进行rehash。因此，如果预先知道entry的数量，计算相应的capacity值，有利于提高存取效率。</p><p>HashMap不是一个同步类，如果需要进行多线程的访问，可以考虑三种方式</p><ol><li>使用 <code>Map m = Collections.synchronizedMap(new HashMap(...));</code></li><li>使用HashTable，同步类</li><li>使用ConcurrentHashMap</li></ol><p>如果有高并发读的需求，强烈建议使用ConcurrentHashMap，它是无锁读的。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><h2 id="bucket长度与Hash函数"><a href="#bucket长度与Hash函数" class="headerlink" title="bucket长度与Hash函数"></a>bucket长度与Hash函数</h2><p>HashMap是通过一个内部类Node类存取K/V值的，该Node包含了4个属性：hash,key,value,next。hash存的就是key值经过Hash之后的返回值，HashMap通过hash字段，快速的定位该node； key值就是K/V中的键，value就是K/V中的值，next指向了链表中下一个节点（先分析数组+链表的存储结构，之后分析红黑树，红黑树的节点为TreeNode）。</p><p>Node的equals方法比较重要，它决定了HashMap中存储新的的K/V对时，原来的Node中是否有与新的K/V对相同，如果equals为真，则覆盖原来的值，否则，new一个新的Node。equals方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)           </div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</div><div class="line">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div class="line">        <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</div><div class="line">            Objects.equals(value, e.getValue()))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>有代码可知，先判断引用是否一致，如果相同，则返回true，然后判断是否为Map.Entry的一个子类，之后判断K/V是否同时相同，如果是，则返回true，否则，返回false。这段判断是否相同的逻辑，对于Set中的元素也使用，因为Set也是使用Map来存储元素的。</li></ul><p>HashMap通过一个Node数组来表示存储hash(key)的bucket入口，默认大小为16.这个数字比较特别，是2的4次方，bucket的大小必须是2的整数次幂,这样做的好处是，length-1正好是低x位均为1，起到一个掩码的作用，而掩码的作用与求余相同。如初始长度16，-1后的二进制为1111，和hash值进行与操作，相当于hash值对16求余。这个求余操作用于将hash值映射到Node数组的空间中，在寻找key对应的bucket时，只需要table[(length-1) &amp; hash(key)]即可，然后遍历其指向的链表即可找到K/V对。HashMap为了保证容量为2的整数次幂，使用了一个方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><ul><li>该方法很好理解，将cap-1的二进制数为1的最高位以下的所有位置为1，然后加1，则为一个形如00100000的数。</li></ul><p>上面提到了hash函数，HashMap的hash函数比较简单，只是简单的将key的高16位与低16位进行位异或即可。这是一个扰动函数，为了防止低16位数的规律性。原因是，由于Node数组长度有限，无法对应hash函数的返回值，而hash函数低x位有可能有一定的规律性，为了减少其低16位的规律性，又因为高16位在求数组index中永远不会用到，因此，选择将高16位直接与低16位做异或，将高16位作为一个扰动信号，维持hash函数的散列性。</p><h2 id="put、get源码解读"><a href="#put、get源码解读" class="headerlink" title="put、get源码解读"></a>put、get源码解读</h2><p>下面着重分析put(key,value)和get(key)这两个方法。</p><p>put的核心方法是putVal方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">//table为空，需要初始化</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">//bucket入口为空，直接new一个Node，放到数组的对应坐标处</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="comment">//hash值冲突，开链法解决冲突</span></div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">//链表第一个节点就是要put的key，赋值给e</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">//链表长度大于8，已经被树化</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="comment">//到达链表末尾，将k/v对添加到最后</span></div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//大于阈值，进行树化</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//链表中已存在key值</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//该key值已存在</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key值不存在，已添加进HashMap</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>首先介绍参数，后两个为布尔值，作为flag，表示存储策略，onlyIfAbsent为true的时候，put方法检测到已有值时不会覆盖，evict为false的时候，Hash表处于创建，初始化时刻。hash，key,value分别对应Node中的对应属性。</p><p>在上面的代码段中已经添加了必要的注释，最终的结果只有两种。一、key值已存在，根据策略替换原值，返回oldValue；二、key值不存在，找到一个合适的位置插入，返回null。为了达到最后的结果，大致有以下几个步骤：</p><ol><li>判断table是否为空，若为空，则执行resize方法，根据初始容量，初始化table数组</li><li>根据key值运算后的hash值，与数组长度求余(通过(n-1)掩码与运算求余)，找到在数组中的index，如果该index对应的为null，则将新的k/v插入到该位置，相当于一个bucket的入口，由此可知，resize只是初始化数组，并没有给数组中的Node进行初始化，因此index位置仍为空</li><li>如果bucket的入口非空，则表示Hash冲突，对应的链表长度&gt;=1，需要通过开链法解决冲突。有三个判断逻辑：链表头节点key值与添加的key值相等；链表已经树化，需要搜索红黑树查找该key值是否已存在；链表未被树化，且头节点key值与新增key值不同，需要遍历链表查找该key值是否存在。</li><li>上面的判断逻辑中，不管是哪一种，只要key值已存在，则赋值给e，因此在后面判断e是否为null，若不为空，则表示已存在，根据策略决定是否覆盖原值</li><li>如果key值不存在，需要将modCount自增1，然后将size自增，判断大小是否超过阈值，是，则通过resize方法double原table数组的容量。</li></ol><p>在上面的代码块中，有两个方法比较有趣，afterNodeAccess和afterNodeInsertion方法，它们在HashMap中代码段为空，它们的作用主要是为了让LinkedHashMap继承，这样的话，LinkedHashMap不需要重写putVal方法，而只需要重写afterNodeAccess和afterNodeInsertion方法即可，因为LinkedHashMap需要保证HashMap的顺序，因此需要在putVal之后进行顺序的调整，就是通过上面的两个方法执行顺序调整的。这个编程思想让我十分受用，父类定义了方法的流程，在此为putVal方法的流程，而对于父类中不需要的操作，通过将方法体书写为空，对父类的操作不会影响，而对于子类(LinkedHashMap)，只需要重写那两个为空的方法，即可完成功能的增强(在此为保证Map的顺序，也就是key值插入的顺序)。</p><blockquote><p><a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="external">LinkedHashMap</a>是一个HashMap和double linklist的结合体，它保证的顺序为key值put的顺序</p></blockquote><p>下面分析TreeNode的putTreeVal方法，它是putVal的树化版。它遍历红黑树以寻找是否已经存在要插入的key值，若存在，则返回该节点，否则，在合适的位置插入节点，并返回null.要分析putTreeVal,首先需要搞清楚TreeNode的结构，其定义如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></div><div class="line">    TreeNode&lt;K,V&gt; left;</div><div class="line">    TreeNode&lt;K,V&gt; right;</div><div class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></div><div class="line">    <span class="keyword">boolean</span> red;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><blockquote><p>红黑树的特性</p><ol><li>根结点是黑的。</li><li>每个结点要么是红的，要么是黑的</li><li>如果一个结点是红的，那么它的俩个儿子都是黑的</li><li>任意从根到叶子的路径的黑色节点总数相同。</li><li>本质上是二叉搜索树，左子树节点小于当前节点，右子树节点大于当前节点</li></ol></blockquote><p>上面是典型的红黑树节点定义，包含了指向父节点的指针parent，左子节点left，右子节点right, red表示当前节点是否为红色。</p><p>下面来分析putTreeVal方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">putTreeVal</span><span class="params">(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab,</span></span></div><div class="line"><span class="function"><span class="params">                               <span class="keyword">int</span> h, K k, V v)</span> </span>&#123;</div><div class="line">    Class&lt;?&gt; kc = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> searched = <span class="keyword">false</span>;</div><div class="line">    <span class="comment">//找到红黑树的根节点</span></div><div class="line">    TreeNode&lt;K,V&gt; root = (parent != <span class="keyword">null</span>) ? root() : <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = root;;) &#123;</div><div class="line">        <span class="keyword">int</span> dir, ph; K pk;</div><div class="line">        <span class="comment">//当前节点hash大于h,在左节点查找</span></div><div class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">            dir = -<span class="number">1</span>;</div><div class="line">        <span class="comment">////当前节点hash小于h,在右节点查找</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">            dir = <span class="number">1</span>;</div><div class="line">        <span class="comment">//ph == h 且 p.key == k</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</div><div class="line">            <span class="keyword">return</span> p;</div><div class="line">        <span class="comment">// K不是Comparable的实现类 或 pk的类型 不是Comparable的实现类</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</div><div class="line">                  (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</div><div class="line">                 (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (!searched) &#123;</div><div class="line">                TreeNode&lt;K,V&gt; q, ch;</div><div class="line">                searched = <span class="keyword">true</span>;</div><div class="line">                <span class="comment">//递归的在左右子树中查找h, k</span></div><div class="line">                <span class="keyword">if</span> (((ch = p.left) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>) ||</div><div class="line">                    ((ch = p.right) != <span class="keyword">null</span> &amp;&amp;</div><div class="line">                     (q = ch.find(h, k, kc)) != <span class="keyword">null</span>))</div><div class="line">                    <span class="keyword">return</span> q;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// dir = -1 / 1</span></div><div class="line">            dir = tieBreakOrder(k, pk);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        TreeNode&lt;K,V&gt; xp = p;</div><div class="line">        <span class="comment">//到达叶子节点，没有找到key值，插入新节点</span></div><div class="line">        <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</div><div class="line">            Node&lt;K,V&gt; xpn = xp.next; <span class="comment">//next属性位于HashMap.Node中，在此进行设置，主要是为了方便红黑树和链表之间的转换</span></div><div class="line">            TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn);</div><div class="line">            <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</div><div class="line">                xp.left = x;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                xp.right = x;</div><div class="line">            xp.next = x;</div><div class="line">            x.parent = x.prev = xp;</div><div class="line">            <span class="keyword">if</span> (xpn != <span class="keyword">null</span>)</div><div class="line">                ((TreeNode&lt;K,V&gt;)xpn).prev = x;</div><div class="line">            <span class="comment">//插入，并重新平衡红黑树，并确保root节点为bucket的第一个节点</span></div><div class="line">            moveRootToFront(tab, balanceInsertion(root, x));</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>我在上面的代码块中添加了必要的代码注释，相信重要的代码分支的含义已经比较清晰。总的来说，putTreeVal方法通过一个循环，从root节点寻找红黑树中是否已存在要插入的key值，最后的结果只有两种，一是找到了，则返回该key值对应的在树中的节点；而是没有找到，此时新建TreeNode，并将其插入到红黑树中，返回null。这里的逻辑与链表插入的逻辑相同，返回null后，通过判断即可得知新增的key值成功插入，且之前不存在。红黑树中查找节点的算法比较简单，和二叉搜索树相同，如果key小于当前节点key，则到左子树查找；大于则到右子树查找，直到找到key值或者到达叶子节点。遍历的方向通过dir表示，-1表示向左子树遍历，1表示向右子树遍历。方法中比较key值得逻辑有几块，主要是满足泛型需要的，key的比较方式有四种：</p><ol><li>通过 &lt;,=,&gt; 比较运算符直接比较；</li><li>通过Object的equals方法比较是否相同，通过Comparable的compareTo比较返回-1或1；</li><li>若key不为Comparable的实现类，则通过find方法查找该key值，find方法只会遍历树一次(searched置为true后，不调用)</li><li>如果上面的方法都没法进行key值得比较，调用tieBreakOrder方法，通过内部System.identityHashCode(key)进行比较，返回-1或者1</li></ol><p>最终如果没有找到key值，则new一个TreeNode，进行插入。此处的插入是要满足红黑树的特性的，因此在balanceInsertion(root, x)中插入了x，并整理该树以满足红黑树的性质，返回之后的根节点。moveRootToFront方法将返回的根节点确保其位于tab的对应index位置，也就是确保根节点位于bucket的入口处。</p><p>balanceInsertion方法插入节点x，并平衡红黑树，其代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;K,V&gt; <span class="function">TreeNode&lt;K,V&gt; <span class="title">balanceInsertion</span><span class="params">(TreeNode&lt;K,V&gt; root,</span></span></div><div class="line"><span class="function"><span class="params">                                            TreeNode&lt;K,V&gt; x)</span> </span>&#123;</div><div class="line">    x.red = <span class="keyword">true</span>;</div><div class="line">    <span class="keyword">for</span> (TreeNode&lt;K,V&gt; xp, xpp, xppl, xppr;;) &#123;</div><div class="line">        <span class="comment">// x 为根节点</span></div><div class="line">        <span class="keyword">if</span> ((xp = x.parent) == <span class="keyword">null</span>) &#123;</div><div class="line">            x.red = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> x;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// x的父节点为黑色节点 或 x的父节点为根节点</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!xp.red || (xpp = xp.parent) == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> root;</div><div class="line">        <span class="comment">// x的父节点为其父节点的左子节点</span></div><div class="line">        <span class="keyword">if</span> (xp == (xppl = xpp.left)) &#123;</div><div class="line">            <span class="comment">//x的叔父节点也为红色节点，不能通过旋转解决颜色冲突，直接通过改变颜色，但改变之后的xpp与其父节点都为红色，在下一次循环中解决冲突</span></div><div class="line">            <span class="keyword">if</span> ((xppr = xpp.right) != <span class="keyword">null</span> &amp;&amp; xppr.red) &#123;</div><div class="line">                xppr.red = <span class="keyword">false</span>;</div><div class="line">                xp.red = <span class="keyword">false</span>;</div><div class="line">                xpp.red = <span class="keyword">true</span>;</div><div class="line">                x = xpp;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//与父节点颜色冲突，都为红色</span></div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">// x 是xp的右子节点， xp是xpp的左子节点，此时需要两次旋转，先左旋，后右旋</span></div><div class="line">                <span class="keyword">if</span> (x == xp.right) &#123;</div><div class="line">                    <span class="comment">//左旋</span></div><div class="line">                    root = rotateLeft(root, x = xp);</div><div class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line">                    xp.red = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line">                        xpp.red = <span class="keyword">true</span>; <span class="comment">//右旋后xpp成为xp的右子节点，应该变为红色</span></div><div class="line">                        root = rotateRight(root, xpp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (xppl != <span class="keyword">null</span> &amp;&amp; xppl.red) &#123;</div><div class="line">                xppl.red = <span class="keyword">false</span>;</div><div class="line">                xp.red = <span class="keyword">false</span>;</div><div class="line">                xpp.red = <span class="keyword">true</span>;</div><div class="line">                x = xpp;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (x == xp.left) &#123;</div><div class="line">                    root = rotateRight(root, x = xp);</div><div class="line">                    xpp = (xp = x.parent) == <span class="keyword">null</span> ? <span class="keyword">null</span> : xp.parent;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (xp != <span class="keyword">null</span>) &#123;</div><div class="line">                    xp.red = <span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">if</span> (xpp != <span class="keyword">null</span>) &#123;</div><div class="line">                        xpp.red = <span class="keyword">true</span>;</div><div class="line">                        root = rotateLeft(root, xpp);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>上面代码块已经加入了我自己的理解，这里主要是通过插入后，判断是否与父节点颜色冲突(均为红色)，然后通过二叉树的旋转来保持平衡，旋转的策略分为了左旋和右旋，主要根据插入节点、父亲节点、祖父节点的关系决定，具体规则可以参考<a href="https://www.cnblogs.com/fanzhidongyzby/p/3187912.html" target="_blank" rel="external">红黑树数据结构剖析</a>，写的比较详细。</p><p>到此终于把putVal方法分析完了，小小的一个put方法牵扯了这么多的知识，包含了开链法解决Hash冲突，链表插入，红黑树的插入以及每种插入前的查找。既然在此分析到了TreeNode，就小结一下，TreeNode实现的是红黑树的数据结构，在其中包含了插入、删除、查找、split方法，其中插入、删除、查找比较好理解，split方法主要是用在HashMap的resize中，通过将红黑树分为lower和upper两个红黑树，放置到相应的两个bucket处。</p><p>分析完put方法，下面分析get方法，有了put的铺垫，get相对来说就简单一些了。getNode是get的核心方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>); <span class="comment">//do-while遍历链表</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>逻辑就比较简单了，首先判断第一个节点是否为要找的key值，然后如果是链表形态，则do-while结构遍历链表；如果是红黑树形态，则调用getTreeNode查找并返回对应的TreeNode。getTreeNode的方法调用了TreeNode的find方法，其定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</div><div class="line">    TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">int</span> ph, dir; K pk;</div><div class="line">        TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q;</div><div class="line">        <span class="keyword">if</span> ((ph = p.hash) &gt; h)</div><div class="line">            p = pl;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</div><div class="line">            p = pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (k != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</div><div class="line">            <span class="keyword">return</span> p;  <span class="comment">//上面三个判断时通过&gt;, &lt;, = 比较符号进行比较的</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</div><div class="line">            p = pr;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</div><div class="line">            p = pl;    <span class="comment">//上面两个判断左右子节点是否为空</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</div><div class="line">                  (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</div><div class="line">                 (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</div><div class="line">            p = (dir &lt; <span class="number">0</span>) ? pl : pr; <span class="comment">//通过Comparable的compareTo方法判断，-1遍历左子树，1遍历右子树</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.find(h, k, kc)) != <span class="keyword">null</span>) <span class="comment">//</span></div><div class="line">            <span class="keyword">return</span> q;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            p = pl; <span class="comment">//上面两个是递归调用find的两种形式，一个为递归find右子树，另一个为循环遍历左子树</span></div><div class="line">    &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>find的逻辑与putTreeVal的查找逻辑十分类似，也是通过比较符、compareTo方法，递归调用find来查找，不同的是，这里不使用System.identityHashCode来比较了。</p><p>有了put和get方法，基本上HashMap的框架就有了，接下来分析resize方法，该方法扩容table的size，使其double原来的大小，这也是HashMap如此好用的原因，我们不需要考虑HashMap的大小，只要使用put、get即可。</p><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><p>resize方法有两个作用：1、初始化table； 2、double原table的大小。 resize的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">//链表只有一个节点</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">//oldCap形如00100000,此处相与，类似于选择器，为0的放在lower list，为1的放在upper list</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//将lower list放在newTab的j处</span></div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="comment">//将upper list放在newTab的j+oldCap处，原来j处的list一分为二，相距oldCap距离</span></div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>if (oldTab != null)</code>之前的语句比较容易理解，计算newCap(为oldCap的两倍，左移1位)，然后通过new来初始化数组。到<code>if (oldTab != null)</code>，说明之前table中已经存了k/v(put方法已经被调用过)，需要将原来的K/V值移动到新的table中对应的index处。移动的逻辑也比较简单，如果链表只有一个节点，则直接赋值给新数组的对应index处，这里有一个隐含逻辑，就是当e1.hash &amp; (oldCap-1) = j的时候，e2.hash &amp; (oldCap - 1) = k； j不等于k，则 e1.hash &amp; (newCap - 1) 一定不等于 e2.hash &amp; (newCap - 1)，因为它们的低x位不同(x为oldCap-1的1的个数)。因此不需要考虑e.hash &amp; (newCap - 1) 处是否已存在节点，因为一定为null。</p><p>如果链表长度大于1，则需要将链表一分为二，分别为lower list和upper list。 将lower list放到 newTab的j处，upper list放到newTab的j+oldCap处。 但它的分割方法是通过e.hash &amp; oldCap进行的，如果为0，则放在lower里面，否则，放在upper里面。但这种方法个人认为并不能保证等分，它的分割是否平均取决于hash值在该位的随机性。split方法是TreeNode的分割版本，其逻辑也是通过e.hash &amp; oldCap进行分割的，在此不再赘述。</p><h2 id="遍历源码分析"><a href="#遍历源码分析" class="headerlink" title="遍历源码分析"></a>遍历源码分析</h2><p>HashMap的遍历方式与Map的一样，有三种遍历方式，分别为:key的遍历，value的遍历，Entry(K/V对)的遍历。三者的实现一致，下面以key的遍历为例进行分析。</p><p>keySet()方法会返回一个Set<k>对象，它的实现类是一个内部类KeySet，继承了AbstractSet<k>，通过KeySet的iterator方法，可以返回一个KeyIterator对象，KeyIterator也是一个内部类，继承了HashIterator，ValueIterator（value的遍历对象），EntryIterator（Entry的遍历对象）也继承了该类，因此，在此分析HashIterator即可。</k></k></p><p>HashIterator在初始化的时候会将next指向从table的0开始数，第一个存了Node的位置，next指向的为一个Node。构造函数定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">HashIterator() &#123;</div><div class="line">    expectedModCount = modCount;</div><div class="line">    Node&lt;K,V&gt;[] t = table;</div><div class="line">    current = next = <span class="keyword">null</span>;</div><div class="line">    index = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></div><div class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>nextNode方法返回next当前指向的Node，并将next指向下一个Node。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">nextNode</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] t;</div><div class="line">    Node&lt;K,V&gt; e = next;</div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</div><div class="line">    <span class="comment">//将next指向下一个不为空的Node</span></div><div class="line">    <span class="keyword">if</span> ((next = (current = e).next) == <span class="keyword">null</span> &amp;&amp; (t = table) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">do</span> &#123;&#125; <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>到此为止，HashMap就分析结束了，主要分析了HashMap的put、get方法，存储方式，扩容方式，遍历方式，这些是Map的几个最重要的操作，也是体现HashMap之所以为HashMap的特征，接下来，分析两个和HashMap关系密切的类：LinkedHashMap、HashTable。</p><h1 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h1><p>LinkedHashMap关系最为密切，它是在HashMap的基础上进行的功能增强，提供了双向链表的存储结构。这里的意思不是说LinkedHashMap完全舍弃了HashMap使用数组的存取方式，而是说在此基础上，通过添加一个双向链表（节点类型为LinkedHashMap.Entry<k,v>, 有一个before指针，和after指针，因此为双向链表），保证了Map的顺序，而在遍历时，舍弃了上面HashMap的HashIterator，选择直接对双向链表遍历，因此就达到了保证顺序的目的。</k,v></p><p>LinkedHashMap中有一个比较有趣的属性，叫作accessOrder，它是一个布尔值，表示了双向链表所保证的顺序是否为访问顺序。如果accessOrder为true，则保证的为访问顺序，即通过put修改了某个key对应的value后，会将该节点放在双向链表的最后。如果accessOrder为false，则保证的是插入顺序，此时put修改不会更改该节点在双向链表中的顺序。</p><p>LinkedHashMap重写了HashMap的newNode方法，在newNode中调用了linkNodeLast方法将新生成的节点放到了双向链表的最后。因此，在HashMap的putVal方法中调用newNode时，实际调用的为LinkedHashMap的newNode方法，这就达到了复用putVal方法的目的。在插入、修改、删除Node后，通过afterNodeInsertion，afterNodeAccess，afterNodeRemoval修改LinkedHashMap中的双向链表即可。三个方法的含义为</p><ul><li>afterNodeInsertion在节点插入后执行，在LinkedHashMap中没有实际作用，它提供了一个潜在的功能，就是在插入后删除eldest节点，可以达到一个类似于固定长度的缓冲队列的功能。</li><li>afterNodeAccess在accessOrder为true的时候触发，将修改或者通过get访问的节点放到双向链表的最后。</li><li>afterNodeRemoval在删除节点后触发，删除双向链表中的对应节点。</li></ul><p>LinkedHashMap的遍历同构一个内部类LinkedHashIterator实现了双向链表的遍历，在此不再赘述。</p><h1 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h1><p>HashTable经常拿来跟HashMap比较，是因为在ConcurrentHashMap，它可以作为一个线程安全的HashMap来使用。但实际HashTable的出生日期比HashMap还要早一些，从1.0开始就存在了，而HashMap在1.2才出现。HashTable就是一个标准的Hash表，继承了Dictionary抽象类，实现的是基本的K/V操作，没有HashMap那么多的基于性能的优化。HashTable中很多方法直接使用的是synchronized修饰，因此是线程安全的。HashTable不能将null作为key值存放，且key值必须是一个对象，定义了hashCode和equals方法。存储结构就是标准的数组+链表的方式，解决Hash冲突的方法就是采用标准的开链法，每次将新的node放在链表的头部。下面分析一下put方法，其定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="comment">// Make sure the value is not null</span></div><div class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Makes sure the key is not already in the hashtable.</span></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="comment">//hash值为key的hashCode，因此key必须实现了hashCode方法</span></div><div class="line">    <span class="keyword">int</span> hash = key.hashCode();</div><div class="line">    <span class="comment">//index和31个1相与，然后对length求余，因为int长度为32，第一个1代表为负数，而index&gt;=0</span></div><div class="line">    <span class="keyword">int</span> index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];</div><div class="line">    <span class="keyword">for</span>(; entry != <span class="keyword">null</span> ; entry = entry.next) &#123;</div><div class="line">        <span class="comment">//key值已存在，则覆盖</span></div><div class="line">        <span class="keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.key.equals(key)) &#123;</div><div class="line">            V old = entry.value;</div><div class="line">            entry.value = value;</div><div class="line">            <span class="keyword">return</span> old;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//key值不存在，新增节点</span></div><div class="line">    addEntry(hash, key, value, index);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>逻辑很清晰，先计算hash值在数组中的index，然后在index对应的链表寻找是否有对应的key，有的话覆盖旧值，否则，调用addEntry方法，新增节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    Entry&lt;?,?&gt; tab[] = table;</div><div class="line">    <span class="keyword">if</span> (count &gt;= threshold) &#123;</div><div class="line">        <span class="comment">// Rehash the table if the threshold is exceeded</span></div><div class="line">        rehash();</div><div class="line"></div><div class="line">        tab = table;</div><div class="line">        hash = key.hashCode();</div><div class="line">        index = (hash &amp; <span class="number">0x7FFFFFFF</span>) % tab.length;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Creates the new entry.</span></div><div class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">    Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) tab[index];</div><div class="line">    <span class="comment">//将新增节点放在链表的头部，原来的链表头e，作为新节点的next节点</span></div><div class="line">    tab[index] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</div><div class="line">    count++;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>如果大小大于阈值，需要进行rehash，对数组进行扩容。rehash方法double当前的容量，然后将旧节点放到 <code>(e.hash &amp; 0x7FFFFFFF) % newCapacity</code>处，代码不在此处粘贴。</p><p>HashTable的遍历时从数组的末尾index递减的顺序进行遍历的，通过一个内部的Enumerator来实现，通过属性type判断要取的是key值还是value值或者Entry值，在此不做赘述。</p><p>由上面所说，HashTable大多数的方法都为同步方法，已经不太适合多并发编程，因此推荐使用ConcurrentHashMap类满足并发需求，ConcurrentHashMap的读不加锁，因此适合频繁多线程读的场景。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析HashMap是我读Collection 家族的最多收获的一次，在过程中不仅复习了开链法解决Hash冲突，还学到了通过掩码实现类似于求余的操作，并搞懂了为什么capacity为什么必须是2的整数次幂，在后面有学习了一下红黑树的相关知识，虽然让我实现一个红黑树还是困难重重，但已经增加了很深对于红黑树的理解。而且在分析LinkedHashMap的时候，了解了LinkedHashMap巧妙复用HashMap的put方法的编程技巧，这一点也是让我受益匪浅。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(sad) &#123;</div><div class="line">  sad = <span class="keyword">false</span>;</div><div class="line">  beAwesome();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;HashMap和HashTable可以说是Map家族中最常用的两个类了，而两者又都是通过Hash表来进行key值的映射的，因此选择将两者进行统一的比较分析，并借此了解jdk中是如何实现hash表结构的map对象的。这篇博客篇幅较长，但我觉得有很多是很有用的知识，希望读者可以耐心阅读。博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2017/12/07/hashmap_info/#more&quot;&gt;HashMap1.8源码解读&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="Collection" scheme="http://www.wangjialong.cc/tags/Collection/"/>
    
      <category term="HashMap" scheme="http://www.wangjialong.cc/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>Map简介</title>
    <link href="http://www.wangjialong.cc/2017/11/26/map_info/"/>
    <id>http://www.wangjialong.cc/2017/11/26/map_info/</id>
    <published>2017-11-25T16:00:00.000Z</published>
    <updated>2017-11-29T11:30:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Collection家族的最后一个重要成员就是Map了，坦白来说，在实际开发中，用到的最多的怕就是List和Map了，而相对来说Set比他们用的都少一点。Map的K/V存储结构，特别适合在后端开发中存放一些用户请求参数，配置信息等。因此，准备详细分析一下Map家族，大致分为三个部分Map、HashMap、TreeMap。</p><a id="more"></a><h1 id="Map介绍"><a href="#Map介绍" class="headerlink" title="Map介绍"></a>Map介绍</h1><p>Map是一个接口，它表示了一组可以存放K/V键值对的集合。key值必须是唯一的，不能重复，对应的value值同一时刻只能指向一个对象。Map的定义是使用了泛型的，其定义语法为 <code>public interface Map&lt;K,V&gt;</code>， K为键的类型，V为value的类型。可以是通用数据类型也可以是类。</p><p>Map提供了三种视图可以用于遍历，key值得集合，value值得集合，k/v对的集合。有一些子类的遍历顺序是一定的，如TreeMap，而另一些是不确定的，如HashMap。Map主要提供了以下的方法：</p><ul><li><strong>查询类的</strong>：size返回当前大小、isEmpty返回是否为空，containsKey、containsValue分别返回是否包含该key或value，</li><li><strong>操作类的</strong>：get(key)、put(key, value)、remove(key)、putAll(map)、clear()</li><li><strong>视图类的</strong>：keySet()返回key值的一个set集合对象，values返回一个Collection对象，entrySet返回一个Set<map.entry<k, v="">&gt; 对象，Map.Entry是一个内部静态类</map.entry<k,></li></ul><p>根据视图类的三个方法，分别有三种遍历方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>/遍历k,v值</div><div class="line"><span class="keyword">for</span>(K key: map.keySet()) &#123;</div><div class="line">    V value = map.get(key);</div><div class="line">&#125;</div><div class="line"><span class="number">2</span>/只遍历v值</div><div class="line"><span class="keyword">for</span>(V value: map.values()) &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="number">3</span>/遍历k,v值</div><div class="line"><span class="keyword">for</span>(Map.Entry&lt;K,V&gt; entry: map.entrySet()) &#123;</div><div class="line">    K key = entry.getKey();</div><div class="line">    V value = entry.getValue();</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>JDK1.8之后，接口中的方法可以提供默认的结构体了，叫作接口的默认方法，该方法提供了默认操作，如果实现类没有重写这些方法，则将直接调用默认方法的逻辑，这赋予了接口部分父类的功能，免除了实现类重复的实现相同的方法逻辑。Map中的默认方法大多与1.8支持的lambda表达式有关，通过传入Function，提供了函数式编程的部分特性。</p><p>默认方法中有一部分是无关Lambda表达式的，这部分方法的意义就是纯粹的提供了一个默认的操作逻辑。这些方法包含了</p><ul><li>putIfAbsent(K key, V value)，该方法判断key对应的是否为null，如果是，则赋值。</li><li>remove(Object key, Object value)删除指定key/value对，这里使用了Object而没有采用泛型，具体原因没有分析出来。</li><li>replace(K key, V oldValue, V newValue)将旧值替换为新值</li><li>replace(K key, V value)将该key对应的value设为传入的value。</li></ul><p>默认方法中另一组方法是传入参数为Function或者BiFunction的，Function和BiFunction为依赖注入的对象，在默认方法调用其apply方法，对Map的元素进行相应的操作。依赖注入是spring中重要的一个思想，它通过注入一个接口，达到了控制反转的目的。在这里，默认方法都调用apply方法，但apply方法的具体实现逻辑在这里并没有指定，而是通过传入的Function或者BiFunction的实现类来决定的，也就是把具体控制权交给了其实现类。简单介绍一下两个接口。</p><ul><li>两者都可以用Lambda表达式传入</li><li>Function的apply方法传入一个参数，BiFunction的apply方法传入两个参数。</li><li>两者的apply方法都会返回一个值</li></ul><p>computeIfAbsent传入一个key值和Function，在调用时可以使用 <code>map.computeIfAbsent(1, k -&gt; k+&quot;&quot;)</code>的格式，将key为1（不存在与Map中）对应的value设置为字符串“1”。</p><p>compute、computeIfPresent、merge、replaceAll传入的都为BiFunction。</p><p>compute的典型用法如<br><code>map.compute(key, (k, v) -&gt; (v == null) ? msg : v.concat(msg))</code> 将key对应的value设一个默认字符串或者将原有字符串和新字符串合并。merge的用法与compute类似。<code>map.merge(key, msg, String::concat)</code></p><p>computeIfPresent对一个存在的key值进行对应的apply方法调用。replaceAll对所有的k/v对进行相应的操作。</p><p>默认方法还有一个传入的是BiConsumer接口。该接口调用的是accept方法，传入两个参数，不返回值。该默认方法为forEach方法，可以方便的用于遍历map.如 <code>map.forEach((k, v) -&gt; System.out.println(k +&quot;-&gt;&quot;+ v));</code></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Map是Collection框架中的大家族，其中有HashMap、HashTable、TreeMap都有分析的必要，因此决定单独几篇分析每个类。在这里，简单介绍了Map的功能和特性，重点介绍了1.8后支持的默认方法，给接口的使用增加了很多的便利性。灵活使用默认方法搭配Lambda表达式，可以写出来简洁且清晰的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;Collection家族的最后一个重要成员就是Map了，坦白来说，在实际开发中，用到的最多的怕就是List和Map了，而相对来说Set比他们用的都少一点。Map的K/V存储结构，特别适合在后端开发中存放一些用户请求参数，配置信息等。因此，准备详细分析一下Map家族，大致分为三个部分Map、HashMap、TreeMap。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="Collection" scheme="http://www.wangjialong.cc/tags/Collection/"/>
    
      <category term="Map" scheme="http://www.wangjialong.cc/tags/Map/"/>
    
  </entry>
  
  <entry>
    <title>Set家族简介</title>
    <link href="http://www.wangjialong.cc/2017/11/19/java_set_info/"/>
    <id>http://www.wangjialong.cc/2017/11/19/java_set_info/</id>
    <published>2017-11-18T16:00:00.000Z</published>
    <updated>2017-11-19T13:37:47.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Set家族是Collection Framework中重要的一个分支，它的含义就是数学意义上的set概念，也就是说它的元素满足互斥性，如果e1，e2都属于一个Set，则e1.equals(e2)一定返回false，否则，在添加的时候，后面加入的元素无法被添加进来。Set在存储互斥元素的时候有很好的作用，如果我们希望在一个集合中存储唯一元素，如key值，则可以选择Set的子类进行存储。</p><a id="more"></a><h1 id="Set简述"><a href="#Set简述" class="headerlink" title="Set简述"></a>Set简述</h1><p>Set不能存储相等的两个元素，那么就有一个问题，如果元素存入后改变了怎么办？通常的，一个元素的值得改变如果影响到了equals方法的返回值，Set并没有规定必须抛出异常，但在添加的时候，尽量不要添加会改变equals返回值的元素。</p><p>Set中的方法与父接口中方法签名一致，但我在阅读源码的时候，发现Set还是重写了父接口的方法，这在语法上并不是必要的，在此我就暂且“以小人之心度一下源码大大之意“吧。</p><ul><li>Set中的方法虽然签名与Collection相同，但具体含义不一样，如add方法，Collection是随意添加一个元素，而Set是添加一个之前在集合中不存在的元素</li><li>为了写方法的doc注释，Collection中add方法和Set中add方法的注释不同</li></ul><p>Set家族中有几个重要的成员，HashSet、SortedSet、TreeSet，下面简单介绍一下各自的含义</p><ul><li>HashSet：Set接口的实现类，内部存储结构为Hash表，实际上是由HashMap实现的HashSet</li><li>SortedSet：Set接口的子接口，代表了一类排序的Set，其元素排列顺序为自然排序或者通过具体的comparator比较</li><li>TreeSet：SortedSet的一个实现类，内部存储结构为红黑树，实际是由TreeMap实现的</li></ul><h1 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h1><p>HashSet是一个Hash表实现的Set结构，其内部具体存储元素的是HashMap对象(<em>HashMap是Map家族的重要成员，将在Map中进行分析</em>)，其具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;</div><div class="line"><span class="comment">// Dummy value to associate with an Object in the backing Map</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>由上面代码可以看出，HashSet中的元素实际上被存储为HashMap的key值，其唯一性由HashMap来保证，而HashMap的value值为一个静态常量PRESENT，它是一个Object对象。该对象用于判断map.remove时的返回值是否与其相同，来确保remove方法正确的删除了指定元素。</p><p>HashSet中有两个比较重要的概念是initialCapacity和loadFactor，它们也是HashMap中的重要概念，在此只做简单的描述，详细的在Map中进行分析。</p><ul><li><code>initialCapacity</code>是bucket的默认大小，bucket也就是Hash表中一个key值对应的存储容量，是为了解决key冲突的，一个理想的Hash表应当是每个key对应一个值，这样可以在O(1)的时间内读取到一个值，但这需要Hash算法能把key值散列的完全没有重复才可以达到，而这在现实中是不可能的，因此bucket的存在就很关键，由此可见HashMap是通过开链法解决冲突的</li><li><code>loadFactor</code>是bucket的默认填充因子，是一个0~1间的小数，代表了一个bucket最多可以填充多少百分比</li></ul><p>HashSet是线程不安全的，如果需要获取一个同步Set，可以使用下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set s = Collections.synchronizedSet(<span class="keyword">new</span> HashSet(...));</div></pre></td></tr></table></figure><p>HashSet的iterator也是fail-fast的，如果在iterator遍历时，使用了除iterator的remove方法之外的方法改变了HashSet，则会抛出ConcurrentModificationException，这部分的实现是与</p><h2 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h2><p>LinkedHashSet是HashSet的子类，是从1.4版本开始加入Set家族的(<em>HashSet从1.2就存在了</em>)，它主要解决的问题是HashSet在返回iterator的时候，顺序不统一的问题，因此LinkedHashSet使用了链表的方式，确保了元素的遍历顺序，该顺序与元素插入顺序一致。LinkedHashSet内部使用了LinkedHashMap存储元素值，它的iterator也是调用了LinkedHashMap的iterator方法。</p><p>LinkedHashSet的典型使用场景是客户端展示数据，因为相同的集合，客户端希望展示的数组顺序是一样的，此时可以选择使用LinkedHashSet返回元素集合。严格意义上也可以使用TreeSet实现相同的功能，但TreeSet耗时比LinkedHashSet更大，因此LinkedHashSet是更好的选择。</p><h1 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h1><p>SortedSet是Set的一个子接口，它的含义跟它的名字一样——排序集合。它可以根据元素的自然顺序进行存储，也可以通过指定Comparator，来实现自己的排序逻辑。插入的元素必须实现Comparable接口（或者可以接受Comparator的compare方法），e1.compareTo(e2)或者comparator.compare(e1, e2)方法必须不能抛出ClassCastException异常。</p><p>SortedSet的实现类有以下几点限制：</p><ul><li>一个无参构造方法，创建一个自然顺序的SortedSet</li><li>一个传入Comparator的构造方法，根据Comparator的compare方法进行排序</li><li>一个传入Collection的构造方法，根据自然顺序创建一个Collection的拷贝</li><li>一个传入SortedSet的构造方法，创建一个跟传入对象相同的SortedSet</li></ul><p>SortedSet中定义了几个方法：</p><ul><li>comparator() 返回用于排序的Comparator</li><li>first() 返回Set的第一个元素</li><li>headSet(E toElement) 返回toElement之前所有元素组成的集合</li><li>subSet(E fromElement, E toElement)返回一个half-open的子集合，范围为[fromElement, toElement)</li><li>tailSet(E fromElement) 返回fromElement之后所有元素组成的集合</li></ul><h2 id="NavigableSet（1-6之后才有）"><a href="#NavigableSet（1-6之后才有）" class="headerlink" title="NavigableSet（1.6之后才有）"></a>NavigableSet（1.6之后才有）</h2><p>NavigableSet是SortedSet的一个子接口，也是TreeSet实现的接口，因此在这里简单介绍。NavigableSet顾名思义，是一个可以查找的Set，而且通常意义上很快（TreeSet通过红黑树实现，可以实现O(logN)的查找)。因此可以通过指定一个target，来返回想要查找的元素。</p><p>NavigableSet提供了几个实用的方法：</p><ul><li>lower(E e)返回小于e的最大元素</li><li>floor(E e) 返回小于或等于e的最大元素</li><li>ceiling(E e)返回大于或等于e的最小元素</li><li>higher(E e) 返回大于e的最小元素</li><li>descendingSet() 和 descendingIterator()分别返回一个倒序的Set和Iterator</li><li>pollFirst() 和 pollLast() 分别返回第一个、最后一个元素</li></ul><h1 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h1><p>TreeSet实现了NavigableSet，它是基于TreeMap存储的，由于TreeMap实现了红黑树，因此TreeSet也提供了O(logN)的插入、删除、查找操作。</p><p>TreeSet的方法是NavigableSet和SortedSet的方法并集，在此不再进行罗列。源码中各个方法都是使用TreeMap的相应方法实现，在此也不过多描述，在TreeMap中进行详细的分析。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析到这里，发现Set家族的儿子都是从别人家偷的（HashSet使用了HashMap，TreeSet使用了TreeMap），真是精致的拿来主义者啊。不过这在代码的实现中，确实很高的技巧，完美的实现了DRY（Don’t repeat yourself）原则。Set家族的分析相对比较简单，因为大多都是Map家族的成员帮助它们完成了功能，因此，在下一步Map的分析就显得任重道远了。Set家族使用的场景虽然不多，但经过一番分析之后，也是挖掘了不少潜在价值，合理利用HashSet和TreeSet，可以减少很多代码的工作量。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Set家族是Collection Framework中重要的一个分支，它的含义就是数学意义上的set概念，也就是说它的元素满足互斥性，如果e1，e2都属于一个Set，则e1.equals(e2)一定返回false，否则，在添加的时候，后面加入的元素无法被添加进来。Set在存储互斥元素的时候有很好的作用，如果我们希望在一个集合中存储唯一元素，如key值，则可以选择Set的子类进行存储。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="Collection" scheme="http://www.wangjialong.cc/tags/Collection/"/>
    
      <category term="Set" scheme="http://www.wangjialong.cc/tags/Set/"/>
    
  </entry>
  
  <entry>
    <title>List家族简介</title>
    <link href="http://www.wangjialong.cc/2017/11/15/javaList_info/"/>
    <id>http://www.wangjialong.cc/2017/11/15/javaList_info/</id>
    <published>2017-11-14T16:00:00.000Z</published>
    <updated>2017-11-15T14:02:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>List是Collection framework中重要的一员，在平时的编程中，我也会经常用到，它可以简单的理解成一个变长的数组，数组中的每个元素的类型必须一致。在数据结构的概念里面，链表是可以动态添加删除的，由节点与指针组成的一组数据集合，包括了单向链表、双向链表、循环链表、带头节点的链表、十字链表等。在Java中，并没有实现那么多复杂的结构，它的实现类包括了ArrayList、LinkedList、Vector三大类，下面详细介绍各个实现类。</p><a id="more"></a><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>ArrayList是List家族最常用的一个类了，它是一个变长的数组，实际上它的内部实现也是通过一个对象数组实现的。它实现了List、RandomAccess、Cloneable、Serializable接口，这四个接口的含义是：</p><ul><li>List代表的是一个有序的数组，顺序为插入时候的先后顺序，成员可以是基本数据类型和类，用户可以通过下标访问成员，也可以查询成员是否存在</li><li>RandomAccess接口比较有意思，它用来修饰实现了List接口的类，也就是说实现该接口必须先实现List接口。它表示该类可以进行快速的随机访问。具体的含义可以理解为代码段</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, n=list.size(); i &lt; n; i++)</div><div class="line">         list.get(i);</div></pre></td></tr></table></figure><p> 的运行速度比下面的代码段快</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Iterator i=list.iterator(); i.hasNext(); )</div><div class="line">    i.next();</div></pre></td></tr></table></figure><ul><li>Cloneable接口代表的是该类可以进行复制，并保留原有的属性值，实现该接口的类必须有一个public的clone方法</li><li>Serializable接口是序列化中的关键，只有实现了该接口的类才可以正常的进行序列化和反序列化</li></ul><p>上面说到ArrayList内部实现是一个数组，那么它的长度是多少呢，它又是怎么实现变长的呢，数组的元素类型又是什么呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The array buffer into which the elements of the ArrayList are stored.</span></div><div class="line"><span class="comment"> * The capacity of the ArrayList is the length of this array buffer. Any</span></div><div class="line"><span class="comment"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></div><div class="line"><span class="comment"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div></pre></td></tr></table></figure><p>上面的成员变量就是ArrayList中实际存元素的数组，通过注释我们也可以看出，ArrayList有一个默认的长度，在JDK8中为10，也可以通过构造函数传入默认的长度。ArrayList在添加元素的时候，会保证当前的数组有剩余空间，通过<code>ensureCapacityInternal(size + 1);  // Increments modCount!!</code>来实现，调用该方法保证当前数组长度大于等于size+1，方法内部调用<br><code>ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</code> calculateCapacity方法返回的是默认容量和传入的minCapacity间的最大值，ensureExplicitCapacity方法会判断minCapacity是否大于elementData的长度，如果小于，调用grow方法，对elementData扩容。grow方法默认扩充原elementData的一半长度（<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>），如果newCapacity仍然小于minCapacity的话，则<code>newCapacity = minCapacity;</code></p><p>在ensureExplicitCapacity方法的调用第一句有一句有趣的代码为<code>modCount++</code>，这个属性我最开始以为是类似于魔数的含义，但最后发现并不是，它的定义语句位于AbstractList中，通过注释可以看到，它的存在是为了解决并发访问的问题，由于ArrayList没有加锁，因此当我们返回它的Iterator之后，一旦对该List进行元素的增删改，就会发生并发错误，ArrayList通过modCount来避免该现象，当ArrayList发生了结构变化时(增删改、自排序)，modCount会自增，这就会于返回Iterator时的值不同，因此直接抛出ConcurrentModificationException异常，这是Java实现的一个fail-fast机制，此时我们可以重新返回新的Iterator元素，重新进行数据的遍历。在ArrayList的序列化和反序列化中，modCount也扮演了重要的角色，在调用writeObject方法时，写完对象之后，会判断modCount和写之前的值是否一致，若不一致，也会抛出ConcurrentModificationException异常。如果我们在使用ArrayList时候，需要考虑并发访问，可以考虑使用<code>List list = Collections.synchronizedList(new ArrayList(...));</code>返回一个同步对象了，然后对该同步对象进行并发操作。</p><p>ArrayList常用的方法介绍如下：</p><ul><li>add方法向数组最后添加一个元素，该方法也可以将元素添加到指定的位置</li><li>remove方法可以删除指定位置的元素，也可以删除与指定元素相同的元素，也可以传入一个下标区间，删除该区间内的元素</li><li>get方法返回指定位置的元素，set方法修改指定位置的元素</li><li>isEmpty方法判断是否为空</li><li>iterator方法返回一个遍历对象，该对象可以通过next方法遍历数组</li><li>sort方法可以传入一个comparator对象实现数组的自排序，comparator可以定义排序规则</li><li>subList可以返回指定区间的子数组，listIterator可以返回指定位置开始的子Iterator</li></ul><p>ArrayList中通过iterator方法返回一个遍历对象，该对象的类原型是一个ArrayList中的内部类Itr，该类实现了Iterator接口，可以通过next方法遍历数组，并可以通过remove删除当前位置的元素，forEachRemaining方法传入一个Consumer，可以对当前位置之后的所有元素执行Consumer的动作，在特定的场景下可以应用。通过Itr对象进行的元素更改，对原ArrayList会产生影响。上面说到的modCount在Itr中重要的应用，用以防止在Itr对象的生命周期中，原始ArrayList没有发生结构上的变化，若发生了变化，则抛出异常，但通过Itr的remove方法进行的修改不会抛出异常。Itr的remove方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</div><div class="line">    checkForComodification();</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ArrayList.<span class="keyword">this</span>.remove(lastRet);</div><div class="line">        cursor = lastRet;</div><div class="line">        lastRet = -<span class="number">1</span>;</div><div class="line">        expectedModCount = modCount;</div><div class="line">    &#125; <span class="keyword">catch</span> (IndexOutOfBoundsException ex) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>expectedModCount是一个Itr对象的属性，在该对象创建的时候赋值为modCount，checkForComodification方法判断两值是否相等，若不相等，则抛出异常。remove方法调用的ArrayList的remove方法删除指定位置(lastRet)的元素，删除该元素后，cursor指向了lastRet位置，由于该位置元素已经被删除，因此指向了原位置的下一元素，lastRet指向-1，因此，Itr的remove方法不可以连续执行。</p><h1 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h1><p>LinkedList是一个第一眼看上去很熟悉，但用的时候却总是想不起来的一个角色，对于我来说，它的使用频率甚至少于Stack（Vector的子类），但因为它的名字里面带了List，因此我在第二位分析它。</p><p>LinkedList是一个双向链表，它实现了List、Deque、Cloneable、Serializable接口，其他三个都在ArrayList中进行了分析，这里重点介绍Deque接口。Deque光看名字好像跟Queue有点关系，但又不完全相同，实际上它是Queue的子接口，它是一个支持从头、尾两端进行添加元素和删除元素的队列，也就是“double ended queue”。它的添加、删除两头元素的方法都有两种形式，一种是遇到错误的时候抛出异常、一种是遇到错误返回特定的值（null或false），下表是这些方法的详细说明。</p><table><thead><tr><th>/</th><th>抛出异常</th><th>返回特定值</th><th>抛出异常</th><th>返回特定值</th></tr></thead><tbody><tr><td>添加</td><td>addFirst(e)</td><td>offerFirst(e)</td><td>addLast(e)</td><td>offerLast(e)</td></tr><tr><td>删除</td><td>removeFirst()</td><td>pullFirst()</td><td>removeLast()</td><td>pullLast()</td></tr><tr><td>获取值</td><td>getFirst()</td><td>peekFirst()</td><td>getLast()</td><td>peekLast()</td></tr></tbody></table><p>由于Deque可以在两端增删元素，因此也可以用作栈来使用，实际上，它也提供了相应的方法，push、pop、peek、它们与上面的方法的对应关系为</p><table><thead><tr><th>Stack方法</th><th>Deque对应的方法</th></tr></thead><tbody><tr><td>push(e)</td><td>addFirst(e)</td></tr><tr><td>pop()</td><td>removeFirst()</td></tr><tr><td>peek()</td><td>peekFirst()</td></tr></tbody></table><p>由此可见，当被用作栈的时候，栈顶为Deque的第一个元素。</p><p>LinkedList是双向链表，与ArrayList相比，它或许更有资格称为“List”，因为，它的内部实现就是通过一组节点和节点的引用来构成的，节点类是一个内部类Node，定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line">    E item;</div><div class="line">    Node&lt;E&gt; next;</div><div class="line">    Node&lt;E&gt; prev;</div><div class="line"></div><div class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</div><div class="line">        <span class="keyword">this</span>.item = element;</div><div class="line">        <span class="keyword">this</span>.next = next;</div><div class="line">        <span class="keyword">this</span>.prev = prev;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>它通过一个next指向下一个节点，通过prev指向前一个节点。LinkedList通过保存两个节点first、last来记录链表的头部和尾部，通过size属性来记录当前链表的长度。当需要添加一个元素的时候，LinkedList将该节点添加到last之后，当需要删除一个节点的时候，LinkedList从first节点向后遍历，逐一比对，删除第一个相同的节点（equals返回true）。</p><p>当调用set、get(index) 方法的时候，LinkedList会根据index来选择比较近的路径找到对应节点（从头向尾或者从尾向头），通过调用node(index)返回对应的节点。该方法的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">// assert isElementIndex(index);</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">        Node&lt;E&gt; x = first;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</div><div class="line">            x = x.next;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;E&gt; x = last;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</div><div class="line">            x = x.prev;</div><div class="line">        <span class="keyword">return</span> x;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>可以看到，当index小于size的一半时，从first节点向后，大于时，从last节点从后向前。</p><p>LinkedList中有个内部类ListItr，它是ListIterator的一个实现类，ListIterator提供了双向遍历数组的能力，这也是LinkedLIst的能力，该Iterator返回node节点，next方法也是通过Node的next“指针”来进行的，它和ArrayList中的Itr一样，并不会返回一个全新的对象，对它的元素的删除、添加是直接对原LinkedList中的节点的操作，因此也需要防止并发错误，也是通过了modCount来实现的，具体原理与ArrayList中相同。DescendingIterator是一个从后向前遍历的单向Iterator，内部实现使用了ListIterator。</p><h1 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h1><p>Vector也是一个第一眼看来很眼熟，但不怎么常用的类(在C++中可能更常用些)，这主要源于它很大程度上与ArrayList的功能相同，内部也是通过对象数组来进行元素的存储。它与ArrayList的主要不同有两点：</p><ul><li>提供了capacityIncrement来控制当数组空间不足时，新增的容量，这在需要严格控制内存的使用的应用上有时可以派上用场，但鉴于Java应用大多数跑在服务器上，所以似乎用处不大</li><li>它是<strong>线程安全</strong>的。这在多线程编程时，自己不想实现类似结构的时候，可以临时使用Vector来代替。但由于其内部实现是通过在方法上直接修饰synchronized来形成同步方法，因此并发度并不高，因此使用场景也比较有限。</li></ul><p>Vector也提供了Itr和ListItr两种遍历对象来进行数组的遍历，其内部实现逻辑与ArrayList相同，也是通过一个cursor记录当前的遍历位置，在涉及到元素修改的代码中，添加了synchronized (Vector.this)来确保元素的操作是线程安全的。</p><h1 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h1><p>Stack跟List家族的关系并不大，在这里介绍主要是因为它是Vector的子类，但它却不是数组，而是栈(LIFO)。栈顶位于Vector的最后一个位置，添加和删除都是从该位置进行的。Stack提供了栈的几个基本的操作，包括push、pop、peek、empty查看是否为空，search返回元素距栈顶的距离。</p><p>Stack只是栈的一个最基本的实现，更加具体的实现由Deque和它的实现类提供，在实际使用中应该倾向于使用该类，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;();</div></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>List家族的几员大将已经分析完毕，还剩一个CopyOnWriteArrayList由于涉及更多关于线程的知识，暂时不在这里讨论，通过总结List中的几个常用类，对它们的使用场景有了更深的认识，并了解了modCount机制，这是一个简单避免线程不安全的方法，在编程中是一个不错的小技巧。List中动态分配内存空间的思想也对于高效编程有很大的帮助，理解它们有助于编写出GC友好的代码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;List是Collection framework中重要的一员，在平时的编程中，我也会经常用到，它可以简单的理解成一个变长的数组，数组中的每个元素的类型必须一致。在数据结构的概念里面，链表是可以动态添加删除的，由节点与指针组成的一组数据集合，包括了单向链表、双向链表、循环链表、带头节点的链表、十字链表等。在Java中，并没有实现那么多复杂的结构，它的实现类包括了ArrayList、LinkedList、Vector三大类，下面详细介绍各个实现类。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="Collection" scheme="http://www.wangjialong.cc/tags/Collection/"/>
    
      <category term="List" scheme="http://www.wangjialong.cc/tags/List/"/>
    
  </entry>
  
  <entry>
    <title>cgroups资源限制</title>
    <link href="http://www.wangjialong.cc/2017/11/07/cgroups_info/"/>
    <id>http://www.wangjialong.cc/2017/11/07/cgroups_info/</id>
    <published>2017-11-06T16:00:00.000Z</published>
    <updated>2017-12-19T12:13:13.775Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>资源隔离技术namespace通过系统调用构建了一个相对隔离的shell环境，在该环境下资源的使用不会影响宿主机，这已经有“容器”的雏形了。而如何将隔离出来的资源合理的使用，这就需要另一个强大的内核工具——cgroups。它不仅可以限制被namespace隔离的资源，还可以为资源设置权重、计算使用量、操控任务(进程或线程)启停等，Docker通过cgroups进行运行时资源的限制。</p><a id="more"></a><h1 id="cgroups简介"><a href="#cgroups简介" class="headerlink" title="cgroups简介"></a>cgroups简介</h1><p>cgroups最初名为process container，但由于container的多重含义，最后改名为control groups，顾名思义就是把任务放到一个组里，统一进行控制。因此，cgroups控制对象是任务组，一旦一个任务加入了一个组中，就会受到相关联的cgroups的资源限制，这里的资源指的是物理资源(cpu、Memory)。</p><p>cgroups的4个特征:</p><ul><li>cgroups以一个伪文件系统的方式实现，用户态的程序可以通过文件操作实现cgroups的组织管理</li><li>cgroups组织管理的单元可以细到线程级别，用户可以创建和销毁cgroup，实现资源再分配和管理</li><li>所有资源管理都以子系统的方式实现，接口统一</li><li>子任务创建之初与父任务处于同一cgroup</li></ul><h1 id="cgroups的核心功能和术语"><a href="#cgroups的核心功能和术语" class="headerlink" title="cgroups的核心功能和术语"></a>cgroups的核心功能和术语</h1><p>cgroups为不同用户层面的资源管理提供了一个统一化的接口，实现了资源的虚拟化，主要提供了四大功能：</p><ul><li><strong>资源限制</strong>：cgroups可以对任务组使用的资源总额进行限制，如内存上限</li><li><strong>优先级</strong>：通过分配CPU时间片数量及磁盘IO带宽大小，变相控制任务优先级</li><li><strong>资源统计</strong>：统计资源使用量，如CPU使用时长，适用于计费</li><li><strong>任务控制</strong>：cgroups可以对任务执行挂起、恢复等操作。</li></ul><p>cgroups的几个术语</p><ul><li><strong>task(任务)</strong>:表示系统的一个进程或线程</li><li><strong>cgroup(控制组)</strong>:cgroups资源控制的最小单位，表示按某种资源控制标准划分的任务组，包含一个或多个子系统。一个任务可以加入某个cgroup，也可以从某个cgroup迁移到另一个cgroup</li><li><strong>subsystem(子系统)</strong>：资源调度器，如CPU子系统、内存子系统</li><li><strong>hierarchy(层级)</strong>：由一系列cgroup以树状结构排列而成，每个层级绑定子系统进行资源控制。层级中cgroup节点可以有0或多个子节点，子节点继承父节点的子系统。整个操作系统有多个层级。</li></ul><h1 id="cgroups的组织结构和基本规则"><a href="#cgroups的组织结构和基本规则" class="headerlink" title="cgroups的组织结构和基本规则"></a>cgroups的组织结构和基本规则</h1><p>前面说到cgroup是一个树状结构，但系统中多个cgroup构成的并非一个单根结构，而是可以存在多个，最终构成了一个cgroup森林。这样做的目的是，如果只有一个层级，则所有的任务都将被迫绑定其上的所有子系统，这会给某些人物带来不必要的限制。在Docker中，每个子系统独自构成一个层级，这样做非常易于管理。组织结构图如下：</p><p><img src="http://ww1.sinaimg.cn/mw690/aa213e02jw1eup8axdxb5j21fp1hs465.jpg" alt="image"></p><p>上面这个图从整体结构上描述了进程与 cgroups 之间的关系。最下面的P代表一个进程。每一个进程的描述符中有一个指针指向了一个辅助数据结构css_set（cgroups subsystem set）。 指向某一个css_set的进程会被加入到当前css_set的进程链表中。一个进程只能隶属于一个css_set，一个css_set可以包含多个进程，隶属于同一css_set的进程受到同一个css_set所关联的资源限制。</p><p>上图中的”M×N Linkage”说明的是css_set通过辅助数据结构可以与 cgroups 节点进行多对多的关联。但是 cgroups 的实现不允许css_set同时关联同一个cgroups层级结构下多个节点。 这是因为 cgroups 对同一种资源不允许有多个限制配置。</p><p>一个css_set关联多个 cgroups 层级结构的节点时，表明需要对当前css_set下的进程进行多种资源的控制。而一个 cgroups 节点关联多个css_set时，表明多个css_set下的进程列表受到同一份资源的相同限制。</p><p>cgroups、任务、子系统、层级四者间的关系及其基本规则如下：</p><ul><li>同一个层级可以附加一个或多个子系统</li><li>一个已经附加在某个层级上的子系统不能附加到其他含有别的子系统的层级上。</li><li>一个任务不能存在于同一个层级的不同cgroup中，但可以存在不同层级的多个cgroup中。</li><li>刚fork/clone出的子任务在初始状态与其父任务处于同一个cgroup，但子任务允许被移动到不同的cgroup中。</li></ul><h1 id="子系统简介"><a href="#子系统简介" class="headerlink" title="子系统简介"></a>子系统简介</h1><p>子系统就是cgroups的资源控制系统，每种子系统独立地控制一种资源，目前Docker使用如下9种子系统：</p><ul><li>blkio:块设备输入/输出限制，如物理驱动设备(包括磁盘、固态、USB等)。Linux中分为块设备和字符设备两种，块设备以块存储数据，可以进行数据的寻址；字符设备提供连续的数据流，按字节/字符读取，如键盘、串口等。</li><li>cpu: 使用调度程序控制任务对cpu的使用</li><li>cpuacct：自动生成cgroup中任务对CPU资源使用情况的报告</li><li>cpuset: 可以为cgroup中任务数分配独立的cpu(针对多处理器)</li><li>devices: 可以开启或关闭对设备的访问</li><li>freezer: 挂起或恢复cgroup中的任务</li><li>memory: 可以设定cgroup中任务对内存使用量的限定，并自动生成内存使用情况报告</li><li>perf_event: 对cgroup中的任务可以进行统一的性能测试</li><li>net_cls: 使用等级识别符标记网络数据包，从而允许Linux流量控制程序识别从具体cgroup中生成的数据包</li></ul><h1 id="cgroups实现方式"><a href="#cgroups实现方式" class="headerlink" title="cgroups实现方式"></a>cgroups实现方式</h1><p>cgroups的实质是给任务挂上钩子，当任务运行的工程中涉及某种资源时，就会触发钩子上所附带的子系统进行检测，根据资源类别的不同，使用相应的技术进行资源限制和优先级分配。</p><p>cgroup与任务是多对多的关系，它们不直接关联，而是通过一个中间结构把双向的关联信息记录起来，类似于数据库中的中间表。任务结构体task_struct中包含了一个指针，可以查询相应的cgroup情况，同时可以查询子系统的状态，子系统状态中也包含了找到任务的指针。</p><p>一个cgroup创建完成，不管绑定了何种子系统，其目录下都会生成以下几个文件，用来描述cgroup相应信息。</p><ul><li>tasks： 这个文件罗列所有在该cgroup中任务的TID，即所有进程或线程的ID，并不保证有序。</li><li>cgroup.procs: 罗列所有在该cgroup中的TGID(线程组ID)，即线程组中的一个进程的PID。不保证有序和无重复，写一个TGID到这个文件就代表把与其相关的线程加到这个cgroup中。</li><li>notify_on_release: 填0或1，表示cgroup中最后一个任务退出时通知运行release_agent，默认不运行(0)</li><li>release_agent：指定release_agent执行脚本的文件路径，用于自动化卸载无用的cgroup</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>cgroups通过与cgroup关联的子系统，形成了对进程组的资源限制。它一个伪文件系统的方式实现，并可以通过文件操作实现组织管理，最终提供了资源限制、优先级分配、资源统计、任务控制四大功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;资源隔离技术namespace通过系统调用构建了一个相对隔离的shell环境，在该环境下资源的使用不会影响宿主机，这已经有“容器”的雏形了。而如何将隔离出来的资源合理的使用，这就需要另一个强大的内核工具——cgroups。它不仅可以限制被namespace隔离的资源，还可以为资源设置权重、计算使用量、操控任务(进程或线程)启停等，Docker通过cgroups进行运行时资源的限制。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.wangjialong.cc/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.wangjialong.cc/tags/Linux/"/>
    
      <category term="Docker" scheme="http://www.wangjialong.cc/tags/Docker/"/>
    
      <category term="cgroups" scheme="http://www.wangjialong.cc/tags/cgroups/"/>
    
  </entry>
  
  <entry>
    <title>Collection简介</title>
    <link href="http://www.wangjialong.cc/2017/11/04/java_collection/"/>
    <id>http://www.wangjialong.cc/2017/11/04/java_collection/</id>
    <published>2017-11-03T16:00:00.000Z</published>
    <updated>2017-11-04T15:42:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Java编程中集合类可以说给我们提供了很多的便利，在享受它带来的便利的时候，有时候也会想它的内部是怎么实现的，近期给自己定了个小目标，就是把Collection接口相关的jdk源码看一下，进行一个系统的总结和梳理，一方面提升自己源码阅读的能力，另一方面，通过阅读大神的代码，是自己对于集合这块的数据结构有个更加深刻的了解，对自己以后的使用相信也会有很大的益处。因为自己平时其他的事情也比较多，而且jdk1.8中相关的类也比较多，就先定一个月的时间吧，截止日期12月1日，希望可以完成。</p><a id="more"></a><h1 id="Collection体系综述"><a href="#Collection体系综述" class="headerlink" title="Collection体系综述"></a>Collection体系综述</h1><p>阅读源码首先得有一个总体的结构认识，不然直接一头扎到类中的每个方法实现细节，只能是盲人摸象，摸到啥算啥。因此，我决定从Java SE 1.8的官方API入手，先梳理Collection这个核心接口，搞清楚它的父接口、子接口以及实现类，形成一个宏观的认识，然后再对它的子接口及其实现类分模块进行梳理，相信会对之后的阅读有一个引导作用。</p><p>Collection接口的关系图如下：</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-4/24208556.jpg" alt=""></p><ul><li>上图中菱形代表的是接口，矩形代表的是类，箭头所指的方向为父类或父接口</li></ul><p>Collection继承了Iterable接口，Iterable接口在1.8之前都只有一个抽象方法，叫做iterator,返回一个Iterator对象，也就是说，该接口赋予了Collection遍历自己的能力。因此，一个Collection的子类拥有如下的特点：</p><ul><li>元素的集合，{element1, element2, …, elementn}</li><li>可以通过返回的Iterator进行遍历</li><li>具有add、remove方法，可以添加或删除元素、集合。</li><li>1.8之后，removeIf方法可以传入lambda表达式，通过条件判断进行删除</li></ul><h1 id="Collection子接口综述"><a href="#Collection子接口综述" class="headerlink" title="Collection子接口综述"></a>Collection子接口综述</h1><p>由上图可以看出，Collection接口的主要子接口为Set、List、Queue(<em>BeanContext并不属于Collection 框架中的成员，且其位于java.beans.beancontext包中，暂时不进行讨论</em>)，三个子接口的特点如下:</p><ul><li>Set接口表示的一类集合，该集合中element不可重复，且没有先后顺序</li><li>List接口表示的类似于数组的一类集合，该集合有先后顺序且可以通过下标进行访问，且可以存放重复元素</li><li>Queue通常表示的为FIFO序列，优先队列根据优先级弹出，Queue也就是队列的一个统一接口</li></ul><p>除了上面的三个直接子接口，Map接口也是Collection Framework中重要的一员，它代表的是一组<k,v>键值对，也可以称为hash表，可以通过key值来访问指定的元素。</k,v></p><p>Collection的相关子接口、子类关系如下表所示：</p><table><thead><tr><th>接口名</th><th>Hash表</th><th>变长数组（Resizable Array）</th><th>平衡树(Balanced Tree)</th><th>链表(Linked List)</th><th>链表实现的Hash表</th></tr></thead><tbody><tr><td>Set</td><td>HashSet</td><td></td><td>TreeSet(红黑树)</td><td></td><td>LinkedHashSet</td></tr><tr><td>List</td><td></td><td>ArrayList</td><td></td><td>LinkedList</td></tr><tr><td>Deque</td><td></td><td>ArrayList</td><td></td><td>LinkedList</td></tr><tr><td>Map</td><td>HashMap</td><td></td><td>TreeMap(红黑树)</td><td></td><td>LinkedHashMap</td></tr></tbody></table><h1 id="Collections类"><a href="#Collections类" class="headerlink" title="Collections类"></a>Collections类</h1><p>Collections类并不是Collection接口的一个实现类，但它却和Collection接口息息相关，因为该类是集合的一个工具类，方法均为静态方法，传入参数大多数为List，也有一部分为Collection。该类是一个集合算法的工具类，提供了诸如集合排序和查找的算法，下面对提供的算法进行一个总结。</p><h2 id="改变元素顺序的方法"><a href="#改变元素顺序的方法" class="headerlink" title="改变元素顺序的方法"></a>改变元素顺序的方法</h2><p>sort方法提供了对List及其子类的排序功能(毕竟Set无序)，内部实现的算法是归并排序的算法，该方法是快速和稳定的。</p><ul><li><strong>快速：</strong>保证时间复杂度在O(n logn)</li><li><strong>稳定：</strong>不重排列相等的元素，这在多次排序中很重要，第二次排序希望第一次排完序的部分保持</li></ul><p>sort方法的方法头如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span></span></div></pre></td></tr></table></figure><ul><li>可以自定义Comparator实现升序、降序排序</li></ul><p>swap方法提供了对List指定两个位置元素进行交换的方法，声明为<code>public static void swap(List&lt;?&gt; list, int i, int j)</code>，将位于i,j的元素进行交换</p><p>shuffle方法提供了对List及其子类的乱序功能，它可以利用一个Random对象，随机的将位于i的元素和位于random.nextInt(i)的元素交换，核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=size; i&gt;<span class="number">1</span>; i--)</div><div class="line">    swap(list, i-<span class="number">1</span>, rnd.nextInt(i));</div></pre></td></tr></table></figure><ul><li>在i-1的位置时，从i到size的元素已经被乱序，因此使用nextInt(i)随机的与前i个元素中的一个进行交换</li><li>该方法在形成测试数据时很适用</li></ul><p>reverse方法将List首尾倒置，该方法的时间复杂度为O(n),核心代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>, mid=size&gt;&gt;<span class="number">1</span>, j=size-<span class="number">1</span>; i&lt;mid; i++, j--)</div><div class="line">    swap(list, i, j);</div></pre></td></tr></table></figure><h2 id="改变元素值的方法"><a href="#改变元素值的方法" class="headerlink" title="改变元素值的方法"></a>改变元素值的方法</h2><p>fill方法将List的每个元素设置为指定的元素，该方法在进行数组的初始化时适用。</p><p>replaceAll方法将List中指定的旧值设置为新值。</p><p>copy方法将src list中的元素全部拷贝到dest list中，并覆盖dest list.</p><h2 id="查询类方法"><a href="#查询类方法" class="headerlink" title="查询类方法"></a>查询类方法</h2><p>max方法和min方法分别返回序列中的最大值和最小值，通过遍历找到最大、最小值。</p><p>binarySearch方法在一个排好序的方法使用二分查找的方法查找一个元素的位置，该方法对于实现了RandomAccess接口的序列可以在logn时间内找到该元素，但对于未实现该接口，该方法将使用遍历的算法进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (list <span class="keyword">instanceof</span> RandomAccess || list.size()&lt;BINARYSEARCH_THRESHOLD)</div><div class="line">    <span class="keyword">return</span> Collections.indexedBinarySearch(list, key);</div><div class="line"><span class="keyword">else</span></div><div class="line">    <span class="keyword">return</span> Collections.iteratorBinarySearch(list, key);</div></pre></td></tr></table></figure><p>disjoint方法传入两个集合，如果两个集合没有交集，则返回true，否则，返回false.</p><h2 id="序列初始化"><a href="#序列初始化" class="headerlink" title="序列初始化"></a>序列初始化</h2><p>empty*方法可以返回空List、Set等。</p><p>synchronized*方法可以将传入的List、Set等，返回线程安全的List、Set，适用于多线程编程，但其内部使用的synchronized同步语句，因此并发度不高。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Collection Framework是Java集合编程的一个重要的工具，通过梳理Collection接口，基本理清了涉及到的接口和对象，接下来将按照List、Set、Queue、Map的顺序依次进行各自模块的梳理。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Java编程中集合类可以说给我们提供了很多的便利，在享受它带来的便利的时候，有时候也会想它的内部是怎么实现的，近期给自己定了个小目标，就是把Collection接口相关的jdk源码看一下，进行一个系统的总结和梳理，一方面提升自己源码阅读的能力，另一方面，通过阅读大神的代码，是自己对于集合这块的数据结构有个更加深刻的了解，对自己以后的使用相信也会有很大的益处。因为自己平时其他的事情也比较多，而且jdk1.8中相关的类也比较多，就先定一个月的时间吧，截止日期12月1日，希望可以完成。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.wangjialong.cc/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="Collection" scheme="http://www.wangjialong.cc/tags/Collection/"/>
    
  </entry>
  
  <entry>
    <title>Linux中的namespace综述</title>
    <link href="http://www.wangjialong.cc/2017/11/01/linux_namespace/"/>
    <id>http://www.wangjialong.cc/2017/11/01/linux_namespace/</id>
    <published>2017-10-31T16:00:00.000Z</published>
    <updated>2017-11-01T11:49:34.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>namespace是Linux内核中实现资源隔离的手段，通过将资源对象划分为不同的namespace，有效的防止了资源的误用，也防止了不同namespace间资源的互扰。Docker的资源隔离在本质上使用了namespace，达到容器资源与宿主机的隔离，防止容器对宿主机的资源侵染。</p><a id="more"></a><h1 id="namespace类型"><a href="#namespace类型" class="headerlink" title="namespace类型"></a>namespace类型</h1><p>Linux内核提供了6种namespace隔离的系统调用，这也是一个容器所需要做的6项隔离，具体的隔离类型见下表。</p><table><thead><tr><th>namespace</th><th>系统调用参数</th><th>隔离对象</th></tr></thead><tbody><tr><td>UTS</td><td>CLONE_NEWUTS</td><td>主机名与域名</td></tr><tr><td>IPC</td><td>CLONE_NEWIPC</td><td>信号量、消息队列和共享内存</td></tr><tr><td>PID</td><td>CLONE_NEWPID</td><td>进程编号</td></tr><tr><td>Network</td><td>CLONE_NEWNET</td><td>网络设备、网络栈、端口等</td></tr><tr><td>Mount</td><td>CLONE_NEWNS</td><td>挂载点（文件系统）</td></tr><tr><td>User</td><td>CLONE_NEWUSER</td><td>用户和用户组</td></tr></tbody></table><ul><li>Mount对应的系统调用参数比较特殊，因为它是第一个namespace，所以定义为了CLONE_NEWNS，而不是相关语义</li></ul><p>Docker的启动，首先就是需要一个文件系统，也就是一个挂载点(Mount)，有了它，容器的存储就能和宿主机的隔离开来；紧接着就是需要网络的隔离(Network)，因为容器之间需要通过独立的IP、端口等进行分布式环境下的通信，有了它，容器就能形成一个隔离于宿主机的“内网”环境，此处的“内网”指的是容器组成的网络。有了容器组成的网络，自然而然每个容器都需要一个主机名来在网络中标识自己，因此就需要主机名和域名的隔离(UTS)。容器内部进程可能会形成协同工作，因此需要进程间的通信，自然就需要信号量、消息队列和共享内存的隔离(IPC)。而容器的进程和宿主机的进程如何进行区分呢？自然需要不同的进程号，因此需要进行进程号隔离(PID)。有了这些，进程和文件的权限自然也离不开用户权限的隔离(User)。因此，上表中的6项namespace基本满足了docker所需要的全部隔离对象。</p><h1 id="namespace的API"><a href="#namespace的API" class="headerlink" title="namespace的API"></a>namespace的API</h1><p>Linux内核提供了几种namespace操作的方式，其中包括了系统函数调用和文件描述。系统函数调用包括了clone()、setns()、unshare()，文件描述主要是/proc下的文件。在使用系统调用的时候，通常需要6个参数中的一个或者多个，通过|(位或)连接。6个参数即是表格中的CLONE_NEWUTS、CLONE_NEWIPC、CLONE_NEWPID、CLONE_NEWNET、CLONE_NEWNS和CLONE_NEWUSER。</p><h2 id="通过clone-创建namespace"><a href="#通过clone-创建namespace" class="headerlink" title="通过clone()创建namespace"></a>通过clone()创建namespace</h2><p>使用clone()来创建一个独立namespace的进程，是最常见的做法，也是Docker使用namespace最基本的方法，它在创建一个进程的同时，顺带创建了一个独立的namespace。调用方式如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int clone(int (*child_func)(void *), void *child_stack, int flags, void *args)</div></pre></td></tr></table></figure><p>clone()实际上是fork()的一种更通用的实现，它通过flags来控制使用多少功能，一共有20多种CLONE_*的flag参数。clone函数的参数说明如下：</p><ul><li>child_func传入子进程运行的程序主函数</li><li>child_stack传入子进程的栈空间</li><li>flags表示使用哪些CLONE_*标志位，与namespace相关的为上面提到的6个。</li><li>args用于传入用户参数。</li></ul><h2 id="proc-pid-ns文件"><a href="#proc-pid-ns文件" class="headerlink" title="/proc/[pid]/ns文件"></a>/proc/[pid]/ns文件</h2><p>用户可以在/proc/[pid]/ns文件下看到指向不同namespace号的文件，效果如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ls -l /proc/$$/ns</span></div><div class="line">total 0</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 ipc -&gt; ipc:[4026531839]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 mnt -&gt; mnt:[4026531840]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 net -&gt; net:[4026531956]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 pid -&gt; pid:[4026531836]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 user -&gt; user:[4026531837]</div><div class="line">lrwxrwxrwx. 1 root root 0 Oct 31 18:58 uts -&gt; uts:[4026531838]</div></pre></td></tr></table></figure><ul><li>形如[4026531839]即为namespace号</li><li>$$是shell中表示当前运行的进程ID号</li></ul><p>若两个进程指向的namespace号相同，就说明它们在同一个namespace下。/proc/[pid]/ns里的link文件一旦被打开，只要该文件描述符存在，即使该namespace下所有进程都已经结束，这个namespace也会存在，可以通过文件描述符将后续进程加入进来。Docker就是通过文件描述符定位和加入namespace的。</p><p>通过–bind方式挂载可以起到同样作用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># touch ~/uts</span></div><div class="line"><span class="comment"># mount --bind /proc/27514/ns/uts ~/uts</span></div></pre></td></tr></table></figure><p>上述命令将~/uts文件与该namespace文件绑定，可以通过~/uts文件来使得后续进程加入该namespace中。</p><h2 id="setns-加入已存在的namespace"><a href="#setns-加入已存在的namespace" class="headerlink" title="setns()加入已存在的namespace"></a>setns()加入已存在的namespace</h2><p>上面使用挂载方式将namespace保留下来，可以使用setns()系统调用加入该namespace，使用方法如下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">setns</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> nstype)</span></span>;</div></pre></td></tr></table></figure><ul><li>参数fd表示要加入namespace的文件描述符，可以通过open()，打开挂载的文件(如~/uts）获得。</li><li>nstype让调用者可以检查fd指向的namespace是否符合要求。为0表示不检查。</li></ul><p>典型用法如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">fd=open(argv[<span class="number">1</span>], O_RDONLY);</div><div class="line">setns(fd, <span class="number">0</span>);</div><div class="line">execvp(argv[<span class="number">2</span>], &amp;argv[<span class="number">2</span>]);</div></pre></td></tr></table></figure><p>假设该程序编译为setns-test</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># ./setns-test ~/uts /bin/bash</span></div></pre></td></tr></table></figure><p>可以在新加入的namespace中执行shell命令了。</p><h2 id="unshare-在原进程上进行namespace隔离"><a href="#unshare-在原进程上进行namespace隔离" class="headerlink" title="unshare()在原进程上进行namespace隔离"></a>unshare()在原进程上进行namespace隔离</h2><p>unshare()运行在原进程上，不需要启动新进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">unshare</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</div></pre></td></tr></table></figure><p>unshare()可以在不启动新进程的前提下，跳出原先的namespace进行操作，以达到隔离的目的。</p><h1 id="UTS-namespace"><a href="#UTS-namespace" class="headerlink" title="UTS namespace"></a>UTS namespace</h1><p>UTS(UNIX Time-sharing System) namespace提供了主机名和域名的隔离，这样每个docker都可以拥有独立的主机名和域名，在网络上可以被视为一个独立的节点，而非宿主机上的一个进程。Docker中，每个镜像基本都以自身所提供的服务名称来命名镜像的hostname，且不会对宿主机有任何影响，其原理就是利用了UTS namespace。</p><h1 id="IPC-namespace"><a href="#IPC-namespace" class="headerlink" title="IPC namespace"></a>IPC namespace</h1><p>进程间通信(Inter-Process Communication)涉及的IPC资源包括常见的信号量、消息队列和共享内存。申请IPC资源就申请了一个全局唯一的32位ID，所以IPC namespace实际上包含了系统IPC标识符以及实现POSIX消息队列的文件系统。在同一个IPC namespace下的进程彼此可见，不同IPC namespace下的进程则互相不可见。</p><p>Docker使用IPC namespace实现了容器与宿主机、容器与容器之间的IPC隔离。</p><h1 id="PID-namespace"><a href="#PID-namespace" class="headerlink" title="PID namespace"></a>PID namespace</h1><p>PID namespace隔离对进程PID重新编号，使得两个不同namespace下的进程可以有相同的PID。每个PID namespace都有自己的计数器。内核为所有的PID namespace维护了一个树状结构，最顶层的为系统初始时创建，为root namespace。树状结构中的父子节点对应的为namespace的父子关系。父节点可以看到子节点中的进程，并可以通过信号对子节点中进程产生影响。反之，子节点无法看到父节点中德任何内容。</p><ul><li>每个PID namespace中的第一个进程“PID 1”，就像Linux中的init进程一样，拥有特权</li><li>一个namespace中的进程不能通过kill或ptrace影响父节点或兄弟节点中的进程。</li><li>如果在新的PID namespace中重新挂载/proc文件系统，会发现只显示同属一个PID namespace中的其他进程</li><li>在root namespace中可以看到所有进程，并可以通过递归包含所有子节点中进程。</li></ul><p>因此，要实现外部监控Docker运行的程序，可以通过监控Docker daemon所在的PID namespace下的所有进程及其子进程，在进行筛选即可。</p><h1 id="mount-namespace"><a href="#mount-namespace" class="headerlink" title="mount namespace"></a>mount namespace</h1><p>mount namespace通过隔离文件系统挂载点来对文件系统进行隔离保护，隔离后，不同mount namespace下的文件结构变化互不影响。可以通过/proc/[pid]/mounts查看到所有挂载在当前namespace中的文件系统，还可以通过/proc/[pid]/mountstats看到文件设备的统计信息，包括挂载文件的名字、文件系统类型、挂载位置等。</p><p>进程在创建mount namespace时，会把当前的文件结构复制给新的namespace。新的namespace中所有的mount操作都只影响自身的文件系统，对外界不影响。但若父节点进程中挂载了一个CD-ROM，此时子节点namespace无法自动挂载该CD-ROM。</p><p>挂载传播定义了挂载对象之间的关系，包括共享关系和从属关系。</p><ul><li><strong>共享关系</strong>。若两个挂载对象具有共享关系，则一个挂载对象中的挂载事件会传播到另一个挂载对象中。反之亦然。</li><li><strong>从属关系</strong>。若两个挂载对象形成从属关系，则一个挂载对象中的挂载事件会传播到另一个挂载对象中，但是反之不行。</li></ul><p>一个挂载状态可能为以下中的一种：</p><ul><li>共享挂载</li><li>从属挂载</li><li>共享/从属挂载</li><li>私有挂载</li><li>不可绑定挂载</li></ul><p>传播事件的为共享挂载，接受传播事件的为从属挂载，同时具有前两者特征的为共享/从属挂载，既不传播又不接受传播事件的为私有挂载，而不可绑定挂载除具有私有挂载约束外，不允许执行绑定挂载，即创建mount namespace时这块文件对象不可被复制。</p><h1 id="network-namespace"><a href="#network-namespace" class="headerlink" title="network namespace"></a>network namespace</h1><p>network namespace提供了关于网络资源的隔离，包括网络设备、IPV4和IPv6协议栈、IP路由表、防火墙、/proc/net目录、/sys/class/net目录、套接字（socket）等。一个物理的网络设备最多存在于一个network namespace中，可以通过创建 veth pair在不同的network namespace间创建管道，以达到通信目的。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-1/18129128.jpg" alt=""></p><p>Docker网络如上图所示，使用veth pair创建一个独立网络实体，进行通信。veth pair一端放置在容器的namespace中，通常命名为eth0，一端放在原先的namespace中连接物理网络设备，再通过多个设备连入网桥或者进行路由转发，实现通信的目的。</p><h1 id="user-namespace"><a href="#user-namespace" class="headerlink" title="user namespace"></a>user namespace</h1><p>user namespace隔离了安全相关的标识符和属性，包括用户id、用户组id、key（指密钥）以及特殊权限。一个普通用户的进程创建的新进程在新user namespace中可以拥有不同的用户和用户组。也就是说，一个进程在容器外属于没有特权的普通用户，但进入容器却属于拥有所有权限的超级用户，这使得在保护宿主机的安全基础上，为容器提供了极大的自由。</p><ul><li>user namespace被创建后，第一个进程被赋予了该namespace中的全部权限，这样该init进程就可以完成所有必要的初始化工作，而不会因为权限不足出现错误。</li><li>从namespace内部观察的UID和GID已经与外部不同，默认为65534，表示尚未与外部namespace用户映射。此时可以进行映射，以保证当涉及一些外部namespace操作时，系统可以检验其权限。</li><li>用户在新namespace中有全部权限，但他在创建它的父namespace中不含任何权限。因此即使root用户调用clone在user namespace创建了新用户，它在外部也没有任何权限。</li><li>user namespace的创建其实是一个层层嵌套的树状结构。最上层是root namespace，新创建的每个user namespace都有一个父节点，以及零个或多个子节点。</li></ul><p>Docker不仅使用了user namespace，还使用了在user namespace中涉及的Capabilities机制。Linux把原来和超级用户相关的高级权限划分为不同的单元，称为Capabilities。这样管理员可以独立的对特定的Capabilities进行使用和禁止。Docker同时使用两者，在很大程度上加强了容器的安全性。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>namespace是一个在很多地方都有应用的概念，Linux使用该概念进行了6项资源的限制，对资源的使用进行了保护。Docker起源于Linux，利用namespace达成了容器与宿主机、容器与容器间的资源隔离。利用namespace，我们可以在容器中为所欲为，而对宿主机没有丝毫的影响，这也是容器的便利之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;namespace是Linux内核中实现资源隔离的手段，通过将资源对象划分为不同的namespace，有效的防止了资源的误用，也防止了不同namespace间资源的互扰。Docker的资源隔离在本质上使用了namespace，达到容器资源与宿主机的隔离，防止容器对宿主机的资源侵染。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.wangjialong.cc/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://www.wangjialong.cc/tags/Linux/"/>
    
      <category term="Docker" scheme="http://www.wangjialong.cc/tags/Docker/"/>
    
      <category term="namespace" scheme="http://www.wangjialong.cc/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>Etcd集群安装</title>
    <link href="http://www.wangjialong.cc/2017/10/31/etcd_install/"/>
    <id>http://www.wangjialong.cc/2017/10/31/etcd_install/</id>
    <published>2017-10-30T16:00:00.000Z</published>
    <updated>2017-10-31T11:24:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>Etcd是一个分布式的K/V存储组件，主要用于存储元数据和配置数据，典型应用是Kubernetes中，用于服务发现和节点注册。本篇文章主要介绍了3节点下安装Etcd集群及其配置过程，主要参考了<a href="http://blog.frognew.com/2017/04/install-etcd-cluster.html" target="_blank" rel="external">青蛙小白</a>的博客，解决了安装过程中的一部分问题，并加入了etcdctl工具的配置步骤，方便日后的参考。</p><a id="more"></a><h1 id="环境信息"><a href="#环境信息" class="headerlink" title="环境信息"></a>环境信息</h1><p>Centos 7<br>IP | hostname<br>—|—<br>192.168.202.131 | etcd-1<br>192.168.202.132 | etcd-2<br>192.168.202.133 | etcd-3</p><h1 id="TLS密钥和证书"><a href="#TLS密钥和证书" class="headerlink" title="TLS密钥和证书"></a>TLS密钥和证书</h1><p>部署的etcd集群使用TLS证书对集群中节点间通信进行加密，并开启基于CA根证书签名的双向数字证书认证。本文档使用<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="external">cfssl</a>来生成CA证书以及其他需要的证书。生成的证书列表如下：  </p><ul><li>ca.pem</li><li>etcd.pem</li><li>etcd-key.pem<br>下面介绍使用cfssl生成所需要的私钥和证书.</li></ul><h1 id="安装cfssl"><a href="#安装cfssl" class="headerlink" title="安装cfssl"></a>安装<a href="https://github.com/cloudflare/cfssl" target="_blank" rel="external">cfssl</a></h1><h2 id="方式一：直接使用二进制包安装"><a href="#方式一：直接使用二进制包安装" class="headerlink" title="方式一：直接使用二进制包安装"></a>方式一：直接使用二进制包安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl_linux-amd64</div><div class="line">$ chmod +x cfssl_linux-amd64</div><div class="line">$ sudo mv cfssl_linux-amd64 /root/local/bin/cfssl</div><div class="line"></div><div class="line">$ wget https://pkg.cfssl.org/R1.2/cfssljson_linux-amd64</div><div class="line">$ chmod +x cfssljson_linux-amd64</div><div class="line">$ sudo mv cfssljson_linux-amd64 /root/local/bin/cfssljson</div><div class="line"></div><div class="line">$ wget https://pkg.cfssl.org/R1.2/cfssl-certinfo_linux-amd64</div><div class="line">$ chmod +x cfssl-certinfo_linux-amd64</div><div class="line">$ sudo mv cfssl-certinfo_linux-amd64 /root/local/bin/cfssl-certinfo</div><div class="line"></div><div class="line">$ export PATH=/root/local/bin:$PATH</div></pre></td></tr></table></figure><h2 id="方式二：使用go命令安装"><a href="#方式二：使用go命令安装" class="headerlink" title="方式二：使用go命令安装"></a>方式二：使用go命令安装</h2><p>如果系统中安装过Go的话，可以直接使用命令安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ go get -u github.com/cloudflare/cfssl/cmd/...</div><div class="line">$ echo $GOPATH</div><div class="line">/usr/local</div><div class="line">$ ls /usr/local/bin/cfssl*</div><div class="line">cfssl cfssl-bundle cfssl-certinfo cfssljson cfssl-newkey cfssl-scan</div></pre></td></tr></table></figure></p><h1 id="创建CA证书"><a href="#创建CA证书" class="headerlink" title="创建CA证书"></a>创建CA证书</h1><h2 id="创建CA的配置文件ca-config-json"><a href="#创建CA的配置文件ca-config-json" class="headerlink" title="创建CA的配置文件ca-config.json"></a>创建CA的配置文件ca-config.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">$ mkdir /root/ssl</div><div class="line">$ cd /root/ssl</div><div class="line">$ cfssl print-defaults config &gt; ca-config.json</div><div class="line">$ cfssl print-defaults csr &gt; ca-csr.json</div><div class="line">$ cat ca-config.json</div><div class="line">&#123;</div><div class="line">  &quot;signing&quot;: &#123;</div><div class="line">    &quot;default&quot;: &#123;</div><div class="line">      &quot;expiry&quot;: &quot;8760h&quot;</div><div class="line">    &#125;,</div><div class="line">    &quot;profiles&quot;: &#123;</div><div class="line">      &quot;frognew&quot;: &#123;</div><div class="line">        &quot;usages&quot;: [</div><div class="line">            &quot;signing&quot;,</div><div class="line">            &quot;key encipherment&quot;,</div><div class="line">            &quot;server auth&quot;,</div><div class="line">            &quot;client auth&quot;</div><div class="line">        ],</div><div class="line">        &quot;expiry&quot;: &quot;87600h&quot;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>ca-config.json中可以定义多个profile，分别设置不同的expiry和usages等参数。如上面的ca-config.json中定义了名称为frognew的profile，这个profile的expiry 87600h为10年，useages中：</p><ul><li>signing表示此CA证书可以用于签名其他证书，ca.pem中的CA=TRUE</li><li>server auth表示TLS Server Authentication, 即client可以用该 CA 对server提供的证书进行验证</li><li>client auth表示TLS Client Authentication，即server可以用该CA对client提供的证书进行验证</li></ul><h2 id="创建CA证书签名请求配置ca-csr-json："><a href="#创建CA证书签名请求配置ca-csr-json：" class="headerlink" title="创建CA证书签名请求配置ca-csr.json："></a>创建CA证书签名请求配置ca-csr.json：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  &quot;CN&quot;: &quot;frognew&quot;,</div><div class="line">  &quot;key&quot;: &#123;</div><div class="line">    &quot;algo&quot;: &quot;rsa&quot;,</div><div class="line">    &quot;size&quot;: 2048</div><div class="line">  &#125;,</div><div class="line">  &quot;names&quot;: [</div><div class="line">    &#123;</div><div class="line">      &quot;C&quot;: &quot;CN&quot;,</div><div class="line">      &quot;ST&quot;: &quot;BeiJing&quot;,</div><div class="line">      &quot;L&quot;: &quot;BeiJing&quot;,</div><div class="line">      &quot;O&quot;: &quot;frognew&quot;,</div><div class="line">      &quot;OU&quot;: &quot;cloudnative&quot;</div><div class="line">    &#125;</div><div class="line">  ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>下面使用cfssl生成CA证书和私钥:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -initca ca-csr.json | cfssljson -bare ca</div><div class="line">$ ls ca*</div><div class="line">ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem</div></pre></td></tr></table></figure><h1 id="Etcd证书和私钥"><a href="#Etcd证书和私钥" class="headerlink" title="Etcd证书和私钥"></a>Etcd证书和私钥</h1><p>创建etcd证书签名请求配置etcd-csr.json：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    &quot;CN&quot;: &quot;frognew&quot;,</div><div class="line">    &quot;hosts&quot;: [</div><div class="line">      &quot;127.0.0.1&quot;,</div><div class="line">      &quot;192.168.202.131&quot;,</div><div class="line">      &quot;192.168.202.132&quot;,</div><div class="line">      &quot;192.168.202.133&quot;,</div><div class="line">      &quot;etcd-1&quot;,</div><div class="line">      &quot;etcd-2&quot;,</div><div class="line">      &quot;etcd-3&quot;</div><div class="line">    ],</div><div class="line">    &quot;key&quot;: &#123;</div><div class="line">        &quot;algo&quot;: &quot;rsa&quot;,</div><div class="line">        &quot;size&quot;: 2048</div><div class="line">    &#125;,</div><div class="line">    &quot;names&quot;: [</div><div class="line">        &#123;</div><div class="line">            &quot;C&quot;: &quot;CN&quot;,</div><div class="line">            &quot;ST&quot;: &quot;BeiJing&quot;,</div><div class="line">            &quot;L&quot;: &quot;BeiJing&quot;,</div><div class="line">            &quot;O&quot;: &quot;frognew&quot;,</div><div class="line">            &quot;OU&quot;: &quot;cloudnative&quot;</div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>注意上面配置hosts字段中制定授权使用该证书的IP和域名列表，因为现在要生成的证书需要被etcd集群各个节点使用，所以这里指定了各个节点的IP和hostname。</p><p>下面生成etcd的证书和私钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ cfssl gencert -ca=ca.pem -ca-key=ca-key.pem -config=ca-config.json -profile=frognew etcd-csr.json | cfssljson -bare etcd</div><div class="line"></div><div class="line">$ ls etcd*</div><div class="line">etcd.csr  etcd-csr.json  etcd-key.pem  etcd.pem</div></pre></td></tr></table></figure><ul><li><strong>注意</strong>：确认-config的参数文件名和路径正确，可以使用绝对路径；etcd-csr.json在当前目录下存在，也可以为绝对路径，否则会报config文件json格式有误，但并不是文件内容的错误，而是路径和文件名错误。<br>对生成的证书可以使用cfssl或者openssl查看：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cfssl-certinfo -cert etcd.pem</div><div class="line"></div><div class="line">$ openssl x509  -noout -text -in  etcd.pem</div></pre></td></tr></table></figure><ul><li>确认 Issuer 字段的内容和 ca-csr.json 一致；</li><li>确认 Subject 字段的内容和 etcd-csr.json 一致；</li><li>确认 X509v3 Subject Alternative Name 字段的内容和 etcd-csr.json 一致；</li><li>确认 X509v3 Key Usage、Extended Key Usage 字段的内容和 ca-config.json 中 profile 一致；</li></ul><h1 id="安装etcd"><a href="#安装etcd" class="headerlink" title="安装etcd"></a>安装etcd</h1><p>Etcd可以使用二进制安装和yum源安装两种方式</p><h2 id="二进制安装"><a href="#二进制安装" class="headerlink" title="二进制安装"></a>二进制安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget https://github.com/coreos/etcd/releases/download/v3.1.6/etcd-v3.1.6-linux-amd64.tar.gz</div></pre></td></tr></table></figure><p>解压缩etcd-v3.1.6-linux-amd64.tar.gz，将其中的etcd和etcdctl两个可执行文件复制到各节点的/usr/bin目录。</p><h2 id="yum源安装"><a href="#yum源安装" class="headerlink" title="yum源安装"></a>yum源安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ yum list etcd</div><div class="line">$ yum install -y etcd</div></pre></td></tr></table></figure><p>安装完成之后，在各节点创建etcd的数据目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mkdir -p /var/lib/etcd</div></pre></td></tr></table></figure><p>使用systemctl启动和管理etcd服务，在每个节点上创建etcd的systemd unit文件/usr/lib/systemd/system/etcd.service，注意替换ETCD_NAME和INTERNAL_IP变量的值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">export ETCD_NAME=node1</div><div class="line">export INTERNAL_IP=192.168.202.131</div><div class="line">cat  /usr/lib/systemd/system/etcd.service</div><div class="line">[Unit]</div><div class="line">Description=etcd server</div><div class="line">After=network.target</div><div class="line">After=network-online.target</div><div class="line">Wants=network-online.target</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=notify</div><div class="line">WorkingDirectory=/var/lib/etcd/</div><div class="line">EnvironmentFile=-/etc/etcd/etcd.conf</div><div class="line">ExecStart=/usr/bin/etcd \</div><div class="line">  --name $&#123;ETCD_NAME&#125; \</div><div class="line">  --cert-file=/etc/etcd/ssl/etcd.pem \</div><div class="line">  --key-file=/etc/etcd/ssl/etcd-key.pem \</div><div class="line">  --peer-cert-file=/etc/etcd/ssl/etcd.pem \</div><div class="line">  --peer-key-file=/etc/etcd/ssl/etcd-key.pem \</div><div class="line">  --trusted-ca-file=/etc/etcd/ssl/ca.pem \</div><div class="line">  --peer-trusted-ca-file=/etc/etcd/ssl/ca.pem \</div><div class="line">  --initial-advertise-peer-urls https://$&#123;INTERNAL_IP&#125;:2380 \</div><div class="line">  --listen-peer-urls https://$&#123;INTERNAL_IP&#125;:2380 \</div><div class="line">  --listen-client-urls https://$&#123;INTERNAL_IP&#125;:2379,https://127.0.0.1:2379 \</div><div class="line">  --advertise-client-urls https://$&#123;INTERNAL_IP&#125;:2379 \</div><div class="line">  --initial-cluster-token etcd-cluster-1 \</div><div class="line">  --initial-cluster node1=https://192.168.202.131:2380,node2=https://192.168.202.132:2380,node3=https://192.168.202.133:2380 \</div><div class="line">  --initial-cluster-state new \</div><div class="line">  --data-dir=/var/lib/etcd</div><div class="line">Restart=on-failure</div><div class="line">RestartSec=5</div><div class="line">LimitNOFILE=65536</div><div class="line"></div><div class="line">[Install]</div><div class="line">WantedBy=multi-user.target</div><div class="line">EOF</div></pre></td></tr></table></figure><ul><li>–data-dir指定了etcd的工作目录和数据目录是/var/lib/etcd</li><li>–cert-file和–key-file分别指定etcd的公钥证书和私钥</li><li>–peer-cert-file和–peer-key-file分别指定了etcd的Peers通信的公钥证书和私钥。</li><li>–trusted-ca-file指定了客户端的CA证书</li><li>–peer-trusted-ca-file指定了Peers的CA证书</li><li>–initial-cluster-state new表示这是新初始化集群，–name指定的参数值必须在–initial-cluster中  </li></ul><p><strong>注意</strong>：在etcd.pem生成时hosts配置了Ip地址列表和hostname列表，在etcd的service(/usr/lib/systemd/system/etcd.service)文件中，所有ip不能代替为未包含的hostname，如master</p><h1 id="启动Etcd"><a href="#启动Etcd" class="headerlink" title="启动Etcd"></a>启动Etcd</h1><p>在各节点上启动etcd：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ systemctl daemon-reload</div><div class="line">$ systemctl enable etcd</div><div class="line">$ systemctl start etcd</div><div class="line">$ systemctl status etcd</div></pre></td></tr></table></figure><p>在启动etcd的时候，可以开启另一个命令窗口，查看启动日志，确保没有报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">journalctl -f</div></pre></td></tr></table></figure><ul><li>如果出现了形如 <code>unkown flag</code>的字段，表示启动参数错误，不识别,说明该参数拼写错误(<em>如–keyfile应当为–key-file</em>),可以到官方配置文档<a href="https://github.com/coreos/etcd/blob/master/Documentation/op-guide/configuration.md" target="_blank" rel="external">Configuration flags</a>查看该参数的写法，确保正确。</li><li>如果出现<code>Failed to find member fXXXXXX</code>的错误，这说明之前启动的etcd时，标识号出现错误，此时删除<code>/var/lib/etcd/member</code>目录，让etcd重新为每个节点分配标识号, <code>/var/lib/etcd</code>为etcd启动配置工作目录</li></ul><p>如果日志一切正常，可以使用<code>etcdctl</code>检查集群是否健康，在任一节点执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">etcdctl \</div><div class="line">  --ca-file=/etc/etcd/ssl/ca.pem \</div><div class="line">  --cert-file=/etc/etcd/ssl/etcd.pem \</div><div class="line">  --key-file=/etc/etcd/ssl/etcd-key.pem \</div><div class="line">  --endpoints=https://node1:2379,https://node2:2379,https://node3:2379 \</div><div class="line">  cluster-health</div><div class="line"></div><div class="line">2017-04-24 19:53:40.545148 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">2017-04-24 19:53:40.546127 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">member 4f2f99d70000fc19 is healthy: got healthy result from https://192.168.202.132:2379</div><div class="line">member 99a756f799eb4163 is healthy: got healthy result from https://192.168.202.131:2379</div><div class="line">member a9aff19397de2e4e is healthy: got healthy result from https://192.168.202.133:2379</div><div class="line">cluster is healthy</div></pre></td></tr></table></figure><p>确保输出<code>cluster is healthy</code>的信息。<br>上面的命令使用证书访问，返回正常信息，若未添加证书，使用<code>etcdctl member list</code>访问，应当报错，否则，TLS(安全认证)未生效，即使用http访问etcd集群。</p><h1 id="etcdctl配置"><a href="#etcdctl配置" class="headerlink" title="etcdctl配置"></a>etcdctl配置</h1><p>由于使用了TLS安全认证，etcdctl 查询时需要在命令行中指定证书和endpoints，会使得一条命令变得很长，可以预先创建一个etcdctl配置文件，进行相应的配置.</p><ol><li>创建etcdctl配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$ vi /etc/etcd/etcdctl</div><div class="line">$ cat /etc/etcd/etcdctl</div><div class="line">export ETCDCTL_API=3</div><div class="line">export ETCDCTL_ENDPOINTS=&quot;https://etcd-1:2379,https://etcd-2:2379,https://etcd-3:2379&quot;</div><div class="line">export ETCDCTL_CACERT=/etc/etcd/ssl/ca.pem</div><div class="line">export ETCDCTL_CERT=/etc/etcd/ssl/etcd.pem</div><div class="line">export ETCDCTL_KEY=/etc/etcd/ssl/etcd-key.pem</div></pre></td></tr></table></figure><ol><li>使配置文件生效</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ source /etc/etcd/etcdctl</div></pre></td></tr></table></figure><ol><li>查看集群状态</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ etcdctl cluster-health</div><div class="line"></div><div class="line">2017-04-24 19:53:40.545148 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">2017-04-24 19:53:40.546127 I | warning: ignoring ServerName for user-provided CA for backwards compatibility is deprecated</div><div class="line">member 4f2f99d70000fc19 is healthy: got healthy result from https://192.168.202.132:2379</div><div class="line">member 99a756f799eb4163 is healthy: got healthy result from https://192.168.202.131:2379</div><div class="line">member a9aff19397de2e4e is healthy: got healthy result from https://192.168.202.133:2379</div><div class="line">cluster is healthy</div></pre></td></tr></table></figure><p>etcdctl配置的本质是定义ETCDCTL_ENDPOINT常量，etcdctl运行时读取该常量值，进行连接，具体的常量名称可以参考官方的配置说明<a href="https://github.com/coreos/etcd/tree/master/etcdctl" target="_blank" rel="external">etcdctl config</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/coreos/etcd/blob/master/Documentation/op-guide/clustering.md" target="_blank" rel="external">Clustering Guide</a></li><li><a href="https://github.com/coreos/etcd/tree/master/etcdctl" target="_blank" rel="external">etcdctl config</a></li><li><a href="https://github.com/cloudflare/cfssl" target="_blank" rel="external">cloudflare/cfssl</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;Etcd是一个分布式的K/V存储组件，主要用于存储元数据和配置数据，典型应用是Kubernetes中，用于服务发现和节点注册。本篇文章主要介绍了3节点下安装Etcd集群及其配置过程，主要参考了&lt;a href=&quot;http://blog.frognew.com/2017/04/install-etcd-cluster.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;青蛙小白&lt;/a&gt;的博客，解决了安装过程中的一部分问题，并加入了etcdctl工具的配置步骤，方便日后的参考。&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="http://www.wangjialong.cc/categories/kubernetes/"/>
    
    
      <category term="kubernetes" scheme="http://www.wangjialong.cc/tags/kubernetes/"/>
    
      <category term="etcd" scheme="http://www.wangjialong.cc/tags/etcd/"/>
    
  </entry>
  
  <entry>
    <title>HDFS永久性数据结构</title>
    <link href="http://www.wangjialong.cc/2017/10/20/hdfs_structer/"/>
    <id>http://www.wangjialong.cc/2017/10/20/hdfs_structer/</id>
    <published>2017-10-19T16:00:00.000Z</published>
    <updated>2017-10-24T12:04:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要讲解了HDFS是如何在磁盘上组织永久性数据的，主要从NameNode、Secondary NameNode和DataNode的目录结构以及fsimage和edits文件几个方面进行介绍，了解这些文件的用法有助于进行故障诊断和故障检出。</p><a id="more"></a><h1 id="Namenode的目录结构"><a href="#Namenode的目录结构" class="headerlink" title="Namenode的目录结构"></a>Namenode的目录结构</h1><p>NameNode在被格式化之后，会产生如下的目录结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$&#123;dfs.name.dir&#125;/</div><div class="line">|---current/</div><div class="line">    |--- VERSION</div><div class="line">    |--- edits</div><div class="line">    |--- fsimage</div><div class="line">    |--- fstime</div></pre></td></tr></table></figure><ul><li><code>${dfs.name.dir}</code> 是HDFS配置文件的一个属性名，存储着镜像内容，推荐配置为一个NFS的挂载。</li></ul><p>VERSION文件是一个Java属性文件，其中包含了正在运行的HDFS的版本信息，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">namespaceID=134368444</div><div class="line">cTime=0</div><div class="line">storageType=NAME_NODE</div><div class="line">layoutVersion=-18</div></pre></td></tr></table></figure><ul><li><code>namespaceID</code>属性是HDFS文件系统的唯一标识符，是在文件系统首次格式化(<code>hadoop namenode -format</code>)的时候设置的。datanode在注册到NameNode之前都不知道<code>namespaceID</code>的值，因此NameNode可以通过该属性来鉴别是否为新建的DataNode</li><li><code>cTime</code>属性标记了NameNode的创建时间，对于刚格式化的存储系统，该值为0，；但在文件系统升级之后，该值会更新到新的时间戳</li><li><code>storageType</code>属性说明该存储目录(<code>${dfs.name.dir}/current/</code>)</li><li><code>layoutVersion</code>属性是一个负整数，描述HDFS持久性数据结构（也称布局）的版本号，但是与Hadoop发布包的版本号无关。只要HDFS布局变更，版本号变回递减(-1)，此时，HDFS也需要升级。否则，磁盘仍然使用旧版本的布局，新版本的NameNode无法工作。</li></ul><p>NameNode的存储目录中还包含edits、fsimage、和fstime等二进制文件。这些文件都使用Hadoop的Writable对象作为其序列化格式。</p><h1 id="fsimage和edits-文件"><a href="#fsimage和edits-文件" class="headerlink" title="fsimage和edits 文件"></a>fsimage和edits 文件</h1><p>HDFS客户端执行写操作（创建、移动文件）时，这些操作信息都会记录在edits文件中。NameNode在内存中维护HDFS的元数据；当edits日志被修改时，内存中的元数据也会同步更新，该元数据支持客户端的读请求。</p><p>每次执行写操作时，首先修改edits文件，并进行更新和同步。在NameNode向多个目录写数据时，只有所有的写操作均完毕后方才返回成功代码，以确保不会因为机器故障而丢失(所有操作都在edits文件中，可以在恢复时进行相应操作的重演，类似于write ahead log的思想)。</p><p>fsimage是HDFS元数据的一个永久性的checkpoint。由于fsimage很大(可高达几个GB)，如果频繁写，会拖慢系统的运行，因此，并非每一次写操作都会更新该文件。在NameNode发生故障后，可以先将fsimage文件读入内存进行重构，然后执行edits中记录的各项操作，这也是NameNode启动阶段做的事情。</p><p>fsimage包含了HDFS中所有目录和文件inode的序列化信息。每个inode都是一个文件或目录的元数据内部描述。对文件，包含信息有”副本级别”(replication level)、修改时间和访问时间、访问许可、块大小、组成该文件的块等；对于目录，包含的信息有修改时间、访问许可和配额元数据等信息。</p><p>edits文件会无限增长，这虽然不会拖慢NameNode的运行，但会使得NameNode的启动异常耗时，有违用户的期待，因此，secondary NameNode应用而生。</p><p>Secondary NameNode辅助NameNode创建fsimage文件，它主要的功能有两个</p><ul><li>作为备份，在NameNode故障时升级为NameNode提供服务</li><li>定期合并edits和fsimage文件，防止NameNode故障重启时，由于fsimage长时间没有同步，执行edits的恢复操作很耗时。</li></ul><p>Secondary NameNode的工作步骤如下图所示</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-10-16/61956212.jpg" alt=""></p><ol><li>SecondaryNameNode通知NameNode准备提交edits文件，此时主节点将新的写操作数据记录到一个新的文件edits.new中。</li><li>SecondaryNameNode通过HTTP GET方式获取NameNode的fsimage与edits文件（在SecondaryNameNode的current同级目录下可见到 temp.check-point或者previous-checkpoint目录，这些目录中存储着从namenode拷贝来的镜像文件）。</li><li>Secondary NameNode将获取的fsimage文件载入内存，并逐一执行edits文件的操作，产生新的fsimage文件fsimage.chpt</li><li>SecondaryNameNode用HTTP POST方式发送fsimage.ckpt至NameNode。</li><li>NameNode将fsimage.ckpt与edits.new文件分别重命名为fsimage与edits，然后更新fstime，记录检查点执行的时间，到此整个checkpoint过程到此结束。</li></ol><p>最终，NameNode拥有一个更新的fsimage文件和一个更小的edits文件(在Secondary NameNode执行merge时，NameNode可能收到新的写请求)。在NameNode处在安全模式是，管理员可使用<code>hadoop dfsadmin -saveNamespace</code>命令主动创建checkpoint。</p><p>该过程解释了Secondary NameNode和NameNode拥有相近内存需求的原因，因为Secondary NameNode在合并时需要先将fsimage读入内存中。创建checkpoint的触发条件有两个限制：通常情况下，Secondary NameNode每个一小时(fs.checkpoint.period属性设置，以秒为单位)创建一次；此外，当edits文件达到64MB(fs.checkpoint.size属性设置，以字节为单位)，即使没到一小时，也会创建checkpoint。系统每5分钟检查一次edits的大小。</p><h1 id="Secondary-NameNode的目录结构"><a href="#Secondary-NameNode的目录结构" class="headerlink" title="Secondary NameNode的目录结构"></a>Secondary NameNode的目录结构</h1><p>创建checkpoint不仅为NameNode创建了checkpoint，还使得Secondary NameNode也有了一份备份数据(存储在previous.checkpoint目录中)，此数据可用于NameNode元数据的备份</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$&#123;fs.checkpoint.dir&#125;/</div><div class="line">|---current/</div><div class="line">|   |--- VERSION</div><div class="line">|   |--- edits</div><div class="line">|   |--- fsimage</div><div class="line">|   |--- fstime</div><div class="line">|---previous.checkpoint/</div><div class="line">    |--- VERSION</div><div class="line">    |--- edits</div><div class="line">    |--- fsimage</div><div class="line">    |--- fstime</div></pre></td></tr></table></figure><p>Secondary NameNode的previous.checkpoint/和current/与NameNode的current目录布局相同。在NameNode发生故障时，可以从Secondary NameNode恢复数据。有两种方法实现。</p><ol><li>将相应目录复制到新的NameNode中</li><li>使用-importCheckpoint选项，启动NameNode守护进程，从而是Secondary NameNode用作新的NameNode。</li></ol><h1 id="DataNode的目录结构"><a href="#DataNode的目录结构" class="headerlink" title="DataNode的目录结构"></a>DataNode的目录结构</h1><p>与NameNode不同，DataNode的存储目录是初始阶段自动创建的，不需额外格式化。结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">$&#123;dfs.data.dir&#125;/</div><div class="line">|---current/</div><div class="line">    |--- VERSION</div><div class="line">    |--- blk_&lt;id_1&gt;</div><div class="line">    |--- blk_&lt;id_1&gt;.meta</div><div class="line">    |--- blk_&lt;id_2&gt;</div><div class="line">    |--- blk_&lt;id_2&gt;.meta</div><div class="line">    |--- ...</div><div class="line">    |--- blk_&lt;id_64&gt;</div><div class="line">    |--- blk_&lt;id_64&gt;.meta</div><div class="line">    |--- subdir0/</div><div class="line">    |--- subdir1/</div><div class="line">    |--- ...</div><div class="line">    |--- subdir63/</div></pre></td></tr></table></figure><p>DataNode的VERSION文件与NameNode的VERSION文件类似，如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">namespaceID=134368444</div><div class="line">storageID=DS-547717739-172.16.85.1-50010-1236720751627</div><div class="line">cTime=0</div><div class="line">storageType=DATA_NODE</div><div class="line">layoutVersion=-18</div></pre></td></tr></table></figure><p>namespaceID、cTime、layoutVersion都与NameNode中的值相同。namespaceID是DataNode首次访问NameNode时获取的。storageID对每个DataNode来说是唯一的(但对单个DataNode中所有存储目录来说则相同)，NameNode可用该值区分不同DataNode。storageType表明该目录是DataNode的存储结构。</p><p>DataNode的current目录中其他文件都有blk_前缀，包括两种类型：HDFS块文件(仅包含原始数据)和块的元数据(.meta后缀)。块文件包含所存储文件的一部分原始数据(文件分块存储)；元数据包括头部(含版本和类型)及该块各区段的一系列校验和。</p><p>当目录中数据块文件增加到一定规模，DataNode会创建一个子目录来存放新的块和元数据信息。如果当前目录存储到64个(由dfs.datanode.numblocks设置)，就创建一个子目录。最终设计一个高扇出的目录树，即使快数量很多，但目录树的层数也不多。</p><p>如果dfs.data.dir属性指定不同磁盘上的多个目录，数据块会以轮转(round-robin)的方式写到各个目录中。同一个DataNode上的每个磁盘的块不重复，不同DataNode之间的块才可能重复（如三备份原则保证同一机架的两个DataNode备份，不同机架上有一个DataNode备份）</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要讲解了HDFS是如何在磁盘上组织永久性数据的，主要从NameNode、Secondary NameNode和DataNode的目录结构以及fsimage和edits文件几个方面进行介绍，了解这些文件的用法有助于进行故障诊断和故障检出。&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/tags/hadoop/"/>
    
      <category term="hdfs目录结构" scheme="http://www.wangjialong.cc/tags/hdfs%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>VMware虚拟机添加磁盘</title>
    <link href="http://www.wangjialong.cc/2017/10/19/vmware_addDisk/"/>
    <id>http://www.wangjialong.cc/2017/10/19/vmware_addDisk/</id>
    <published>2017-10-18T16:00:00.000Z</published>
    <updated>2017-10-24T12:04:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在搞使用CDH安装Hadoop的时候，需要搭建一个内网的yum源(参考<a href="http://www.wangjialong.cc/2017/09/14/private_yum/">使用httpd搭建内网yum源</a>)，并把CDH的RPM包放上去，方便虚拟机内网使用yum进行安装。由于我最开始虚拟机内网yum源只设置了20G的磁盘，硬盘剩余空间已经不够用，因此考虑给该虚拟机添加硬盘，并将该硬盘挂载到httpd的子目录上，在该磁盘上单独放CDH的包。</p><a id="more"></a><h1 id="新建硬盘"><a href="#新建硬盘" class="headerlink" title="新建硬盘"></a>新建硬盘</h1><p>VMware添加硬盘非常简单，只需要鼠标右键想要添加硬盘的虚拟机，然后点击添加，选择硬盘，根据向导进行添加即可。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-10-19/45118131.jpg" alt=""></p><p>图形化的向导使用非常方便，在此不作赘述，从上图可以看出，我已经添加了一个20G的硬盘到该虚拟机上，在上图的设备名为硬盘2.</p><h1 id="在虚拟机上查看磁盘信息"><a href="#在虚拟机上查看磁盘信息" class="headerlink" title="在虚拟机上查看磁盘信息"></a>在虚拟机上查看磁盘信息</h1><p>启动该虚拟机，在命令行使用<code>fdisk</code>命令查看添加的磁盘是否存在。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# fdisk -l | grep sd</div><div class="line">Disk /dev/sda: 21.5 GB, 21474836480 bytes, 41943040 sectors</div><div class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</div><div class="line">/dev/sda2         2099200    41943039    19921920   8e  Linux LVM</div><div class="line">Disk /dev/sdb: 21.5 GB, 21474836480 bytes, 41943040 sectors</div></pre></td></tr></table></figure><p>打印出的/dev/sdb即是我添加的硬盘，由于它是新添加的硬盘，所以没有像sda那样的分区( 即sda1、sda2)。如果有在Windows上使用磁盘管理器的经验的话，就会知道新添加的硬盘是无法直接使用的，需要给该硬盘进行分区，使得Linux系统“认识”它。</p><h1 id="fdisk工具添加分区"><a href="#fdisk工具添加分区" class="headerlink" title="fdisk工具添加分区"></a>fdisk工具添加分区</h1><p>根据上一步的结果，我们知道新加的硬盘名称为/dev/sdb， 因此我们可以直接使用<code>fdisk</code>给该硬盘进行分区。<code>fdisk</code>是Linux上一个类似于Windows上的磁盘管理器的工具，它简便易用，可以方便的进行硬盘分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# fdisk /dev/sdb</div><div class="line">Welcome to fdisk (util-linux 2.23.2).</div><div class="line"></div><div class="line">Changes will remain in memory only, until you decide to write them.</div><div class="line">Be careful before using the write command.</div><div class="line"></div><div class="line"></div><div class="line">Command (m for help): m</div><div class="line">Command action</div><div class="line">   a   toggle a bootable flag</div><div class="line">   b   edit bsd disklabel</div><div class="line">   c   toggle the dos compatibility flag</div><div class="line">   d   delete a partition</div><div class="line">   g   create a new empty GPT partition table</div><div class="line">   G   create an IRIX (SGI) partition table</div><div class="line">   l   list known partition types</div><div class="line">   m   print this menu</div><div class="line">   n   add a new partition</div><div class="line">   o   create a new empty DOS partition table</div><div class="line">   p   print the partition table</div><div class="line">   q   quit without saving changes</div><div class="line">   s   create a new empty Sun disklabel</div><div class="line">   t   change a partition&apos;s system id</div><div class="line">   u   change display/entry units</div><div class="line">   v   verify the partition table</div><div class="line">   w   write table to disk and exit</div><div class="line">   x   extra functionality (experts only)</div><div class="line"></div><div class="line">Command (m for help):</div></pre></td></tr></table></figure><p>输入<code>m</code>可查看提示，根据提示可知，输入<code>n</code>可以添加一个新分区。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# fdisk /dev/sdb</div><div class="line">Welcome to fdisk (util-linux 2.23.2).</div><div class="line"></div><div class="line">Changes will remain in memory only, until you decide to write them.</div><div class="line">Be careful before using the write command.</div><div class="line"></div><div class="line"></div><div class="line">Command (m for help): n</div><div class="line">Partition type:</div><div class="line">   p   primary (1 primary, 0 extended, 3 free)</div><div class="line">   e   extended</div><div class="line">Select (default p):</div><div class="line">Using default response p</div><div class="line">Partition number (2-4, default 2):</div><div class="line">First sector (10485760-41943039, default 10485760):</div><div class="line">Using default value 10485760</div><div class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (10485760-41943039, default 41943039):</div><div class="line">Using default value 41943039</div><div class="line">Partition 2 of type Linux and of size 15 GiB is set</div><div class="line"></div><div class="line">Command (m for help):</div></pre></td></tr></table></figure><p>输入<code>n</code>后，会有一个向导指引创建一个新分区，分为以下几步。</p><ol><li>选择分区类型，根据上面的信息可以看出，默认是 <code>primary</code>类型</li><li>选择分区号，由于我已经创建了一个分区，因此它提示我输入2-4内的整数，当前默认为2，创建后的分区为/dev/sdb2。硬盘最多可以分为4个分区，这个跟MBR和扇区的知识有关系，大概是因为硬盘为分区表保留了64字节，而每个分区参数占16个字节，因此只能存4个分区表，但由于分区可以分为主分区和拓展分区，借助拓展分区，可以分4个以上的分区，可以把拓展分区想象成指向了一块新的硬盘。最新的电脑一般默认采用GPT分区表，几乎没有限制（128个），参考<a href="https://www.ithome.com/html/win8/58192.htm" target="_blank" rel="external">MBR和GPT表</a></li><li>选择所创建分区的起始位置，推荐默认，因为这样可以从硬盘剩余空间的开头创建新分区。</li><li>选择分区的终止扇区位置，只能输入提示范围内的整数值，这个需要进行简单的计算，由于我新增的硬盘为20G,而我希望新分区为5G，因此将最后一个扇区41943039除以4，再加上3步骤中的起始扇区位置即可。</li></ol><p>上面四步结束后，新的分区已经创建成功，但该分区表目前还在内存中存储，并没有写入硬盘，需要输入<code>w</code>命令，将分区表写入，此时fdisk命令返回。</p><h1 id="格式化新分区"><a href="#格式化新分区" class="headerlink" title="格式化新分区"></a>格式化新分区</h1><p>新分区是没有任何格式的，因此操作系统无法进行读写，因此需要将新分区进行格式化。</p><p>查看新分区是否创建成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# ll /dev/sd*</div><div class="line">brw-rw----. 1 root disk 8,  0 Oct 17 20:31 /dev/sda</div><div class="line">brw-rw----. 1 root disk 8,  1 Oct 17 20:31 /dev/sda1</div><div class="line">brw-rw----. 1 root disk 8,  2 Oct 17 20:31 /dev/sda2</div><div class="line">brw-rw----. 1 root disk 8, 16 Oct 19 15:04 /dev/sdb</div><div class="line">brw-rw----. 1 root disk 8, 17 Oct 19 15:04 /dev/sdb1</div></pre></td></tr></table></figure><p>可以看到，已经有一个<code>/dev/sdb1</code>的设备了，现在进行格式化，centos系统下，格式化ext4的格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# mkfs.ext4 /dev/sdb1</div></pre></td></tr></table></figure><p>新分区已经格式化成功，下面可以挂载了。</p><h1 id="挂载新分区"><a href="#挂载新分区" class="headerlink" title="挂载新分区"></a>挂载新分区</h1><p>因为我使用的是httpd搭建的内网yum源，需要放置CDH的文件目录为<code>/var/www/html/cdh</code>，因此我需要将新分区挂载到该目录下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@master ~]# mount /dev/sdb1 /var/www/html/cdh</div></pre></td></tr></table></figure><p>已经挂载了5G大小的硬盘分区到该目录了，下面可以将CDH的包解压到该目录下了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在搞使用CDH安装Hadoop的时候，需要搭建一个内网的yum源(参考&lt;a href=&quot;http://www.wangjialong.cc/2017/09/14/private_yum/&quot;&gt;使用httpd搭建内网yum源&lt;/a&gt;)，并把CDH的RPM包放上去，方便虚拟机内网使用yum进行安装。由于我最开始虚拟机内网yum源只设置了20G的磁盘，硬盘剩余空间已经不够用，因此考虑给该虚拟机添加硬盘，并将该硬盘挂载到httpd的子目录上，在该磁盘上单独放CDH的包。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="http://www.wangjialong.cc/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="运维" scheme="http://www.wangjialong.cc/tags/%E8%BF%90%E7%BB%B4/"/>
    
      <category term="VMware" scheme="http://www.wangjialong.cc/tags/VMware/"/>
    
      <category term="新增硬盘" scheme="http://www.wangjialong.cc/tags/%E6%96%B0%E5%A2%9E%E7%A1%AC%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>MapReduce中的shuffle详解</title>
    <link href="http://www.wangjialong.cc/2017/10/10/shuffle/"/>
    <id>http://www.wangjialong.cc/2017/10/10/shuffle/</id>
    <published>2017-10-09T16:00:00.000Z</published>
    <updated>2017-10-24T12:03:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>shuffle在某些情况下，表达的意义为reduce任务获取map输出的这部分过程，也就是通常意义上的“map-shuffle-reduce”。如果是这种情况下，shuffle表示的是将map输出的键值对，按照key值进行了一个groupby操作，最后得到&lt; key, list[key] &gt;的过程。而在这里，shuffle包含了从map输出到reducer的整个过程，包括了写入磁盘、分区、排序等步骤，有利于理解工作机制，优化MapReduce程序。</p><a id="more"></a><h1 id="shuffle简述"><a href="#shuffle简述" class="headerlink" title="shuffle简述"></a>shuffle简述</h1><p><img src="http://ow9czedj7.bkt.clouddn.com/17-10-9/56739194.jpg" alt="shuffle"></p><p>由上图(<em>引用自<a href="http://www.cnblogs.com/yangyquin/p/5021234.html" target="_blank" rel="external">shuffle和排序</a></em>)所示，shuffle是一个横跨map task 和reduce task的过程，它是map 和 reduce的一个数据桥梁，负责将map输出作为输入传给reducer。在map端包括了写入缓冲区，溢出到磁盘，分区与排序等步骤；在reduce端则包括了复制数据、归并数据、reduce阶段等步骤。</p><h1 id="map端"><a href="#map端" class="headerlink" title="map端"></a>map端</h1><p>map函数产生输出时，出于效率的原因并不会直接写入硬盘，而是先放到一个环形内存缓存区中，并将缓存的数据按照key值进行一个预排序。缓冲区默认为100MB，该值可以通过io.sort.mb属性来调整。一旦达到阈值(io.sort.spill.percent, 默认为0.8)，则后台进程开始将内容溢出到磁盘。溢出过程中，map输出仍写入缓冲区，在此期间缓冲区被填满，则会将map阻塞，知道该溢出过程结束。</p><p>每个溢出过程都会产生一个文件存到mapred.local.dir属性指定的目录中，在上图中，共产生了三个溢出到磁盘的文件。在溢出到磁盘之前，会根据reducer的数量划分分区，如图中共划分了3个分区，每个分区中，都按键进行内排序，如果指定了combiner，则在排序后的输出上进行，以减少写到磁盘和传递给reducer的数据。上图中每个溢出文件都有3个分区，每个分区内数据都是排好序的。</p><p>当map任务结束后，会将溢出到磁盘的文件进行一个合并，如图中，将3个文件合并成了一个文件，合并好的文件中每个分区内的数据也是排好序的。在map输出到磁盘时，可以通过设置mapred.compress.map.output为true和指定mapred.map.output.compression.codec指定压缩格式，这样可以加快溢出到磁盘的速度。</p><p>reducer是通过http方式获得输出文件的分区的，如上图中，第一个reducer获取了第一个分区。</p><h1 id="reduce端"><a href="#reduce端" class="headerlink" title="reduce端"></a>reduce端</h1><p>reducer会将各个map task上最后溢出的那个文件的对应分区复制到本地，由于map任务的完成时间可能不同，因此只要一个任务完成，reduce任务就开始复制其输出。reduce可以并行的复制map的输出，默认为5个线程，可以通过设置mapred.reduce.parallel.copies属性来改变。对于指定的作业，jobtracker（或App master）知道map输出和tasktracker的映射关系。reducer线程定期询问jobtracker以获取map输出的位置，直到获取全部的输出位置</p><p>复制完所有map输出后，就进入到上图中的“sort phase”，但它并不是一个严格意义上的排序过程，可以将它理解成归并排序中的merge过程，将若干个排好序的序列，归并成一个有序文件。这个过程根据合并因子(io.sort.factor设置，默认为10)进行，如果有50个map的输出，而合并因子为10，则每次最多合并10个map输出，因此最后会有5个中间文件。</p><p>在reduce阶段，直接将上面的5个中间文件合并成一个已排序的文件输入给reduce函数，最后的合并不需要磁盘的读写，只需要内存和磁盘片段的配合即可。</p><p>在“sort phase”时，由于最后一趟的合并总是将结果直接输入给reduce，而没有磁盘写入过程，因此可以据此进行优化。比如如果合并因子为10，有40个文件，此时不会再四趟中每次合并10个文件而得到4个文件，相反，第一趟只合并4个文件，随后的三趟每次合并10个文件，在最后一趟中，4个已合并的文件（4，10，10，10）和6个未合并的文件合并给reduce函数，这并不改变合并次数，却使得合并过程中磁盘只写入了4+10+10+10=34个文件，从而减少了磁盘的数据量。</p><h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>本文是结合《Hadoop权威指南》shuffle和排序章节整理的读书笔记，方便日后的查阅。shuffle是MapReduce中数据传输的核心步骤，深入理解该部分的实现细节，有助于MapReduce程序的优化，通过减少网络上的数据传输，可以有效的提高MapReduce程序的执行效率。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;shuffle在某些情况下，表达的意义为reduce任务获取map输出的这部分过程，也就是通常意义上的“map-shuffle-reduce”。如果是这种情况下，shuffle表示的是将map输出的键值对，按照key值进行了一个groupby操作，最后得到&amp;lt; key, list[key] &amp;gt;的过程。而在这里，shuffle包含了从map输出到reducer的整个过程，包括了写入磁盘、分区、排序等步骤，有利于理解工作机制，优化MapReduce程序。&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/tags/hadoop/"/>
    
      <category term="MapReduce" scheme="http://www.wangjialong.cc/tags/MapReduce/"/>
    
      <category term="shuffle" scheme="http://www.wangjialong.cc/tags/shuffle/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 55 Jump Game从回溯到动态规划</title>
    <link href="http://www.wangjialong.cc/2017/09/29/leetcode55/"/>
    <id>http://www.wangjialong.cc/2017/09/29/leetcode55/</id>
    <published>2017-09-28T16:00:00.000Z</published>
    <updated>2017-10-24T12:03:30.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>动态规划是一个降低时间的很有效的方法，通常一个可以使用递归从上到下来解决的题目，必定可以转化为动态规划，从下往上计算，并通过设置一个数组存放子问题的解，来降低问题的求解步骤。LeetCode上的第55题可以使用回溯法和动态规划来解决，但回溯法会造成栈溢出，下面讲解我的解题思路。</p><a id="more"></a><h1 id="题目介绍"><a href="#题目介绍" class="headerlink" title="题目介绍"></a>题目介绍</h1><p>给定一个正整数的数组，你起始的位置位于数组的第一个下标处（也就是0），数组中的每个元素代表在该位置可以跳跃的最大距离（只能向index增加的方向跳跃），判断是否有一条跳跃路径，可以使得你跳到最后一个下标处（也就是length-1）。<br>示例：<br>A = [2,3,1,1,4], return true.</p><p>A = [3,2,1,0,4], return false.</p><p>原题链接 <a href="https://leetcode.com/problems/jump-game/description/" target="_blank" rel="external">55. Jump Game</a></p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>相信玩过类似大富豪这样的游戏的同学，理解起这个问题来不会太困难。它相当于有一个起点、一个目的地，从起点到目的地是一个个的格子（只能跳整数个），每个格子规定了当前格子能够跳跃的最大值，让我们来求是否有一条路径可以从起点到终点，文字不太直观，下面我们通过图来展示一下上面的示例。</p><p>当 A = [2,3,1,1,4]</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/90212410.jpg" alt=""></p><p>由上图，从0的位置最大可以跳2格，选择跳一格，到达下标为1的位置，此时最大可以跳3格，选择跳3格到达终点。因此，应该返回 true。A = [3,2,1,0,4]的情况在此不再做分析。下面开始正式解题。</p><h1 id="Round-1"><a href="#Round-1" class="headerlink" title="Round 1"></a>Round 1</h1><p>第一个回合，根据从起点到终点的特性，理所当然的想到了将问题转化为图问题，于是，我画了下图。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/75746144.jpg" alt=""></p><p>圆形中的数字代表下标，箭头为单向的，因此，问题转变为从0到4的图遍历。但刚定义为Node类我就卡住了。两个原因：</p><ul><li>每个节点的孩子节点（单向箭头指向的节点）个数不确定</li><li>太占内存了，每个node都是一个对象</li></ul><p>Round 1， defeated ！</p><h1 id="Round-2"><a href="#Round-2" class="headerlink" title="Round 2"></a>Round 2</h1><p>虽然上面的图使我的图遍历解法宣告失败，但是却给了我另一个灵感，就是树遍历的深度优先算法，当到达叶子节点的时候，算法开始回溯，直到回到一个有没有遍历到的叶子节点，再接着向下遍历。</p><p>此问题也可以使用回溯算法进行求解，算法的核心思想如下：</p><ol><li>从index的位置开始，取得当前能够跳跃的最大值n</li><li>让i从1到n开始遍历，循环判断当前跳i步，到达的位置是否可以到达终点</li><li>若跳i步后，index &gt;最后的位置，则可以到达终点，返回true，否则，递归判断跳i步之后的位置是否可以到达终点</li><li>若递归返回false的话，则让i+1,进行下一步循环判断是否可以到达终点</li><li>若所有的循环和递归都返回后还没有返回true，则返回false</li></ol><p>上面那段叙述可能连我自己也看不懂啥意思，没关系，“talk is cheap, show me the code”，下面立即上代码，一目了然。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc55</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</div><div class="line">        lc55 test = <span class="keyword">new</span> lc55();</div><div class="line">        System.out.println(<span class="string">"res ? "</span> + test.canJump(nums));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">boolean</span>[] flag;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.fill(flag, <span class="keyword">true</span>);</div><div class="line">        <span class="keyword">if</span> (check(nums, <span class="number">0</span>)) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span>(index &lt; <span class="number">0</span> || !flag[index]) &#123;</div><div class="line">            flag[index] = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span>(index + nums[index] + <span class="number">1</span> &gt;= nums.length)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">int</span> n = nums[index];</div><div class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (check(nums, index + n)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">            --n;</div><div class="line">        &#125;</div><div class="line">        flag[index] = <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上面的代码应当返回false，结果正确，于是粘贴到LeetCode上run了一下，期望输出一致，赶紧提交吧，傻眼了，栈溢出。。。</p><p>回溯算法由于频繁的递归调用，而每次方法的调用都需要进行压榨动作，当方法的嵌套调用过深的时候，就形成了栈溢出问题，虽然算法是正确的，然而AC不了啊，下面继续优化。</p><h1 id="Round-3"><a href="#Round-3" class="headerlink" title="Round 3"></a>Round 3</h1><p>解决回溯问题的栈溢出，我们一下子就想到了将递归变成循环，因为循环是递归的逆过程。细心的朋友可能发现了，上面代码中，我已经用flag数组来存放子问题的解了，当子问题为false的时候，无需在进行判断，直接返回false，因为我们之前已经求解了一遍了。因此，结合循环和子问题两个思路，我想到了使用动态规划来解决栈溢出的问题。</p><p>动态规划最重要的就是确定子问题了，通过之前的分析，不难看出，如果从3的位置可以调到终点，而从0的位置可以跳到3的位置的话，那么从0的位置也可以跳到终点。因此，我们的动态规划算法应当是从后向前遍历的，递推公式为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flag[i] = flag[i+1] || flag[i+2] || ... || flag[i+n]</div></pre></td></tr></table></figure></p><p>其中n为i位置可以跳的最大步数，有一个特殊情况，如果i+n &gt; last_index的话，则可以直接判断flag[i]为true。<br>有了递推公式，不难写出相应的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc55</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</div><div class="line">        lc55 test = <span class="keyword">new</span> lc55();</div><div class="line">        System.out.println(<span class="string">"res ? "</span> + test.canJump(nums));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span>[] flag;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.fill(flag, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span>(i + nums[i] + <span class="number">1</span> &gt;= nums.length) &#123;</div><div class="line">                flag[i] = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> n = nums[i];</div><div class="line">                <span class="keyword">while</span>(n&gt;<span class="number">0</span>) &#123;</div><div class="line">                    <span class="keyword">if</span> (((i + n) &lt; nums.length ) &amp;&amp; flag[i + n]) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i+n &gt; nums.length) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        --n;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>这下应该稳了吧，开开心心提交上去，栈溢出倒是解决了，但是出现了一个新的问题，超时！ 纳尼？！ 动态规划不是不计算子问题了吗？怎么还会超时呢，这不科学！</p><h1 id="Final-Round"><a href="#Final-Round" class="headerlink" title="Final Round"></a>Final Round</h1><p>通过查看LeetCode上提交的错误信息，可以发现测试用例形如 [29999,29998,29997,…,4,3,2,1,1,0,0]。 聪明的你可能已经发现了，数字从后往前每一步都只加一，也就是说后一格为false的话，那向前一格，数字只增加一的话，那前一格也必定为false啊，文字不清楚，下面通过画图分析。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/77658785.jpg" alt=""></p><p>由上图可知，2所在的格子已经求得为false，i–到达3所在的格子，由于3后面的为2的格子求得为false，所以两个1所在的格子也为false，因此3在求解flag的时候，不需要求解2、1、1这三个格子，因为他们都为false。总结就是如果i所在的格子最大跳n格，i+1所在的格子最大跳n1格，而i+1的格子为false，则只需要求解从i+2+n1格到i+n格的子问题即可，上图中两个0所在的格子。根据这个思想，可以得到下面的优化的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Arrays;</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">lc55</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">4</span>&#125;;</div><div class="line">        lc55 test = <span class="keyword">new</span> lc55();</div><div class="line">        System.out.println(<span class="string">"res ? "</span> + test.canJump(nums));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">boolean</span>[] flag;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</div><div class="line">        flag = <span class="keyword">new</span> <span class="keyword">boolean</span>[nums.length];</div><div class="line">        Arrays.fill(flag, <span class="keyword">false</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=nums.length-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</div><div class="line">            <span class="keyword">if</span>(i + nums[i] + <span class="number">1</span> &gt;= nums.length) &#123;</div><div class="line">                flag[i] = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">int</span> n = nums[i];</div><div class="line">                <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</div><div class="line">                    flag[i] = flag[i + <span class="number">1</span>];</div><div class="line">                <span class="keyword">if</span>(n - nums[i+<span class="number">1</span>] &lt; <span class="number">2</span>) &#123; <span class="comment">//若n只比nums[i+1]大1，则flag[i] = flag[i + 1];</span></div><div class="line">                    n = <span class="number">0</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">while</span>(n - <span class="number">1</span> &gt; nums[i+<span class="number">1</span>]) &#123;   <span class="comment">//只计算从i+2+n1格到i+n格的子问</span></div><div class="line">                    <span class="keyword">if</span> (((i + n) &lt; nums.length ) &amp;&amp; flag[i + n]) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i+n &gt; nums.length) &#123;</div><div class="line">                        flag[i] = <span class="keyword">true</span>;</div><div class="line">                        n = <span class="number">0</span>;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        --n;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> flag[<span class="number">0</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>再次提交代码，终于Accept了，看到绿色的返回值真是开心</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>分析问题和解决问题的过程是最让人兴奋的，遇到一下子解决不了的问题时，不要轻易的放弃，尝试着继续改进一下，等看到绿色的AC时，往往是最开心的一刻。而即使自己最后真的败下阵来，也没关系，这时候去看大神的解法，会让自己有更多的感受和收获，记忆也会更加的牢固。好了，毒鸡汤撒完了，我去看大神界面工整且逻辑清晰的代码去了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;动态规划是一个降低时间的很有效的方法，通常一个可以使用递归从上到下来解决的题目，必定可以转化为动态规划，从下往上计算，并通过设置一个数组存放子问题的解，来降低问题的求解步骤。LeetCode上的第55题可以使用回溯法和动态规划来解决，但回溯法会造成栈溢出，下面讲解我的解题思路。&lt;/p&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://www.wangjialong.cc/categories/algorithm/"/>
    
    
      <category term="Java" scheme="http://www.wangjialong.cc/tags/Java/"/>
    
      <category term="LeetCode、动态规划" scheme="http://www.wangjialong.cc/tags/LeetCode%E3%80%81%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper是动物管理员吗</title>
    <link href="http://www.wangjialong.cc/2017/09/29/zookeeper1/"/>
    <id>http://www.wangjialong.cc/2017/09/29/zookeeper1/</id>
    <published>2017-09-28T16:00:00.000Z</published>
    <updated>2018-01-20T02:05:29.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>熟悉Hadoop的同学肯定听过这么一句话：“Zookeeper是动物管理员，管着大象（Hadoop）、蜜蜂（Hive）和小猪（Pig）”。刚开始接触到的时候感觉，哇，Zookeeper好厉害啊，都可以管理Hadoop、Hive、Pig了。但后面接触到Hive和Pig的时候，发现他们好像只跟MapReduce有关系啊，因此，我不禁有了以下的疑问。博客原文地址<a href="http://www.wangjialong.cc/2017/09/29/zookeeper1/#more">Zookeeper是动物管理员吗</a></p><a id="more"></a><h1 id="Zookeeper到底是不是动物管理员？"><a href="#Zookeeper到底是不是动物管理员？" class="headerlink" title="Zookeeper到底是不是动物管理员？"></a>Zookeeper到底是不是动物管理员？</h1><p>这个问题的答案可以从Zookeeper的的官网标志图初探端倪。</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/93495054.jpg" alt="Zookeeper slogan"></p><p>由上图，Zookeeper是一个穿着工装，拿着铁锹的工人啊，这不符合管理员的形象吧，管理员不应该是西装革履的吗？好吧，有些牵强，那我们来看看keeper这个词的翻译，使用百度在线翻译的结果如下：</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-9-29/36748004.jpg" alt=""></p><p>门将是什么鬼？ 还好下面还有翻译，饲养员、保管人、负责人、监护人。这几个词好像都跟管理员有一些差距，有了初步的认识后，是时候深入Zookeeper的原理来进行分析了。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这里我只做简单的介绍，更加详细的内容可以参看最后的参考博客。</p><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>Zookeeper中的角色主要分类如下表</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-18/22845559.jpg" alt="zookeeper roles"></p><ul><li>注意：zkServer默认存在Observer角色，具体配置参看<a href="http://zookeeper.apache.org/doc/trunk/zookeeperObservers.html" target="_blank" rel="external">ZooKeeper Observers</a></li></ul><p>集群模型如下:</p><p><img src="http://ow9czedj7.bkt.clouddn.com/17-11-18/13063958.jpg" alt="zookeeper service"></p><p>结合角色说明表格和上图进行说明，Hadoop中使用Zookeeper的组件如YARN和HBase，都是上图中的client，client通过与server进行连接获取Zookeeper server的服务。那么通过什么方式连接呢？</p><h2 id="会话-session"><a href="#会话-session" class="headerlink" title="会话(session)"></a>会话(session)</h2><p>会话记录client与server的连接，client不需要连接所有的server，只需要连接其中一个就可以获得一致性的读写服务。session对应到两种连接方式：心跳连接和watcher监听。</p><h2 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h2><p>上一节中说的一致性读写服务所操作的对象就是数据节点。Zookeeper的数据模型如下图：</p><p><img src="http://www.wuzesheng.com/wp-content/uploads/2013/12/zookeeper-tree.jpg" alt="image"></p><p>ZooKeeper数据模型的结构与Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个ZNode。每个ZNode都可以通过其路径唯一标识，图中每个节点左侧即为其路径唯一标识。</p><p>注：<br>这里的ZNode可以理解成既是Unix里的文件，又是Unix里的目录。因为每个ZNode不仅本身可以写数据（相当于Unix里的文件），还可以有下一级文件或目录（相当于Unix里的目录）。</p><p>在ZooKeeper中，ZNode可以分为持久节点和临时节点两类。</p><p><strong>持久节点</strong></p><p>所谓持久节点是指一旦这个ZNode被创建了，除非主动进行ZNode的移除操作，否则这个ZNode将一直保存在ZooKeeper上。</p><p><strong>临时节点</strong></p><p>临时节点的生命周期跟客户端会话绑定，一旦客户端会话失效，那么这个客户端创建的所有临时节点都会被移除。</p><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>Watcher（事件监听器），是ZooKeeper中一个很重要的特性。ZooKeeper允许用户在指定节点上注册一些Watcher，并且在一些特定事件触发的时候，ZooKeeper服务端会将事件通知到感兴趣的客户端上去。该机制是ZooKeeper实现分布式协调服务的重要特性。</p><h1 id="管理者-or-协调者"><a href="#管理者-or-协调者" class="headerlink" title="管理者 or 协调者"></a>管理者 or 协调者</h1><p>通过Zookeeper的数据节点（临时节点特性）和watcher的组合，可以满足诸如服务发布/订阅、命名服务、master选举、分布式锁等功能。而Zookeeper之所以是keeper而不是manager，正是因为它在Hadoop生态中的两大功能是选举和元数据存储，才使得它有了分布式协调者的称号。</p><p>元数据指的是配置信息、服务注册列表等，这使得Zookeeper更像是一个分布式的注册表。当client需要使用Zookeeper时，如HBase Master需要选举一个主节点，那么他们就并发的去Zookeeper上创建一个临时节点（节点名称一样），Zookeeper的分布式锁可以保证只有一个client创建成功，最后创建成功的那个节点，就当选为主节点。</p><p>Zookeeper在Hadoop中的应用是HDFS和YARN的HA，在HBase中的应用有选举与主备切换、系统容错（RegionServer挂掉后，HMaster获知）、Region状态信息的管理。下面我们来看一下Zookeeper是如何让HMaster获知RegionServer挂掉的信息的。</p><p>当HBase启动时，每个RegionServer都会到ZooKeeper的/hbase/rs节点下创建一个信息节点（临时节点，下文中，我们称该节点为”rs状态节点”），例如/hbase/rs/[Hostname]，同时，HMaster会对这个节点注册监听。当某个 RegionServer 挂掉的时候，ZooKeeper会因为在一段时间内无法接受其心跳（即 Session 失效），而删除掉该 RegionServer 服务器对应的 rs 状态节点。与此同时，HMaster 则会接收到 ZooKeeper 的 NodeDelete 通知，从而感知到某个节点断开，并立即开始容错工作。也就是说，Zookeeper是通过心跳机制来维护临时节点信息的，如果心跳发生了timeout，则Zookeeper删除该临时节点，然后通知注册过该临时节点监听的HMaster，所以Zookeeper默认临时节点删除后，该RegionServer处于无法工作状态，至于是网络延时原因还是该RegionServer确实挂掉了，Zookeeper不管。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>Zookeeper在Hadoop生态中十分重要，但它并没有上升到管理员的高度，Hadoop中使用Zookeeper服务的组件都有自己的master（NameNode、ResourManager、HMaster），各组件视自己的需求，交付给Zookeeper不同程度的权力。NameNode在实现HA的时候，需要用到Zookeeper的选举和watcher功能，因此交付给Zookeeper两个NameNode，让它来决定谁为Active；YARN的HA也是如此。HMaster交给Zookeeper的权力比较大，HMaster选举与主备切换、系统容错、RootRegion管理、Region状态管理和分布式SplitWAL任务管理等都交给了Zookeeper，让Zookeeper来管理HMaster的主备以及RegionServer信息等。Zookeeper相当于是古代的丞相，皇帝（NameNode、HMaster）给它多少权力，它就执行多大的功能。或许有一天，Zookeeper会成为Hadoop生态的“管仲”、“商鞅”，而那一天会不会实现，就要看Hadoop生态的发展了。。。</p><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ul><li><a href="http://www.wangjialong.cc/2017/09/27/etcd&amp;zookeeper/">Zookeeper与etcd的对比</a></li><li><a href="http://linbingdong.com/2017/01/10/ZooKeeper原理及其在Hadoop和HBase中的应用/" target="_blank" rel="external">ZooKeeper原理及其在Hadoop和HBase中的应用</a></li><li><a href="http://cailin.iteye.com/blog/2014486" target="_blank" rel="external">Zookeeper原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;熟悉Hadoop的同学肯定听过这么一句话：“Zookeeper是动物管理员，管着大象（Hadoop）、蜜蜂（Hive）和小猪（Pig）”。刚开始接触到的时候感觉，哇，Zookeeper好厉害啊，都可以管理Hadoop、Hive、Pig了。但后面接触到Hive和Pig的时候，发现他们好像只跟MapReduce有关系啊，因此，我不禁有了以下的疑问。博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2017/09/29/zookeeper1/#more&quot;&gt;Zookeeper是动物管理员吗&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/tags/hadoop/"/>
    
      <category term="zookeeper" scheme="http://www.wangjialong.cc/tags/zookeeper/"/>
    
      <category term="HBase" scheme="http://www.wangjialong.cc/tags/HBase/"/>
    
  </entry>
  
  <entry>
    <title>zookeeper与etcd的类比</title>
    <link href="http://www.wangjialong.cc/2017/09/27/etcd&amp;zookeeper/"/>
    <id>http://www.wangjialong.cc/2017/09/27/etcd&amp;zookeeper/</id>
    <published>2017-09-26T16:00:00.000Z</published>
    <updated>2018-01-20T02:06:03.080Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>最近在看到Pachyderm的介绍时，看到作者拿YARN和Kubernetes做类比，拿Zookeeper和etcd做对比。YARN和Kubernetes的类比还相对比较好理解，毕竟他们都有资源管理和调度的职能，只不过YARN上运行的对象是JVM，而Kubernetes上运行的是容器。但是拿Zookeeper和etcd来类比我就有些不懂了，在我之前的概念里zookeeper并不是一个存储组件啊，因此有了本文的过程。博客原文地址<a href="http://www.wangjialong.cc/2017/09/27/etcd&amp;zookeeper/#more">zookeeper与etcd的类比</a></p><a id="more"></a><h1 id="Zookeeper和etcd可以做类比吗？"><a href="#Zookeeper和etcd可以做类比吗？" class="headerlink" title="Zookeeper和etcd可以做类比吗？"></a>Zookeeper和etcd可以做类比吗？</h1><p>etcd的官网介绍是一个分布式的K/V存储，而Zookeeper的官网介绍是一个高度可用的分布式协调者。看起来他们做的事情完全不同啊，那我们来比较一下功能介绍。</p><table><thead><tr><th>功能</th><th>etcd</th><th>Zookeeper</th></tr></thead><tbody><tr><td>分布式锁</td><td>有</td><td>有</td></tr><tr><td>watcher</td><td>有</td><td>有</td></tr><tr><td>一致性算法</td><td>raft</td><td>zab</td></tr><tr><td>选举</td><td>有</td><td>有</td></tr><tr><td>元数据(metadata)存储</td><td>有</td><td>有</td></tr></tbody></table><ul><li>watcher指的是订阅/通知，当一个值改变时，通知订阅过的节点，在etcd中是K/V值对的改变，在Zookeeper中是znode的改变（值改变、节点删除等）</li><li>raft和zab都是paxos算法的变形，都是为了解决分布式系统中的读写一致性问题</li><li>选举都是通过相应的一致性算法实现的</li></ul><blockquote><p>功能总结的不到位，欢迎补充</p></blockquote><p>从功能上看，他们干的事好像也都差不多，分布式的一致性、选举算法、分布式锁，那么，我们来看一下各自的典型应用吧。</p><table><thead><tr><th>应用场景</th><th>etcd</th><th>Zookeeper</th></tr></thead><tbody><tr><td>发布与订阅（配置中心）</td><td>有</td><td>有</td></tr><tr><td>软负载均衡</td><td>有</td><td>有</td></tr><tr><td>命名服务(Naming Service)</td><td>有</td><td>有</td></tr><tr><td>服务发现</td><td>有</td><td>有</td></tr><tr><td>分布式通知/协调</td><td>有</td><td>有</td></tr><tr><td>集群管理与Master选举</td><td>有</td><td>有</td></tr><tr><td>分布式锁</td><td>有</td><td>有</td></tr><tr><td>分布式队列</td><td>有</td><td>有</td></tr></tbody></table><blockquote><p>分别参考了<a href="http://jm.taobao.org/2011/10/08/1232/" target="_blank" rel="external">ZooKeeper典型应用场景一览</a>和<a href="http://www.sel.zju.edu.cn/?p=523" target="_blank" rel="external">ETCD：从应用场景到实现原理的全方位解读</a></p></blockquote><h1 id="zookeeper可以作为分布式存储吗"><a href="#zookeeper可以作为分布式存储吗" class="headerlink" title="zookeeper可以作为分布式存储吗?"></a>zookeeper可以作为分布式存储吗?</h1><p>在应用场景上，etcd和Zookeeper也很一致，难道Zookeeper本质上是分布式存储组件，为此，我查了下 Zookeeper是否可以作为分布式存储系统？ 在知乎上的答案为 <a href="https://www.zhihu.com/question/22116083" target="_blank" rel="external">zookeeper只存元数据</a>，总结几点原因如下</p><ul><li>znode只能存1M以内的数据</li><li>写入性能低，为保证一致性，每次需要n/2+1的写入完成才算完成</li><li>zookeeper的数据是全部存储在内存,只适合存元数据</li><li>Zookeeper的使用场景是有高一致性的</li></ul><p>所以，逻辑上来说，可以。因为Zookeeper本质上是一个内存式的文件系统，它的znode就相当于dictionary和file的结合体，但是由于性能和存储容量以及使用场景来看，Zookeeper适合存有强一致性要求的配置信息，也就是元数据。</p><p>到这一步，基本搞清楚了Zookeeper的应用场景了，如果etcd可以和Zookeeper作类比的话，难道etcd不是一个分布式存储组件？</p><h1 id="etcd究竟是干啥的？"><a href="#etcd究竟是干啥的？" class="headerlink" title="etcd究竟是干啥的？"></a>etcd究竟是干啥的？</h1><p>回到etcd的官方文档，在Reference下看到一个<a href="https://coreos.com/etcd/docs/latest/learning/why.html" target="_blank" rel="external">etcd versus other key-value stores</a>目录，发现了etcd的名称由来，原来它是”/etc”和”d” for distributed 的结合体， 它存的也是大型分布式系统的配置信息，也就是distributed “/etc”</p><p>到此可知，Zookeeper和etcd解决的问题是一样的，都解决分布式系统的协调和元数据的存储，所以它们都不是一个存储组件，或者说都不是一个分布式数据库。etcd灵感来源于Zookeeper，但在实现的时候有了很多的改进。</p><ul><li>更轻量级、更易用</li><li>高负载下的稳定读写</li><li>数据模型的多版本并发控制</li><li>稳定的watcher功能，通知订阅者监听值的变化</li><li>客户端协议使用gRPC协议，支持go、C++、Java等，而Zookeeper的RPC协议是自定制的，目前只支持C和Java</li><li>可以容忍脑裂现象的发生</li></ul><p>脑裂现象指的是，在一个分布式集群中，只允许一个leader协调工作，由于网络或其他原因，导致一个集群分成了两个集群，产生了两个leader同时工作，此时集群不在具备读写一致性。</p><blockquote><p>etcd是使用raft算法解决的脑裂问题，raft算法具体参考 <a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">大神制作的动画</a></p></blockquote><p>关于脑裂现象的一些推荐资料</p><ul><li><a href="http://linux-ha.org/wiki/Split_Brain" target="_blank" rel="external">Linuex-ha split-brain</a></li><li><a href="http://techthoughts.typepad.com/managing_computers/2007/10/split-brain-quo.html" target="_blank" rel="external">Split-brain, Quorum, and Fencing - updated</a></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>之前在使用etcd的时候，只是在官网看到了分布式存储，就默认它为一个存储组件，导致了对etcd的误解，这也是第一次用到的时候没有深入了解导致的，在经过和Zookeeper的比较学习之后，发现两者在很多方面有着相同的特性。以前我对Zookeeper也有一定的误解，以为它是一个协调者，一定有管理的功能，可以控制很多东西，但经过这番学习之后，发现其实Zookeeper本质上也是一个存储单元，用于存放配置信息，解决分布式中的读写一致性问题。总的来说，etcd和Zookeeper有相似的功能，做的事情也大同小异，只是可能具体的应用场景不太一样，我目前的了解是Zookeeper主要用于Hadoop组件的协调上，etcd主要用与Kubernetes上对于容器的协调上，两者都是用于存放配置信息等元数据的，随着以后的深入学习，希望可以慢慢把他们的区别理清晰。</p><blockquote><p>唉，学习就像解bug，当我知道哪错了的时候，离真相也就不远了 (ಥ_ಥ)</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;最近在看到Pachyderm的介绍时，看到作者拿YARN和Kubernetes做类比，拿Zookeeper和etcd做对比。YARN和Kubernetes的类比还相对比较好理解，毕竟他们都有资源管理和调度的职能，只不过YARN上运行的对象是JVM，而Kubernetes上运行的是容器。但是拿Zookeeper和etcd来类比我就有些不懂了，在我之前的概念里zookeeper并不是一个存储组件啊，因此有了本文的过程。博客原文地址&lt;a href=&quot;http://www.wangjialong.cc/2017/09/27/etcd&amp;amp;zookeeper/#more&quot;&gt;zookeeper与etcd的类比&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://www.wangjialong.cc/tags/hadoop/"/>
    
      <category term="etcd" scheme="http://www.wangjialong.cc/tags/etcd/"/>
    
      <category term="zookeeper" scheme="http://www.wangjialong.cc/tags/zookeeper/"/>
    
  </entry>
  
</feed>
